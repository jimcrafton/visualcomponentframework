<html>

<head>
<title>Makefiles with GNU make</title>
<link rel="stylesheet" type=text/css href="http://www.codeproject.com/styles/global.css">
</head>

<!-- HTML for article "Using the C++ RTTI/Reflection APIs in the VCF" by Jim Crafton,Jim Crafton
     URL: http://www.codeproject.com/useritems/VCF_RTTI.asp

     Article content copyright Jim Crafton,Jim Crafton
     All formatting, additions and alterations Copyright © CodeProject, 2002
-->
<!----------------------------- Ignore ----------------------------->

<body>


<h1>Makefiles with gmake</h1>
<p>When developing with command line tools like gcc/g++ the typical way to
compile and link all you code is through using what is called a Makefile and
running it through a tool called make. This is conceptually equivalent to Visual
C++'s project and workspace files (.dsp and .dsw). If you are going to do any
development (particularly open source development) on other systems than Win32
or even use other 3rd party code from other platforms, you will have to deal
with makefiles, so I thought I would write an article discussing what I have
learned.&nbsp;This article will focus on working with Makefiles for the GNU make
tool (also referred to as gmake or make). I could have written it for nmake (the Microsoft version of make), but
this has some specific syntax that is not compatible with any other make tool
(that I am aware of, but I am by no means at all proficient with nmake so I
could be wrong) so I
choose to stick with GNU's make syntax.&nbsp;</p>
<p>While I am by NO means an expert on make, I feel reasonably comfortable
enough with it to be dangerous. Most of what I have learned is either through
trial and error or because of building a similar tool and having to at least
vaguely understand what it takes to solve a similar problem. So lets look at the
simplest case first - a simple make file that will build a single file, and go
through the basic parts of the makefile.</p>
<p>First you are going to need some tools. If you are on a Win32 system, go get <a href="http://www.cygwin.com/setup.exe">cygwin</a>
- this will have all the tools you need, gcc/g++, all the headers, tar, gzip,
and most importantly: make! If you are on a linux system then there's a 95%
chance you already have all this stuff, if not go get it! Note that in this
article I will refer to g++ for use in compiling and linking, we could easily use
Microsoft's compiler/linker if we want to. In fact, we'll try this in a simple
example just to verify that this will in fact work. One other note: doing it
this way forces you to become much more familiar with your compiler from the
standpoint of having to know what the various command line switches are, so we
will get our hands dirty with some pretty low level stuff, kind of like going
from a language like VB (shudder :) ) to C++.</p>
<p>Once you have an the cygwin tools installed lets run a quick test to make
sure things work: open a command prompt using cygwin (trust me, the cygwin
command shell is way, way cooler than the simple one that comes with windows) by
clicking on the &quot;bash&quot; link and type:</p>
<p><code>make</code></p>
<p>you should get&nbsp;</p>
<p><code>make: *** No targets specified and no makefile found.  Stop.</code></p>
<p>OK this is good - you have make working</p>
<p>Try and make sure the g++ compiler is working by typing :</p>
<p><code>g++</code></p>
<p>you should get :</p>
<p><code>g++: No input files</code></p>
<p>OK at this point lets create a simple test.cpp like so</p>
<pre>
#include &lt;stdio.h&gt;


int main()&nbsp;
{
	printf( &quot;Hello World!&quot; );
	return 0;
}

</pre>

<p>obviously we can compile this without a makefile like so:</p>
<p>g++ test.cpp</p>
<p>This will automatically compile and link test.cpp and create an executable
called a.out. But of course doing this would defeat the whole point of the
article! So now lets go ahead and create a makefile. Create a file called &quot;Makefile&quot;
(no extension) and open it up for editing (at this point we could separate the
men from the boys by seeing if you can do this using emacs, but we'll do this
some other time - of course the <a href="http://www.sheldonbrown.com/real-man.html" target="_blank"> Real Men™</a> With Hairy Chests®
out there would use vi,
but enough on that ). </p>
<p>Lets edit it to read:</p>
<pre>#makefile

test.exe : test.o
g++ -o test.exe test.o

test.o : test.cpp
g++ test.cpp -c
</pre>
<p>Save this, and then at the command line type:</p>
<p><code>&nbsp;make</code></p>
<p>You should see:</p>
<p><code>Makefile:7: *** missing separator.  Stop.</code></p>
<p>Arghh. The first pitfall of a makefile author - the Achilles heel of make, so
to speak! The line with the command line arguments on it MUST start with a tab
character and be preceded with a new line or carriage return (\n or \n\r) -
anything else will result in an error. This can be extremely annoying and cause
all sorts of errors. Lets fix this by inserting a tab character:</p>
<pre>#makefile

test.exe : test.o
	g++ -o test.exe test.o

test.o : test.cpp
	g++ test.cpp -c
</pre>
<p>Save this, and then type:</p>
<p><code>&nbsp;make</code></p>
<p>Now you should see:</p>
<p><code>g++ test.cpp -c<br>
g++ -o test.exe test.o</code></p>
<p><i>Voila!</i> - your first makefile!&nbsp;</p>

<p>So lets walk through the basics of what is going on. First off, comments
obviously are indicated by the &quot;#&quot; character - it is equivalent to the
C++ &quot;//&quot; comment marker, with the same rules - i.e. it only applies to
a single line. Next, makefiles work by indicating a target, zero or more
dependencies that are required to &quot;make&quot; or build the target, and then
a &quot;rule&quot; for how to actually create the target. The rule is the part
that must, must, must be preceded by a new line or CRLF and then start with a
single tab character. That's pretty much it,
everything else that you will see in a makefile are simply bigger and more
complex elaborations of this. Of course how big and complex this can get is
pretty much up to you, and there are a whole slew of special features that can
easily render a makefile unreadable to anyone but an expert, but at heart that
is pretty much it.&nbsp;&nbsp;</p>

<p>In our case, we have a target called <code>test.exe</code>, which depends on
the file <code>test.o</code>. The make program understands that to create the
file <code>test.exe</code> we invoke the following command line: <code>g++ -o
test.exe test.o</code>. Note that the commands you invoke do not have to a
compiler - it could be any program that will somehow output a file named <code>test.exe</code>.
So if you had a program called <code>rover</code>, and it created a file called <code>test.exe</code>,
then you could replace the <code>g++ -o test.exe test.o</code>, with just plain <code>rover</code>,
and make would be perfectly happy!&nbsp;</p>
<p>This creates our executable for us, but how does our C++ file get compiled?
That happens on the next step. Our next step says we have a target called
test.o, and this target depends on the file <code>test.cpp</code>. To create <code>test.o</code>
we have to invoke the command line (I hope you're paying attention at this
point, cause this is a zinger) <code>g++ test.cpp -c</code>. So at this point we
have a basic makefile that will create our executable for us.</p>
<p>All of this works by make finding a target to build, and then following the
steps it takes to build that target. If you don't specify a target at the command
line (i.e. just typing &quot;make&quot; as opposed to say &quot;make
test.o&quot; ) it just starts at the beginning of the file and works its way
down. In our case make finds test.exe, sees that it depends on test.o, so it
looks in it's current directory (we have not specified anywhere else, either
through relative paths or absolute paths), sees that there is no test.o present,
and realizes that it needs to build teh target test.o. Sure enough, it has a
target called test.o, and this depends on test.cpp, which it finds. It then
executes its rule for test.o, which says to run the <code>g++</code> program and
pass it the command line: <code>test.cpp -c,</code> which ends up outputting the
file test.o. Now that the test.o file exists, the previous target (test.exe) can
execute it's rule, which again says to run the g++ program, passing it the command
line g++ -o test.exe test.o, which creates a test.exe file, thus fulfilling the
target for test.exe. Now since all the target is built, there is nothing else
for make to do so it exits.&nbsp;</p>
<p>To see what happens when we change the order try this:</p>
<pre>#makefile

test.o : test.cpp
	g++ test.cpp -c

test.exe : test.o
	g++ -o test.exe test.o
</pre>
<p>Now type</p>
<p><code>make</code></p>
<p>and observe the difference (delete all the .o and .exe files first)</p>
<p><code>g++ test.cpp -c</code></p>
<p>Note that all that got built was <code>test.o</code>. Since we changed the
order, and did <b><i>NOT</i></b> specify a target, make choose the first target
it encountered in the Makefile, which was <code>test.o</code> <b><i>NOT</i></b> <code>test.exe</code>.
</p>
<p>So lets make this a tad bit more interesting and add a header. Lets create a
class called Foo, and declare it in test.h and implement it in test.cpp. Switch
the makefile (if you changed it) and put the test.exe target back to it's
original position. </p>
<p>Declaration (save as test.h):</p>
<pre>#ifndef _TEST_H__
#define _TEST_H__


class Foo {
public:
	Foo();

	virtual ~Foo();
};

#endif //_TEST_H__</pre>
<p>Implementation:</p>
<pre>
#include <stdio.h>
#include &quot;Foo.h&quot;

Foo::Foo()
{
	printf( &quot;hello from instance: %p\n&quot;, this );
}


Foo::~Foo()
{
	printf( &quot;goodbye from instance: %p\n&quot;, this );
}




int main() 
{
	printf( &quot;Hello World!\n&quot; );
	
	Foo foo;

	return 0;
}

</pre>
<p>OK lets build this, type make.&nbsp;</p>
<p>Oops we get:</p>
<p><code>g++ test.cpp -c<br>
test.cpp:3: Foo.h: No such file or directory<br>
make: *** [test.o] Error 1</code></p>

<p>Doh! Astute readers will note that we put the wrong header - fix it, change <code>#include
&quot;Foo.h&quot;</code> to <code>#include &quot;test.h&quot;</code>. This was
just to show how errors get reported.</p>

<p>Now we get&nbsp;</p>

<p>$ make<br>
g++ test.cpp -c<br>
g++ -o test.exe test.o</p>
<p>OK so we are back to where we were before, and everything built ok.</p>
<p>Now lets make a quick modification to test.h. Let's add a method to the Foo
class, like so:</p>
<pre>#ifndef _TEST_H__
#define _TEST_H__


class Foo {
public:
	Foo();

	virtual ~Foo();

	void doit();
};

#endif //_TEST_H__</pre>
<p>Now lets build it and see what happens:</p>
<p>$ make<br>
make: `test.exe' is up to date.</p>
<p>Whoa! What happened? Well unfortunately make is not very smart. It knows
nothing about C or C++ files or includes or anything, so even though you changed
a file, clearly used by a source file mentioned in the target <code>test.o</code>, make knows nothing about this relationship
(i.e. the fact that <code>test.cpp</code> relies on <code>test.h</code>). So, if
you'll remember, we said that a target can have zero or more dependencies, and
that currently the target <code>test.o</code> has only one dependency: <code>test.cpp</code>.
To get make to recognize that any changes to <code>test.h</code> will cause
test.o to be rebuilt, we need to manually add this as a dependency of <code>test.o</code>,
like this:&nbsp;</p>

<pre>test.o : test.cpp <font color="#0000FF"><b>test.h</b></font>
	g++ test.cpp -c</pre>
<p>Note the new dependency we have added. Save this and try and build again:</p>
<p><code>$ make<br>
g++ test.cpp -c<br>
g++ -o test.exe test.o</code></p>
<p>Damn, we are back in business! Now any modification you make to either
test.cpp or test.h will cause test.o to be rebuilt.&nbsp;</p>
<p>Now lets make our makefile a bit more fancy, and prepare for having more than
one header file that test.cpp will rely on, which will in turn introduce
variables.</p>

<p>We are going to add a variable called HDRS that we will assign all our header
files to. Then, whenever we need to refer to these headers as dependencies for
target, we can just use the variable, and make will perform the substitution for
us. Lets add it like so:</p>
<pre>#makefile

HDRS=test.h

test.exe : test.o
	g++ -o test.exe test.o

test.o : test.cpp $(HDRS)
	g++ test.cpp -c
</pre>
<p>We assign a value to the variable HDRS by using the &quot;=&quot; sign (NO
spaces or it will not work). To refer to the value of HDRS we use the
&quot;$&quot; symbol and enclose the HDRS variable in parentheses like so: $(HDRS).
Now at first this seems silly to do it this way, but lets say we add two new
files: bar.h and baz.h, and test.cpp includes both of them. All we need to
change is the HDSR variable to read: </p>
<p><code>HDRS=test.h bar.h baz.h</code> </p>
<p>and now test.o will pick up these new dependencies. If you have a lot of
headers you can separate each header with multiple lines if you use the
&quot;\&quot; between each new line like so:</p>
<pre>HDRS=test.h\
bar.h\
baz.h</pre>
<p>Obviously this can get very hairy and you can end up with hundreds of files
if you have a large scale project. But such is life if you use make. There are
tools (I believe this is part of what autoconf does) that can automatically
generate these dependencies (though why this kind of functionality has not been
added directly into make itself is beyond me) and create a makefile for you,
however that is beyond the scope or point of this article.</p>
<p>&nbsp;Before we move on to some more advanced features, lets try and see if
we can get this to compile with the MS VC++ compiler. Modifiy the makefile like
so:</p>
<pre>#makefile

HDRS=test.h

test.exe : test.o
	link /subsystem:console /out:&quot;test.exe&quot; test.o

test.o : test.cpp $(HDRS)
	cl test.cpp /c /Fo&quot;test.o&quot;
</pre>
<p>Notice the different command line arguments. These are specific to the
Microsoft Visual C++ compiler (I have VC++ 6, VC7 may be different). Build again
and you should see: </p>
<p><code>$ make<br>
cl test.cpp /c /Fo"test.o"<br>
Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 12.00.8804 for 80x86<br>
Copyright (C) Microsoft Corp 1984-1998. All rights reserved.<br>
<br>
test.cpp<br>
link /subsystem:console /out:"test.exe" test.o<br>
Microsoft (R) Incremental Linker Version 6.00.8447<br>
Copyright (C) Microsoft Corp 1992-1998. All rights reserved.</code> </p>
<p>Cool, we can build with the MS toolchain if we want! </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>
