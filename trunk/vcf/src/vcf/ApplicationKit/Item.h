#ifndef _VCF_ITEM_H__
#define _VCF_ITEM_H__
//Item.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */



namespace VCF{



class ItemListener;

class Image;

class Model;

class ItemEvent;

class Rect;

class Point;

class GraphicsContext;

class Control;

class Item;

/**
\class ItemSort ItemSort.h "vcf/ApplicationKit/ItemSort.h"
*/
class ItemSort {
public:
	virtual ~ItemSort(){};
	
	virtual bool compare( const Item* x, const Item* y) = 0;
};


#define ITEM_CLASSID		"ED88C0AA-26AB-11d4-B539-00C04F0196DA"

/**
\class Item Item.h "vcf/ApplicationKit/Item.h"
The Item class can be used represent a single element in a model.
It's useful because as a component it gets all the automatic 
persistance abilities of a component and the ability
to easily edit it at design time through a visual form
editor (like the VCF Builder). 

The Item class has a number of virtual methods that must be implemented,
but the exact methods of implementation may vary widely. For example
it possible that in order to calculate the item's index hte item
may simply carry around a member variable that stores the index. 
An alternate approach would be to query the model the item
is attached to and ask the model for the item's index position.
*/
class APPLICATIONKIT_API Item : public Component {
public:
	/**
	*these are a general set of enumeration masks that can be used
	*to describe the items state above and beyond whether the item
	*is selected
	*/
	enum ItemDisplayState{
		idsNone =			0x0000,
		idsChecked =		0x0005,
		idsUnChecked =		0x0006,
		idsRadioUnpressed = 0x0007,
		idsRadioPressed =	0x0008
	};


	DELEGATE(ItemPaint);
	DELEGATE(ItemChanged);
	DELEGATE(ItemSelected);
	DELEGATE(ItemAdded);
	DELEGATE(ItemDeleted);

	Item():itemState_(0),model_(NULL),owningControl_(NULL) {};

	virtual ~Item(){};

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void addItemPaintHandler( EventHandler* handler ){
		ItemPaint += handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void addItemChangedHandler( EventHandler* handler ){
		ItemChanged += handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void addItemSelectedHandler( EventHandler* handler ){
		ItemSelected += handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void addItemAddedHandler( EventHandler* handler ){
		ItemAdded += handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void addItemDeletedHandler( EventHandler* handler ){
		ItemDeleted += handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void removeItemPaintHandler( EventHandler* handler ){
		ItemPaint -= handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void removeItemChangedHandler( EventHandler* handler ){
		ItemChanged -= handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void removeItemSelectedHandler( EventHandler* handler ){
		ItemSelected -= handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void removeItemAddedHandler( EventHandler* handler ){
		ItemAdded -= handler;
	}

	/**
	@deprecated - these are here for backwards compatibility
	purposes only - they'll be going away in the next release.
	*/
	void removeItemDeletedHandler( EventHandler* handler ){
		ItemDeleted -= handler;
	}

	/**
	This is called to determine if a given point is within the
	bounds of the item. The bounds may be slightly different
	than what is returned by getBounds(). For example, an item
	may not support getBounds(), but may have a non-rectangular
	region and may implement containsPoint() accordingly.
	*/
    virtual bool containsPoint( Point * pt ) = 0;

	/**
	returns the Bounds for the Item or NULL if not
	applicable.
	*/
	virtual Rect* getBounds() = 0;

	virtual void setBounds( Rect* bounds ) = 0;

	/**
	This image index represents the state of an particular item
	separate from whether or not it is selected. Typically it
	is offset horizontally from the regular image that getImageIndex()
	represents. This image is frequently used to represent check marks
	for things like tree or list controls.
	*/
	virtual long getStateImageIndex() = 0;

	virtual void setStateImageIndex( const long& index ) = 0;

	/**
	Returns the index of the item within it's model.
	*/
    virtual ulong32 getIndex() = 0;

	virtual long getImageIndex() = 0;

	virtual void setImageIndex( const long& imageIndex ) = 0;

	virtual void setIndex( const unsigned long& index ) = 0;

	/**
	Returns some application defined data. This can be anything 
	you want, hence the void* storage.
	*/
    virtual void* getData() = 0;

	/**
	Sets the application defined data.
	*/
	virtual void setData( void* data ) = 0;

	/**
	*indicates whether the item can paint itself.
	*In general this is often false, but when true,
	*the control that contains the item should
	*call the item's paint() method whenever the item
	*needs repainting.
	*/
	virtual bool canPaint() = 0;

	virtual void paint( GraphicsContext* context, Rect* paintRect ) = 0;

	virtual bool isSelected() = 0;

	virtual void setSelected( const bool& selected ) = 0;

	/**
	Represents the current state of the item
	that is entirely item specific as well as 
	specific to the control that is hosting 
	the item(s). Some controls will completely 
	ignore this value.
	*/
	long getState(){
		return itemState_;
	}

	/**
	Sets the state for the item. This is made virtual to
	allow subclasses to customize the behaviour. 
	*/
	virtual void setState( const long& state ){
		itemState_ = state;
	}

	/**
	Returns the model that this item belongs to.
	*/
	Model* getModel() {
		return model_;
	}

	/**
	Sets the model that this item is a part of. 
	Subclasses may need or want to customize this.
	*/
	virtual void setModel( Model* model ) {
		model_ = model;
	}

	/**
	All items may have a control that "owns" them.
	so in a ListControl, the ListItem::getControl() would
	return the ListControl the items were part of. 
	The control for item \em must match with the
	view control of the item's model.
	*/
	Control* getControl() {
		return owningControl_;
	}

	/**
	Sets the owning control for this item. It's made
	virtual so that subclasses can override the behaviour
	if they need to.
	*/
	virtual void setControl( Control* control ) {
		owningControl_ = control;
	}
protected:
	long itemState_;
	Model* model_;
	Control* owningControl_;
};

};


/**
*CVS Log info
*$Log$
*Revision 1.5  2006/04/07 02:35:23  ddiego
*initial checkin of merge from 0.6.9 dev branch.
*
*Revision 1.4.2.4  2006/03/18 22:17:42  ddiego
*removed par tag for doxygen comments as its not needed and
*screws up the doc formatting.
*
*Revision 1.4.2.3  2006/03/14 02:25:47  ddiego
*large amounts of source docs updated.
*
*Revision 1.4.2.2  2006/03/05 02:28:04  ddiego
*updated the Item interface and adjusted the other classes accordingly.
*
*Revision 1.4.2.1  2005/11/27 23:55:44  ddiego
*more osx updates.
*
*Revision 1.4  2005/07/09 23:14:53  ddiego
*merging in changes from devmain-0-6-7 branch.
*
*Revision 1.3.2.1  2005/06/06 02:34:06  ddiego
*menu changes to better support win32 and osx.
*
*Revision 1.3  2004/12/01 04:31:21  ddiego
*merged over devmain-0-6-6 code. Marcello did a kick ass job
*of fixing a nasty bug (1074768VCF application slows down modal dialogs.)
*that he found. Many, many thanks for this Marcello.
*
*Revision 1.2.2.1  2004/09/07 00:49:12  ddiego
*minor fixes in printg code in graphics kit, and added a 2 ways to print in the printing example.
*
*Revision 1.2  2004/08/07 02:49:08  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.3  2004/06/06 07:05:30  marcelloptr
*changed macros, text reformatting, copyright sections
*
*Revision 1.1.2.2  2004/04/29 03:43:14  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:17  ddiego
*migration towards new directory structure
*
*Revision 1.20.4.1  2004/04/26 21:58:20  marcelloptr
*changes for dir reorganization: _VCF_MACRO_H__
*
*Revision 1.20  2003/12/18 05:15:57  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.19.2.3  2003/12/02 05:50:05  ddiego
*added preliminary support for teh Action class. This will make it easier
*to hook up complimentary UI elements (such as a "copy" menu item, and a
*"copy" toolbar item) and have tehm respond to update and actions via a
*single source.
*Got rid of the old toolbar button and separator class. Merged in Marcellos
*new fixes for the Container and Splitter classes.
*Some misc fixes to the Toolbar, groups and checks now work correctly.
*
*Revision 1.19.2.2  2003/09/21 04:15:34  ddiego
*moved the cvs info data to teh bottom of the header instead of the
*top so it is easier to get to the actual header class declarations
*instead of having to wade through all the cvs info stuff.
*
*Revision 1.19.2.1  2003/09/12 00:09:32  ddiego
*added better tabbing behaviour - fixed an earlier bug.
*Code is easier to understand and it simplified the implementation
*a bit as well
*Moved around the RTTI definitions for various Appkit classes to a
*single inline and stripped them from the various class headers
*
*Revision 1.19  2003/08/09 02:56:42  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.18.2.1  2003/06/30 02:53:15  ddiego
*Allow getting the selected filter from a CommonFileDialog
*Added a quitCurrentEventLoop to the UIToolkit to allow programatic
*termination of a program if there is no main window specified
*added a getTag method to the Item class
*
*Revision 1.18  2003/05/17 20:37:03  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.17.2.1  2003/03/23 03:23:45  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.17  2003/02/26 04:30:38  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.16.20.1  2002/12/25 22:38:00  ddiego
*more stupid fixes to get rid of the damn gcc no newline warning...grrr...
*
*Revision 1.16  2002/01/24 01:46:47  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


#endif // _VCF_ITEM_H__


