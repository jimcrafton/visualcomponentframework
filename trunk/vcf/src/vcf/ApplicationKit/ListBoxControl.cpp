//ListBoxControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */

#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ListBoxControl.h"
#include "vcf/ApplicationKit/DefaultListModel.h"
#include "vcf/GraphicsKit/DrawUIState.h"


using namespace VCF;


static ListItem* previouslySelectedListItem = NULL;


ListBoxControl::ListBoxControl():
	listModel_(NULL),
	currentMaxWidth_(0),
	currentMaxHeight_(0),
	leftGutter_(2),
	rightGutter_(2),
	textBounded_(false),
	imageList_(NULL),
	stateImageList_(NULL),
	stateItemIndent_(19)
{
	setListModel( new DefaultListModel() );

	addComponent( getViewModel() );

	init();
}


ListBoxControl::ListBoxControl( ListModel* listModel ):
	listModel_(NULL),
	currentMaxWidth_(0),
	currentMaxHeight_(0),
	leftGutter_(2),
	rightGutter_(2),
	textBounded_(false),
	imageList_(NULL),
	stateImageList_(NULL),
	stateItemIndent_(19)
{
	setListModel( listModel );
	init();
}

void ListBoxControl::init()
{
	singleSelectedItem_ = NULL;

	allowsMultiSelect_ = false;

	allowsExtendedSelect_ = true;

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );

	GraphicsContext* context = getContext();
	
	defaultItemHeight_ = UIToolkit::getUIMetricValue( UIMetricsManager::mtListItemHeight );

	EventHandler* lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onItemAdded, "ListBoxControl::onItemAdded" );

	listModel_->addItemAddedHandler( lmh );

	lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onItemDeleted, "ListBoxControl::onItemDeleted" );

	listModel_->addItemDeletedHandler( lmh );

	lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onListModelContentsChanged, "ListBoxControl::onListModelContentsChanged" );

	listModel_->addContentsChangedHandler( lmh );

	selectedItemsContainer_.initContainer( selectedItems_ );

	setUseColorForBackground( true );


}

ListBoxControl::~ListBoxControl()
{
	
}

void ListBoxControl::destroy()
{
	if ( NULL != listModel_ ) {
		EventHandler* ev = getEventHandler( "ListBoxControl::onItemAdded" );
		if ( NULL != ev ) {
			listModel_->removeItemAddedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onItemDeleted" );
		if ( NULL != ev ) {
			listModel_->removeItemDeletedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onListModelContentsChanged" );
		if ( NULL != ev ) {
			listModel_->removeContentsChangedHandler( ev );
		}
		//listModel_->release();
	}

	CustomControl::destroy();
}

ListModel* ListBoxControl::getListModel()
{
	return listModel_;
}

void ListBoxControl::setListModel( ListModel * model )
{
	if ( model == listModel_ ) {
		return;
	}

	if ( NULL != listModel_ ) {
		EventHandler* ev = getEventHandler( "ListBoxControl::onItemAdded" );
		if ( NULL != ev ) {
			listModel_->removeItemAddedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onItemDeleted" );
		if ( NULL != ev ) {
			listModel_->removeItemDeletedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onListModelContentsChanged" );
		if ( NULL != ev ) {
			listModel_->removeContentsChangedHandler( ev );
		}		
	}

	listModel_ = model;


	if ( NULL != listModel_ ) {
		
	}

	setViewModel( dynamic_cast<Model*>(listModel_) );

	repaint();
}

void ListBoxControl::onListModelContentsChanged( ListModelEvent* event )
{
	repaint();



	if ( NULL != event ){
		switch ( event->getType() ){
			case LIST_MODEL_CONTENTS_DELETED: {
				singleSelectedItem_ = NULL;
				selectedItems_.clear();
			}
			break;
/*
			case LIST_MODEL_ITEM_CHANGED: {
				ListItem* item = event->getListItem();
				if ( NULL != item ){
					listBoxPeer_->removeItem( item );
					listBoxPeer_->addItem( item );
				}
			}
			break;
			*/
		}

	}
}

void ListBoxControl::onItemAdded( ListModelEvent* event )
{

	//listBoxPeer_->addItem( event->getListItem() );
	Scrollable* scrollable = getScrollable();


	double width = getWidth();

	Rect itemRect;

	double scrollW = 0;

	if ( NULL != scrollable ) {
		if ( scrollable->getVirtualViewHeight() > getHeight() ) {
			scrollW = scrollable->getVerticalScrollbarWidth();
		}
	}

	GraphicsContext* ctx = getContext();

	ListItem* item = event->getListItem();

	itemRect.setRect( 0, currentMaxHeight_, width-scrollW, currentMaxHeight_ + defaultItemHeight_ );
	item->setBounds( &itemRect );

	currentMaxHeight_ += item->getBounds()->getHeight();

	double imageWidth = 0.0;

	if ( NULL != imageList_ ) {
		imageWidth += imageList_->getImageWidth();
	}

	currentMaxWidth_ = maxVal<double>( ctx->getTextWidth( item->getCaption() ) + leftGutter_ + rightGutter_ + imageWidth, currentMaxWidth_ ); 

	if ( NULL != scrollable ) {
		if ( (getHeight() > currentMaxHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}

		if ( (getWidth() > currentMaxWidth_) && (scrollable->getHorizontalPosition() > 0.0) ) {
			scrollable->setHorizontalPosition( 0.0 );
		}

		scrollable->setVirtualViewSize( currentMaxWidth_, currentMaxHeight_ );
	}
	repaint();
}

void ListBoxControl::onItemDeleted( ListModelEvent* event )
{
	ListItem* item = event->getListItem();

	if ( item == singleSelectedItem_ ) {
		singleSelectedItem_ = NULL;
	}
	
	if ( item->isSelected() ) {
		eraseFromSelectedItems( item );
	}
	
	currentMaxHeight_ -= item->getBounds()->getHeight();
	//need to recalc currentMaxWidth_ here also if item removed was the widest item. DT

	Scrollable* scrollable = getScrollable();

	if ( NULL != scrollable ) {
		if ( (getHeight() > currentMaxHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}

		if ( (getWidth() > currentMaxWidth_) && (scrollable->getHorizontalPosition() > 0.0) ) {
			scrollable->setHorizontalPosition( 0.0 );
		}		

		scrollable->setVirtualViewSize( currentMaxWidth_, currentMaxHeight_ );	
	}

	repaint();
}

void ListBoxControl::rangeSelect( const bool & isSelected, ListItem * first, ListItem * last )
{
	if ( NULL == last ) {
		setSelectedItem( first ); //this will select it
		if ( false == isSelected ) { // we'll deselect it
			first->setSelected( isSelected );
			singleSelectedItem_ = NULL;
		}
		repaint();
	}
	else {
		if ( NULL != singleSelectedItem_ ) {
			singleSelectedItem_->setSelected( false );
		}
		singleSelectedItem_ = NULL;

		selectedItems_.clear();

		ListModel* lm = getListModel();
		if ( NULL != lm ) {
			ulong32 start = first->getIndex();
			ulong32 end = last->getIndex();
			for ( ulong32 i=start;i<=end;i++) {
				ListItem* item = lm->getItemFromIndex( i );
				if ( NULL != item ) {
					item->setSelected( isSelected );
					if ( true == isSelected ) {
						selectedItems_.push_back( item );
					}
				}
			}

			selectionChanged( NULL );
		}
	}
}


Rect ListBoxControl::getStateRect( ListItem* item )
{
	Rect result;

	if ( item->getState() != Item::idsNone ) {
		Rect* itemBounds = item->getBounds();

		result = *itemBounds;

		result.left_ += leftGutter_;
		if ( NULL != stateImageList_ ) {
			result.right_ = result.left_ + stateImageList_->getImageWidth();
			result.top_ = itemBounds->top_ + (itemBounds->getHeight()/2.0 - stateImageList_->getImageHeight()/2.0);
			result.bottom_ = result.top_ + stateImageList_->getImageHeight();
		}
		else {
			result.right_ = result.left_ + stateItemIndent_;
			result.top_ = itemBounds->top_ + (itemBounds->getHeight()/2.0 - (minVal<double>(stateItemIndent_,defaultItemHeight_)/2.0));
			result.bottom_ = result.top_ + (minVal<double>(stateItemIndent_,defaultItemHeight_));
		}

		if ( NULL != imageList_ ) {
			if ( NULL != stateImageList_ ) {
				result.offset( (maxVal<double>( imageList_->getImageWidth(), stateImageList_->getImageWidth() )), 0 );
			}
			else {
				result.offset( (maxVal<double>( imageList_->getImageWidth(), stateItemIndent_ )), 0 );
			}
		}
		else {
			if ( NULL != stateImageList_ ) {
				result.offset( (maxVal<double>( stateItemIndent_, stateImageList_->getImageWidth() )), 0 );
			}
			else {
				//result.offset( -stateItemIndent_, 0 );
			}
		}

	}
	return result;
}

void ListBoxControl::paintItemState( GraphicsContext* ctx, Rect& itemRect, ListItem* item )
{
	Rect stateRect = getStateRect( item );

	stateRect.inflate( -1, -1 );

	if ( NULL != stateImageList_ ) {
		itemRect.left_ = stateRect.right_;
		stateImageList_->draw( ctx, item->getStateImageIndex(), &stateRect );
	}
	else {		
		stateRect.inflate( -1, -1 );
		
		itemRect.left_ = stateRect.right_;

		long state = item->getState();

		ButtonState buttonState;
		buttonState.setActive( true );

		if ( (state & Item::idsChecked) || 
				(state & Item::idsUnChecked) ) {

			buttonState.setPressed( state == Item::idsChecked ? true : false );
			ctx->drawThemeCheckboxRect( &stateRect, buttonState );
		}
		else if ( (state & Item::idsRadioPressed) || 
				(state & Item::idsRadioUnpressed) ) {

			buttonState.setPressed( state == Item::idsRadioPressed ? true : false );
			ctx->drawThemeRadioButtonRect( &stateRect, buttonState );
		}		
	}
}

void ListBoxControl::paintItemImage( GraphicsContext* ctx, Rect& itemRect, ListItem* item )
{
	Rect imageRect;
	imageRect.left_ += leftGutter_;
	imageRect.right_ = imageRect.left_ + imageList_->getImageWidth();

	ulong32 index = item->getImageIndex();	

	imageRect.top_ = itemRect.top_ + (itemRect.getHeight()/2.0 - imageList_->getImageHeight()/2.0);
	imageRect.bottom_ = imageRect.top_ + imageList_->getImageHeight();
	
	if ( !imageRect.isEmpty() ) {

		imageRect.inflate( -1, -1 );

		itemRect.left_ = imageRect.right_;

		imageList_->draw( ctx, index, &imageRect );
	}
}

void ListBoxControl::paintItem( GraphicsContext* ctx, Rect& itemRect, 
							   double currentTop, Color* selectedTextColor, 
							   const Rect& bounds, double scrollWidth, double offsetX,
							   ListItem* item )
{
	double y = currentTop + ( (itemRect.getHeight()/2.0) - (ctx->getTextHeight( "EM" )/2.0) );
	if ( item->isSelected() ) {
		paintSelectionRect( ctx, &Rect(bounds.left_-leftGutter_, itemRect.top_, itemRect.right_, itemRect.bottom_), item );
		ctx->getCurrentFont()->setColor( selectedTextColor );
	}
	else {
		ctx->getCurrentFont()->setColor( getFont()->getColor() );
	}
	
	
	Rect tmp = itemRect;

	bool stateNeedsDrawing = false;
	bool imageNeedsDrawing = false;

	if ( NULL != imageList_ ) {
		imageNeedsDrawing = true;
	}

	if ( Item::idsNone != item->getState() ) {
		stateNeedsDrawing = true;
	}

	itemRect.setLeft( bounds.left_ );

	if ( imageNeedsDrawing ) {
		paintItemImage( ctx, itemRect, item );
	}

	if ( stateNeedsDrawing ) {
		paintItemState( ctx, itemRect, item );
	}	

	String itemText = item->getCaption();
	if ( getUseLocaleStrings() ) {
		itemText = System::getCurrentThreadLocale()->translate( itemText );
	}
	
	if( textBounded_ ){
		Rect itemPaintRect;
		itemPaintRect.setRect(itemRect.left_ + leftGutter_, currentTop, offsetX + bounds.getWidth() - scrollWidth - leftGutter_, currentTop + defaultItemHeight_ );
		ctx->textBoundedBy( &itemPaintRect, itemText, false );
	}
	else{
		ctx->textAt( itemRect.left_ + leftGutter_, y, itemText );
	}
	

	if ( item->canPaint() ) {
		item->paint( ctx, &tmp );
	}
}

void ListBoxControl::paint( GraphicsContext* ctx )
{
	CustomControl::paint( ctx );
	ListModel* lm = getListModel();

	Scrollable* scrollable = this->getScrollable();

	Rect bounds = getClientBounds();
	ctx->setClippingRect( &ctx->getViewableBounds() );

	double width = bounds.getWidth();
	double scrollW = 0;
	double offsetx = bounds.left_ + leftGutter_;
	if ( NULL != scrollable ) {
		if ( scrollable->getVirtualViewHeight() > getHeight() ) {
			scrollW = scrollable->getVerticalScrollbarWidth();
		}

		offsetx = maxVal<>( offsetx, offsetx + scrollable->getHorizontalPosition() );
	}

	if ( NULL != lm ) {
		Color* selectedTextColor =
				GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION_TEXT );

		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = bounds.top_;
		Rect itemRect;
		Rect itemPaintRect;
		double totalHeight = 0;


		Color oldFontColor;
		oldFontColor = *getFont()->getColor();



		Rect viewBounds = ctx->getViewableBounds();
		//Point origin = ctx->getOrigin();
		//viewBounds.offset( -origin.x_, -origin.y_ );

		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( offsetx, currentTop, offsetx + (width-scrollW), currentTop + defaultItemHeight_ );

			if ( ((itemRect.top_ <= viewBounds.bottom_ ) && (itemRect.bottom_ >= viewBounds.top_ )) ||
					(itemRect.containsPt( &viewBounds.getTopLeft()) || (itemRect.containsPt( &viewBounds.getBottomRight() )) ) ) {
				totalHeight += itemRect.getHeight();			

				paintItem( ctx, itemRect, currentTop, selectedTextColor, 
							bounds, scrollW, offsetx, item );
				
			}

			currentTop += itemRect.getHeight();
		}
	}
}

void ListBoxControl::paintSelectionRect( GraphicsContext* ctx, Rect* rect, ListItem* item )
{
	Color* selectedColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION );
	Color* selectedTextColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION_TEXT );
	Color* greyColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SHADOW );
	ctx->setColor( selectedColor );
	ctx->rectangle( rect );
	ctx->fillPath();
	ctx->setColor( greyColor );
	ctx->strokePath();
	ctx->setColor( selectedTextColor );
}

ListItem* ListBoxControl::findSingleSelectedItem( Point* pt )
{
	ListItem* result = NULL;

	Point tmpPt = *pt;
	tmpPt.x_ = 1;

	ListModel* lm = getListModel();
	if ( NULL != lm ) {
		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = 0.0;
		Rect itemRect;
		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( 0, currentTop, getWidth(), currentTop + defaultItemHeight_ );
			if ( true == itemRect.containsPt( &tmpPt ) ) {
				result = item;
				break;
			}
			currentTop += itemRect.getHeight();
		}
	}

	return result;
}

bool ListBoxControl::stateHitTest( Point* point, ListItem* item )
{
	bool result = false;

	Rect stateRect = getStateRect( item );

	result = stateRect.containsPt( point );

	return result;
}

void ListBoxControl::mouseDown( MouseEvent* event )
{
	CustomControl::mouseDown( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		keepMouseEvents();

		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {
			//check state hit test first!
			if ( foundItem->getState() != Item::idsNone ) {
				if ( stateHitTest( event->getPoint(), foundItem ) ) {
					long state = foundItem->getState();
					if ( Item::idsChecked == state ) {
						state = Item::idsUnChecked;
					}
					else if ( Item::idsUnChecked == state ) {
						state = Item::idsChecked;
					}
					else if ( Item::idsRadioUnpressed == state ) {
						state = Item::idsRadioPressed;
					}
					else if ( Item::idsRadioPressed == state ) {
						state = Item::idsRadioUnpressed;
					}
					foundItem->setState( state );

					ItemEvent event( foundItem, ListBoxControl::lbeItemStateChangeRequested );
					ItemStateChangeRequested.fireEvent( &event );

					repaint();

					return;
				}
			}


			if ( true == allowsMultiSelect_ && true == allowsExtendedSelect_ ) {
				if( event->hasShiftKey() ){
					if( foundItem == singleSelectedItem_ ){
						for( ulong32 j=0;j<selectedItems_.size();j++ ){
							selectedItems_[j]->setSelected(false);
						}
						selectedItems_.clear();
						selectedItems_.push_back(foundItem);
						foundItem->setSelected(true);
						selectionChanged( foundItem );
					}
					else if( NULL != singleSelectedItem_ ){
						ulong32 foundItemPos = foundItem->getIndex();
						ulong32 singlePos = singleSelectedItem_->getIndex();
						for( ulong32 j=0;j<selectedItems_.size();j++ ){
							selectedItems_[j]->setSelected(false);
						}
						if(foundItemPos < singlePos){// rangeSelect clears selectedItems_
							rangeSelect(true, foundItem, singleSelectedItem_ );
						}
						else{
							rangeSelect(true, singleSelectedItem_, foundItem );
						}
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
					else{// needed if no items currently selected.
						foundItem->setSelected(true);
						selectedItems_.push_back(foundItem);
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
				}
				else if( event->hasControlKey() ){
					if( foundItem->isSelected() ){
						foundItem->setSelected(false);
						singleSelectedItem_ = NULL;
						eraseFromSelectedItems( foundItem );
						selectionChanged( foundItem );
					}
					else{
						foundItem->setSelected(true);
						selectedItems_.push_back(foundItem);
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
				}
				else{

					if( !(selectedItems_.empty()) ) {

						for( ulong32 j=0;j<selectedItems_.size();j++ ){
							selectedItems_[j]->setSelected(false);
						}

						selectedItems_.clear();
					}					
					
					selectedItems_.push_back(foundItem);
					foundItem->setSelected( true );
					singleSelectedItem_ = foundItem;
					selectionChanged( foundItem );
				}
			}
			else if ( true == allowsMultiSelect_ && false == allowsExtendedSelect_ ){
				if( foundItem->isSelected() ){
					foundItem->setSelected(false);
					singleSelectedItem_ = NULL;
					eraseFromSelectedItems( foundItem );
					selectionChanged( foundItem );
				}
				else{
					foundItem->setSelected( true );
					singleSelectedItem_ = foundItem;
					selectedItems_.push_back( foundItem );
					selectionChanged( foundItem );
				}
			}
			else {
				selectedItems_.clear();
				selectedItems_.push_back( foundItem );
				setSelectedItem( foundItem );
			}
		}
	}
}

void ListBoxControl::mouseMove( MouseEvent* event )
{
	CustomControl::mouseMove( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {
			if ( true == allowsMultiSelect_ ) {
				if ( true == foundItem->isSelected() ){
					singleSelectedItem_ = foundItem; 
				}
				else {
					//selectedItems_.push_back( foundItem );
					setSelectedItem( foundItem );
				}
			}
			else {
				if ( foundItem != singleSelectedItem_ )  {	   
					//JC - Integrated change by Berkano (Thanks Brian!) - fixes bug [1015368] ListBoxControl Mousemove error 
					if(!selectedItems_.empty()) {
					// selectedItems_[0] = foundItem;//assumes index 0 exists
					setSelectedItem( foundItem );
					}
				}
			}
		}
	}
}

void ListBoxControl::mouseUp( MouseEvent* event )
{
	CustomControl::mouseUp( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		releaseMouseEvents();
	}
}

void ListBoxControl::mouseClick( MouseEvent* event )
{
	CustomControl::mouseClick( event );
}

void ListBoxControl::mouseDblClick( MouseEvent* event )
{
	CustomControl::mouseDblClick( event );
}

void ListBoxControl::keyDown( KeyboardEvent* event )
{
	CustomControl::keyDown( event );

	if ( Component::csNormal == getComponentState() ) {
		if ( true == this->allowsMultiSelect_ ) {

		}
		else {
			ListItem* item = this->getSelectedItem();
			ListModel* lm = getListModel();
			if ( (NULL != item) && (NULL != lm) ) {
				ulong32 index = item->getIndex();

				if ( vkUpArrow == event->getVirtualCode() ) {
					index --;

				}
				else if ( vkDownArrow == event->getVirtualCode() ) {
					index ++;
				}
				item = lm->getItemFromIndex( index );
				if ( NULL != item ) {
					setSelectedItem( item );
				}
			}
		}
	}
}

void ListBoxControl::keyUp( KeyboardEvent* event )
{
	CustomControl::keyUp( event );
}

void ListBoxControl::keyPressed( KeyboardEvent* event )
{
	CustomControl::keyPressed( event );
}

void ListBoxControl::setDefaultItemHeight( const double& defaultItemHeight )
{
	defaultItemHeight_ = defaultItemHeight;
	repaint();
}

Enumerator<ListItem*>* ListBoxControl::getSelectedItems()
{
	return selectedItemsContainer_.getEnumerator();
}

void ListBoxControl::setAllowsMultiSelect( const bool& allowsMultiSelect )
{
	allowsMultiSelect_ = allowsMultiSelect;
}

void ListBoxControl::selectionChanged( ListItem* item )
{
	ItemEvent event( item, ITEM_EVENT_SELECTED );
	SelectionChanged.fireEvent( &event );
}

void ListBoxControl::setSelectedItem( ListItem* selectedItem )
{
	if ( true != allowsMultiSelect_ ) {

		if( NULL != singleSelectedItem_ ) singleSelectedItem_->setSelected( false );		
		
		if( !(selectedItems_.empty()) ) {

			for( ulong32 j=0;j<selectedItems_.size();j++ ){
				selectedItems_[j]->setSelected(false);
			}

			selectedItems_.clear();
		}
	}
	
	singleSelectedItem_ = selectedItem;
	if ( NULL != singleSelectedItem_ ) {
		if( !(selectedItem->isSelected()) ) { //If already selected, it is already in selectedItems_!!			
			singleSelectedItem_->setSelected( true );			
			selectedItems_.push_back( selectedItem );//should try to find it find it first, but!			
			selectionChanged( singleSelectedItem_ );
		}
	}

	repaint();
}

void ListBoxControl::deselectAllItems()
{
	for( ulong32 j=0;j<selectedItems_.size();j++ ){
		selectedItems_[j]->setSelected(false);
	}

	selectedItems_.clear();

	repaint();
}

void ListBoxControl::eraseFromSelectedItems(ListItem* item)
{
	std::vector<ListItem*>::iterator foundItemPos;
	foundItemPos = std::find( selectedItems_.begin(), selectedItems_.end(), item );
	
	if(foundItemPos != selectedItems_.end() ) selectedItems_.erase( foundItemPos );
}

void ListBoxControl::setAllowsExtendedSelect (const bool& allowsExtendedSelect)
{
	if ( true == allowsExtendedSelect ) {
		allowsMultiSelect_ = true;
	}

	allowsExtendedSelect_ = allowsExtendedSelect;
}

void ListBoxControl::setLeftGutter(const double& leftgutter)
{
	leftGutter_ = leftgutter;
	repaint();
}

void ListBoxControl::setRightGutter(const double& rightgutter)
{
	rightGutter_ = rightgutter;
	repaint();
}

void ListBoxControl::setTextBounded( const bool& istextbounded ){
	textBounded_ = istextbounded;
}

void ListBoxControl::setScrollable( Scrollable* scrollable )
{
	Control ::setScrollable( scrollable );

	scrollable_->setVirtualViewVertStep( getDefaultItemHeight() );
	scrollable_->setDiscreteScroll( false, true );
}

void ListBoxControl::setImageList( ImageList* imageList )
{
	imageList_ = imageList;
	repaint();
}

void ListBoxControl::setStateImageList( ImageList* stateImageList )
{
	stateImageList_ = stateImageList;
	repaint();
}


/**
*CVS Log info
*$Log$
*Revision 1.7  2006/04/07 02:35:23  ddiego
*initial checkin of merge from 0.6.9 dev branch.
*
*Revision 1.6.2.4  2006/03/01 04:34:56  ddiego
*fixed tab display to use themes api.
*
*Revision 1.6.2.3  2006/01/09 02:22:30  ddiego
*more osx code
*
*Revision 1.6.2.2  2005/10/05 03:37:11  ddiego
*minor fix to typed object property class.
*
*Revision 1.6.2.1  2005/10/04 01:57:03  ddiego
*fixed some miscellaneous issues, especially with model ownership.
*
*Revision 1.6  2005/07/09 23:14:53  ddiego
*merging in changes from devmain-0-6-7 branch.
*
*Revision 1.5.2.7  2005/06/16 20:13:02  dougtinkham
*fixed horizontal scrolling
*
*Revision 1.5.2.6  2005/03/21 05:08:31  dougtinkham
*fixed selection/deselection bug.
*
*Revision 1.5.2.5  2005/03/21 00:41:59  dougtinkham
*more fixes to selection through code.
*
*Revision 1.5.2.4  2005/03/20 20:46:32  dougtinkham
*fixed to allow selection through code to work properly. BugFix 1166682 by glen_f.
*
*Revision 1.5.2.3  2005/03/20 04:29:21  ddiego
*added ability to set image lists for list box control.
*
*Revision 1.5.2.2  2005/03/10 00:27:47  marcelloptr
*set discrete scrolling as default behaviour for ListBoxControls
*
*Revision 1.5  2004/12/01 04:31:21  ddiego
*merged over devmain-0-6-6 code. Marcello did a kick ass job
*of fixing a nasty bug (1074768VCF application slows down modal dialogs.)
*that he found. Many, many thanks for this Marcello.
*
*Revision 1.4  2004/08/20 23:59:16  ddiego
*minor fix to listboxcontrol
*
*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*
*Revision 1.2.2.8  2004/09/21 23:41:23  ddiego
*made some big changes to how the base list, tree, text, table, and tab models are laid out. They are not just plain interfaces. The actual
*concrete implementations of them now derive from BOTH Model and the specific
*tree, table, etc model interface.
*Also made some fixes to the way the text input is handled for a text control.
*We now process on a character by character basis and modify the model one
*character at a time. Previously we were just using brute force and setting
*the whole models text. This is more efficent, though its also more complex.
*
*Revision 1.2.2.7  2004/09/21 05:48:23  dougtinkham
*mod onItemAdded, onItemDeleted
*
*Revision 1.2.2.6  2004/09/13 06:27:31  dougtinkham
*onItemAdded & onItemDeleted modified to call updateVirtualViewSize
*
*Revision 1.2.2.5  2004/09/12 22:34:21  ddiego
*fixed bug in handling window cleanup when exception thrown from constructor.
*
*Revision 1.2.2.4  2004/09/08 21:12:39  dougtinkham
*modified onItemAdded for scrolling behavior
*
*Revision 1.2.2.3  2004/08/25 19:20:34  dougtinkham
*modified onItemDeleted
*
*Revision 1.2.2.2  2004/08/21 02:38:28  ddiego
*updated listbox
*
*Revision 1.2.2.1  2004/08/19 03:22:54  ddiego
*updates so new system tray code compiles
*
*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*
*Revision 1.2  2004/08/07 02:49:08  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.5  2004/07/16 04:01:45  ddiego
*fixed the last of border redraw issues, I hope.
*
*Revision 1.1.2.4  2004/07/09 03:39:29  ddiego
*merged in changes from the OSX branch for new theming API. Added
*support for controlling the use of locale translated strings in components.
*
*Revision 1.1.2.3  2004/07/08 19:41:48  dougtinkham
*implemented multi-selection and extended-selection, modified mouseDown, mouseMove, and paint. Text in list box can be painted using textBoundedBy or textAt, set by making a call to setTextBounded(const bool&). Added double leftGutter_ and double rightGutter_, which control the distance between text left and right edge of borders, respectively.
*
*Revision 1.1.2.2  2004/04/29 03:43:14  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:18  ddiego
*migration towards new directory structure
*
*Revision 1.18  2004/01/20 01:54:56  ddiego
*merged some more changes from dev branch, primarily changes to
*teh RTTI API so that we now process enum sets correctly (i.e. a long
*that is a mask made of enum values).
*
*Revision 1.17.2.1  2004/01/16 04:30:47  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.17  2003/12/18 05:16:00  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.16.2.7  2003/11/10 01:57:43  ddiego
*add a fromString methods to StingUtils
*added some minor fixes to list box control and added a SelectionChanged
*Delegate to it
*add some minor fixes ot ComboBoxControl
*added an unknownColor() method to ColorNames class
*
*Revision 1.16.2.6  2003/10/31 05:06:38  ddiego
*added toolbar impl
*
*Revision 1.16.2.5  2003/10/30 20:03:33  ddiego
*fixed display bug - shouldn't have been adjusting the viewable bounds
*also fixed the display rect for a given item to properly take into
*account any scroll bars
*
*Revision 1.16.2.4  2003/09/22 01:48:04  ddiego
*some minor additions ot teh DropTarget to allow it to have multiple
*control targets
*also a few other misc fixes
*
*Revision 1.16.2.3  2003/09/08 05:23:21  ddiego
*additions to scrolling to determine the correct width/height of scroll
*bars
*fixed problem in text model with inserting text
*optimized ListBoxControl, performs much much better now
*
*Revision 1.16.2.2  2003/08/26 21:41:17  ddiego
*miscellanesous stuff, minor bugs
*
*Revision 1.16.2.1  2003/08/22 01:32:20  ddiego
*fixed failure to release model in destructor
*
*Revision 1.16  2003/08/09 02:56:45  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.15.2.3  2003/07/24 04:10:44  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.15.2.2  2003/07/10 04:55:16  ddiego
*added more stuff to GTK port - fixed some issues with events, and
*added support for posting events, and the stubs for a ButtonPeer
*
*Revision 1.15.2.1  2003/07/09 03:53:18  ddiego
*some fixes to gtk port
*
*Revision 1.15  2003/05/17 20:37:49  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.14.2.3  2003/05/14 03:04:30  ddiego
*fixed some bugs caused by some of the changes in the graphics kit that I made
*yesterday. All is well now.
*
*Revision 1.14.2.2  2003/03/23 03:24:00  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.14.2.1  2003/03/12 03:13:14  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.14  2003/02/26 04:30:56  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.13.2.3  2003/01/08 00:20:00  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.13.2.2  2002/12/27 23:05:06  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.13.2.1  2002/12/25 22:06:35  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.13  2002/11/18 00:46:09  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.12.10.2  2002/11/16 20:31:35  ddiego
*this fixes the following bugs:
*632802 TextControl's setViewModel not called
*639416 ListViewControl's setViewModel not called
*639417 TreeControl's setViewModel not called
*639418 ListBoxControl's setViewModel not called
*639419 ComboBoxControl's setViewModel not called
*639420 TreeListControl's setViewModel not called
*basically just required that setViewModel() get called. Also made changes to
*the TableControl and teh TabbedPages control
*
*Revision 1.12.10.1  2002/09/20 21:28:44  ddiego
*added mods to support building from the VCF Builder and display the
*console build process. Also allows for double clicking in the output
*area and being able to read the output in a generic manner
*
*Revision 1.12  2002/05/09 03:10:45  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.11.4.2  2002/04/27 15:52:51  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.11.4.1  2002/04/08 20:55:31  zzack
*changed include style
*
*Revision 1.11  2002/01/24 01:46:50  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


