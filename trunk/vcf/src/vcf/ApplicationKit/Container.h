#ifndef _VCF_CONTAINER_H__
#define _VCF_CONTAINER_H__
//Container.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */





namespace VCF{

class Control;

class ControlEvent;

class MouseEvent;

class GraphicsContext;

class MouseHandler;

class Rect;


#define CONTAINER_CLASSID		"70ac023d-fb3f-44ee-9fc9-9b4dcebe472f"

/**
A Container is a Component that is implemented when a Control
wants to be able to contain other child controls within itself.
A container can have child controls added or removed, and supports
searching all of it's child controls by name.
In addition a container has methods for enumerating all of it's children
and a method for explicitly resizing all of the children
*/
class APPLICATIONKIT_API Container : public Component {
public:
	Container(){};

	Container( Component* owner ): Component(owner){};

	virtual ~Container(){};

	/**
	*adds a child control to this container
	*@param Control the child control to add
	*Note: the child is added with the alignment
	*type that is already set on the child.
	*/
	virtual void add( Control * child ) = 0;

	/**
	*adds a child control using the specified
	*AlignmentType. The child's alignment also
	*will get set to this value.
	*@param Control* the control to add
	*@param AlignmentType the alignment type to add the child with
	*<table width="100%" cellpadding="2" cellspacing="0" border="1" bordercolor="#C0C0C0">
    *<tr>
    *<td width="20%" bgcolor="#C0C0C0" valign=TOP>
    *Value</td>
    *<td width="80%" bgcolor="#C0C0C0" valign=TOP>
    *Meaning</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *	<code>ALIGN_NONE</code></td>
    * <td width="80%" valign=TOP>
    *   The default value for a control's alignment. The control's top, left,
    *   width, and height are what determine it's position, regardless of
    *   surrounding controls.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_TOP</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the top of the parent container and resizes to
    *   fill in the width of the parent control. The height of the control is
    *   not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_BOTTOM</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the bottom of the parent container and resizes
    *   to fill in the width of the parent control. The height of the control
    *   is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_LEFT</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the left side of the parent container and
    *   resizes to fill in the height of the parent control. The width of the
    *   control is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_RIGHT</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the right side of the parent container and
    *   resizes to fill in the height of the parent control. The width of the
    *   control is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_CLIENT</code></td>
    * <td width="80%" valign=TOP>
    *   The control resizes to fill in the remaining client area of a form
    *   (after all other alignment positions of other controls are calculated).</td>
    *</tr>
	*</table>
	*/
	virtual void add( Control * child, const AlignmentType& alignment ) = 0;

	/**
	*inserts a child control into this container before the control specified in beforeControl.
	*If the child is already present then it's order in the container list is
	*modified accordingly. If the beforeControl control is not found in the list of
	*children then the child is added at the <b><i>beginning</i></b> of the list
	*/
	virtual void insertBeforeControl( Control * child, const AlignmentType& alignment, Control* beforeControl ) = 0;

	/**
	*inserts a child control into this container after the specified index.
	*If the child is already present then it's order in the container list is
	*modified accordingly. If the index specified is not within the container list's
	*bounds then the child is added at the <b><i>end</i></b> of the list
	*/
	virtual void insertAtIndex( Control * child, const AlignmentType& alignment, const ulong32& index ) = 0;

	/**
	*Sends the specified child to the first position in containers list
	*/
	virtual void sendControlToFront( Control* child ) = 0;

	/**
	*Sends the specified child to the last position in containers list
	*/
	virtual void sendControlToBack( Control* child ) = 0;

	/**
	*removes the child control from the container - does <b><i>NOT</i></b>
	*delete the control
	*@param Control the control to remove from this container
	*/
	virtual void remove( Control* child ) = 0;

	/**
	removes \em all child controls
	*/
	virtual void clear() = 0;

	/**
	*returns an Enumerator of controls that represents all the
	*children in this container.
	*@return Enumerator<Control*> an enunerator of all the child controls
	*that this container has.
	*/
	virtual Enumerator<Control*>* getChildren() = 0;


	/**
	Paints all children of this container
	*/
	virtual void paintChildren( GraphicsContext* context ) = 0;

	/**
	*returns the numer of child controls that
	*this container has.
	*/
	virtual unsigned long getChildCount() = 0;

	/**
	*searches through all the child controls of this
	*container. The first child control whose name
	*matches the name passed in is returned as a result
	*of the search. If the container ahs no children, or
	*none of the child controls have a name that matches
	*then NULL is returned.
	*@param String the name of the child control to find
	*@return Control the result of the search, NULL if nothing
	*nothing was found, otherwise a valid pointer to a child control
	*of this container.
	*/
	virtual Control* findControl( const String& controlName ) = 0;

	/**
	*resizes all the children, according to their alignment types
	*and anchor values. Usually called by the implementing container
	*control when it is resized.
	@param Control the child control that has changed and should be paid
	attention to. If the the parameter is NULL then the control that
	the container is attached to has changed.
	*/
	virtual void resizeChildren( Control* control ) = 0;

	virtual Control* getControlAtIndex( const ulong32& index ) = 0;

	virtual long getControlIndex( Control* control ) = 0;

	virtual void updateTabOrder( Control* child, ulong32& newTabOrder ) = 0;

	virtual void getTabList( std::vector<Control*>& tabList ) = 0;

	/**
	Sets the control that this container is attached to
	and responds to events from
	*/
	virtual void setContainerControl( Control* control ) = 0;

	virtual Control* getContainerControl() = 0;
};





template< typename ContainerType>
class DelegatedContainer {
public:

	DelegatedContainer(): delegate_(NULL) {
	}

	void paintChildren( GraphicsContext* context ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->paintChildren( context );
	}

	void add( Control * child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->add( child );
	}

	void add( Control * child, const AlignmentType& alignment ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->add( child, alignment );
	}

	void insertBeforeControl( Control * child, const AlignmentType& alignment, Control* beforeControl ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->insertBeforeControl( child, alignment, beforeControl );
	}

	void insertAtIndex( Control * child, const AlignmentType& alignment, const ulong32& index ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->insertAtIndex( child, alignment, index );
	}

	void sendControlToFront( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->sendControlToFront( child );
	}

	void sendControlToBack( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->sendControlToBack( child );
	}

	void remove( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->remove( child );
	}

	Enumerator<Control*>* getChildren() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getChildren();
	};

	unsigned long getChildCount() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return 0;
		}
		return container->getChildCount();
	}

	Control* findControl( const String& controlName ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->findControl(controlName);
	}

	void resizeChildren( Control* control )  {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->resizeChildren( control );
	}

	Control* getControlAtIndex( const ulong32& index ){
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getControlAtIndex(index);
	}

	long getControlIndex( Control* control ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return -1;
		}
		return container->getControlIndex(control);
	}

	void updateTabOrder( Control* child, ulong32& newTabOrder ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->updateTabOrder(child,newTabOrder);
	}

	void getTabList( std::vector<Control*>& tabList ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->getTabList( tabList );
	}
/*
	Control* getNextTabControl( Control* previousControl=NULL ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getNextTabControl(previousControl);
	}

	Control* getPrevTabControl(Control* previousControl=NULL) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getPrevTabControl(previousControl);
	}

	Control* getFirstTabControl() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getFirstTabControl();
	}

	Control* getLastTabControl() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getLastTabControl();
	}
*/
	void setContainerControl( Control* control ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->setContainerControl(control);
	}

	Control* getContainerControl() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getContainerControl();
	}

	void setContainerDelegate( ContainerType* delegate ) {
		delegate_ = delegate;
	}

	protected:
	ContainerType* delegate_;
};


};


/**
*CVS Log info
*$Log$
*Revision 1.3  2005/07/09 23:14:52  ddiego
*merging in changes from devmain-0-6-7 branch.
*
*Revision 1.2.4.2  2005/03/14 04:17:22  ddiego
*adds a fix plus better handling of accelerator keys, ands auto menu title for the accelerator key data.
*
*Revision 1.2.4.1  2005/03/06 22:50:58  ddiego
*overhaul of RTTI macros. this includes changes to various examples to accommadate the new changes.
*
*Revision 1.2  2004/08/07 02:49:06  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.3  2004/06/06 07:05:29  marcelloptr
*changed macros, text reformatting, copyright sections
*
*Revision 1.1.2.2  2004/04/29 03:43:13  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:15  ddiego
*migration towards new directory structure
*
*Revision 1.23.4.1  2004/04/26 21:58:18  marcelloptr
*changes for dir reorganization: _VCF_MACRO_H__
*
*Revision 1.23  2003/12/18 05:15:56  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.22.4.3  2003/10/12 06:34:29  ddiego
*added some fixes to standard container layout algorithms - thisstill needs
*to be tested, but it looks like it may fix some outstanding issues
*with the layout logic
*
*Revision 1.22.4.2  2003/09/12 00:09:32  ddiego
*added better tabbing behaviour - fixed an earlier bug.
*Code is easier to understand and it simplified the implementation
*a bit as well
*Moved around the RTTI definitions for various Appkit classes to a
*single inline and stripped them from the various class headers
*
*Revision 1.22.4.1  2003/08/18 19:52:32  ddiego
*changed the Container from being a class you derive from to a separate
*intance that is created and assigned dynamically to any Control.
*
*Revision 1.22  2003/05/17 20:37:02  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.21.2.2  2003/03/23 03:23:45  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.21.2.1  2003/03/12 03:09:24  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.21  2003/02/26 04:30:37  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.20.14.1  2002/12/25 22:06:17  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.20  2002/05/09 03:10:42  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.19.4.1  2002/04/27 15:41:55  ddiego
*removed ApplicationKit.h and optimized header includes as
*well as adding better include guard support
*
*Revision 1.19  2002/01/24 01:46:47  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


#endif // _VCF_CONTAINER_H__


