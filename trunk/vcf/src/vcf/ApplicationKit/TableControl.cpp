//TableControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/TableControl.h"
#include "vcf/ApplicationKit/DefaultTableModel.h"
#include "vcf/ApplicationKit/TableItemEditor.h"
#include "vcf/ApplicationKit/Containers.h"

using namespace VCF;


#define TABLECONTROL_KBRD_HANDLER		"TCKeyboardHandler"


class FinishEditingEvent : public Event {
public:
	FinishEditingEvent( Control* source, TableItemEditor* editor ): Event(source,0), editor_(editor){

	}
	TableItemEditor* editor_;
};



TableControl::TableControl( TableModel* model ):
	CustomControl( true ),
	totalRowHeight_(0.0),
	drawGridLinesStyle_(TableControl::dglDrawBoth),
	enableSelection_(true),
	allowSingleColumnSelection_(true),
	allowSingleRowSelection_(true),
	allowFixedColumnSelection_(true),
	allowFixedRowSelection_(true),
	allowLiveResizing_(true),
	autoSizeStyle_(TableControl::asoBoth),
	defaultCellColor_(NULL),
	defaultCellFont_(NULL)
{
	setContainerDelegate( this );

	setViewModel( dynamic_cast<Model*>(model) );

	init();
}

TableControl::~TableControl()
{
	defaultCellFont_->free();
	defaultCellFont_ = NULL;

	defaultCellColor_->free();
	defaultCellColor_ = NULL;
}

void TableControl::setDrawGridLinesStyle( DrawGridLines val )
{
	drawGridLinesStyle_ = val;
	repaint();
}

void TableControl::paint( GraphicsContext * context )
{
	Point oldOrigin = context->getOrigin();
	Rect oldViewBounds = context->getViewableBounds();

	CustomControl::paint( context );


	Point origin = context->getOrigin();
	Rect viewBounds = context->getViewableBounds();

	bool hasScrollable = false;
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		hasScrollable = true;
	}

	if ( hasScrollable ) {
		//reset origin
		context->setOrigin( oldOrigin );
		context->setViewableBounds( oldViewBounds );
	}

	TableModel* tm = getTableModel();
	uint32 rowCount = tm->getRowCount();
	uint32 columnCount = tm->getColumnCount();

	if ( (rowCount > 0) && (columnCount > 0) ) {

		int gcs = context->saveState();


		uint32 fixedRowCount = tm->getFixedRowsCount();
		uint32 fixedColumnCount = tm->getFixedColumnsCount();



		int fixedRowHeight = (int)getFixedRowHeight();
		int fixedColWidth  = (int)getFixedColumnWidth();

		CellID topLeft = getTopLeftNonFixedCell();
		uint32 minVisibleRow = topLeft.row;
		uint32 minVisibleCol = topLeft.column;

		Rect visibleRect;
		CellRange visibleCellRange = getVisibleNonFixedCellRange(&visibleRect);
		uint32 maxVisibleRow = visibleCellRange.getMaxRow();
		uint32 maxVisibleCol = visibleCellRange.getMaxCol();

		Rect rect;
		rect.bottom_ = -1;
		uint32 rowHeight = 0;
		uint32 colWidth = 0;
		TableCellItem* cellItem = NULL;

		uint32 row, col;

		Rect clipRect = context->getViewableBounds();
		//getClippingRect();


		for (row = 0; row < fixedRowCount; row++)  {
			rowHeight = rowHeights_[row];

			if ( rowHeight <= 0 ) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;
			rect.right_ = -1;

			for (col = 0; col < fixedColumnCount; col++) {
				colWidth = columnWidths_[col];
				if ( colWidth <= 0) {
					continue;
				}

				rect.left_ = rect.right_+1;
				rect.right_ = rect.left_ + colWidth-1;

				cellItem = tm->getItem( row, col );
				cellItem->paint( context, &rect );
			}
		}
		
		context->restoreState( gcs );

		gcs = context->saveState();


		// draw fixed column cells:  m_nFixedRows..n, 0..m_nFixedCols-1
		rect.bottom_ = fixedRowHeight-1;
		for (row = minVisibleRow; row <= maxVisibleRow; row++)  {
			rowHeight = rowHeights_[row];
			if ( rowHeight <= 0 ) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;

			// rect.bottom = bottom pixel of previous row
			if ( rect.top_ > clipRect.bottom_ ) {
				break;                // Gone past cliprect
			}

			if ( rect.bottom_ < clipRect.top_ ) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = -1;
			for (col = 0; col < fixedColumnCount; col++)  {
				colWidth = columnWidths_[col];

				if ( colWidth <= 0 )  {
					continue;
				}

				rect.left_ = rect.right_+1;
				rect.right_ = rect.left_ + colWidth-1;

				if ( rect.left_ > clipRect.right_ ) {
					break;            // gone past cliprect
				}

				if ( rect.right_ < clipRect.left_ ) {
					continue;         // Reached cliprect yet?
				}

				cellItem = tm->getItem( row, col );
				cellItem->paint( context, &rect );
			}
		}

		context->restoreState( gcs );

		gcs = context->saveState();

		// draw fixed row cells  0..m_nFixedRows, m_nFixedCols..n
		rect.bottom_ = -1;
		for (row = 0; row < fixedRowCount; row++)  {
			rowHeight = rowHeights_[row];
			if ( rowHeight <= 0) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;



			// rect.bottom = bottom pixel of previous row
			if ( rect.top_ > clipRect.bottom_ ) {
				break;                // Gone past cliprect
			}

			if ( rect.bottom_ < clipRect.top_ ) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = fixedColWidth-1;

			TableRowItemEnumerator* rowItemEnum = tm->getRowItemEnumerator( row );
			col = 0;
			while ( rowItemEnum->hasMoreElements() && (col <= maxVisibleCol) ){
				cellItem = rowItemEnum->nextElement();

				if ( col >= minVisibleCol ) {
					colWidth = columnWidths_[col];

					if ( colWidth > 0 ) {
						rect.left_ = rect.right_+1;
						rect.right_ = rect.left_ + colWidth-1;

						if (rect.left_ > clipRect.right_ ) {
							break;        // gone past cliprect
						}

						if (rect.right_ < clipRect.left_) {
							continue;     // Reached cliprect yet?
						}


						cellItem->paint( context, &rect );
					}
				}

				col ++;
			}

		}

		context->restoreState( gcs );

		gcs = context->saveState();

		// draw rest of non-fixed cells

		if ( hasScrollable ) {
			Rect tmp( fixedColWidth, fixedRowHeight,
						viewBounds.right_, viewBounds.bottom_ );

			//set clipping region
			clipRect = tmp;
			//context->setClippingRect( &tmp );
		}

		

		rect.bottom_ = fixedRowHeight-1;
		for (row = minVisibleRow; row <= maxVisibleRow; row++)  {
			rowHeight = rowHeights_[row];

			if ( rowHeight <= 0) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;

			// rect.bottom = bottom pixel of previous row
			if (rect.top_ > clipRect.bottom_) {
				break;                // Gone past cliprect
			}

			if (rect.bottom_ < clipRect.top_) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = fixedColWidth-1;

			TableRowItemEnumerator* rowItemEnum = tm->getRowItemEnumerator( row );

			col = 0;
			while ( rowItemEnum->hasMoreElements() && (col <= maxVisibleCol) ) {
				cellItem = rowItemEnum->nextElement();

				if ( col >= minVisibleCol ) {
					colWidth = columnWidths_[col];

					if ( colWidth > 0 ) {
						rect.left_ = rect.right_+1;
						rect.right_ = rect.left_ + colWidth-1;

						//StringUtils::traceWithArgs( "Cliprect: %s\n", clipRect.toString().c_str() );

						if (rect.left_ > clipRect.right_ ) {
							break;        // gone past cliprect
						}

						if (rect.right_ < clipRect.left_ ) {
							continue;     // Reached cliprect yet?
						}

						//context->setColor( &Color(0xCCCCCC) );
						//context->rectangle( &rect );
						//context->fillPath();
						cellItem->paint( context, &rect );

					}
				}
				col ++;
			}
		}

		context->restoreState( gcs );

		gcs = context->saveState();

		context->setStrokeWidth( 1 );
		context->setColor( &Color(0.0,0.0,0.0) );
		// draw vertical lines (drawn at ends of cells)
		if ( drawGridLinesStyle_ == TableControl::dglDrawBoth ||
			drawGridLinesStyle_ == TableControl::dglDrawVerticalLines ) {

			int x = fixedColWidth;
			for (col = minVisibleCol; col <= maxVisibleCol; col++)  {
				colWidth = columnWidths_[col];
				if ( colWidth <= 0 ) {
					continue;
				}

				x += colWidth;
				context->moveTo( x-1, fixedRowHeight );
				context->lineTo( x-1, visibleRect.bottom_ );
			}

			context->strokePath();

		}

		// draw horizontal lines (drawn at bottom of each cell)
		if ( drawGridLinesStyle_ == TableControl::dglDrawBoth ||
			drawGridLinesStyle_ == TableControl::dglDrawHorizontalLines ) {

			int y = fixedRowHeight;
			for (row = minVisibleRow; row <= maxVisibleRow; row++) {
				rowHeight = rowHeights_[row];
				if ( rowHeight <= 0 ) {
					continue;
				}

				y += rowHeight;
				context->moveTo( fixedColWidth, y-1 );
				context->lineTo( visibleRect.right_,  y-1 );
			}
			context->strokePath();
		}

		context->restoreState( gcs );
	}	

	paintChildren( context );
}

void TableControl::init()
{
	autoResizeColumns_ = true;
	allowColumnResizing_ = true;
	allowRowResizing_ = true;
	hiddenColumnUnhide_ = false;
	hiddenRowUnhide_ = false;
	listMode_ = false;
	allowColumnHide_ = false;
	allowRowHide_ = false;


	defaultCellColor_ = new Color();

	*defaultCellColor_ = *GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW );

	defaultCellFont_ = new Font();
	*defaultCellFont_ = *getFont();


	//selectedCellItem_ = NULL;

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;

	setContainer( new StandardContainer() );


	defaultColumnWidth_ = DEFAULT_COLUMN_WIDTH;
	defaultRowHeight_ = (uint32)
		UIToolkit::getUIMetricValue( UIMetricsManager::mtLabelHeight );

	mouseState_ = msNone;

	resizeCaptureRange_ = 5;

	if ( NULL == getViewModel() ){
		setTableModel( new DefaultTableModel() );
		addComponent( getViewModel() );
	}
	CallBack* tmh =
		new ClassProcedure1<TableModelEvent*,TableControl>( this, &TableControl::onTableModelChanged, "TableModelHandler" );

	TableModel* model = getTableModel();

	model->TableCellAdded += tmh;
	model->TableCellDeleted += tmh;
	model->TableColumnsAdded += tmh;
	model->TableColumnsDeleted += tmh;
	model->TableRowsAdded += tmh;
	model->TableRowsDeleted += tmh;
	model->TableCellsSelected += tmh;

	ModelHandler* modelHandler =
		new ClassProcedure1<ModelEvent*,TableControl>( this, &TableControl::onTableModelEmptied, "ModelHandler" );

	getViewModel()->addModelHandler( modelHandler );

	CallBack* kh =
		new ClassProcedure1<KeyboardEvent*,TableControl>( this, &TableControl::onEditingControlKeyPressed, TABLECONTROL_KBRD_HANDLER );


	CallBack* focusLost =
		new ClassProcedure1<FocusEvent*,TableControl>( this, &TableControl::onFocusLost, "TableControl::onFocusLost" );


	ScrollbarManager* scroller = new ScrollbarManager();
	addComponent( scroller ) ;
	scroller->setHasHorizontalScrollbar( true );
	scroller->setHasVerticalScrollbar( true );
	scroller->setTarget( this );

	EventHandler* ev = new ClassProcedure1<Event*,TableControl>(this, &TableControl::onVerticalScrolling, "TableControl::onVerticalScrolling" );
	scroller->VerticalScrolling += ev;

	ev = new ClassProcedure1<Event*,TableControl>(this, &TableControl::onHorizontalScrolling, "TableControl::onHorizontalScrolling" );
	scroller->HorizontalScrolling += ev;
}

void TableControl::onTableModelEmptied( ModelEvent* e )
{
	//this needs to happen here cause we receive this event
	//AFTER the table model's items have been cleared so the
	//model is now empty at this point

	currentItemEditor_ = NULL;

	finishEditing();

	columnWidths_.clear();
	rowHeights_.clear();

	//selectedCellItem_ = NULL;


	resizeDragPt_.setNull();
	lastMousePoint_.setNull();
	leftClickPoint_.setNull();

	clickCell_.row = -1;
	clickCell_.column = -1;

	selectionStartCell_.row = -1;
	selectionStartCell_.column = -1;

	currentCell_.row = -1;
	currentCell_.column = -1;
}

void TableControl::onTableModelChanged( TableModelEvent* event )
{
	finishEditing();

	//selectedCellItem_ = NULL;

	TableModel* tm = getTableModel();

	CallBack* itemHandler = getCallback(TABLECELL_HANDLER);
	if ( NULL == itemHandler ) {
		//itemHandler = new 
	}
	switch ( event->getType() ){
		case COLUMNS_DELETED:{

		}
		break;

		case COLUMNS_ADDED:{
			int start = event->getStartColumnThatChanged();
			for (int col=start;col<event->getNumberOfColumnsAffected()+start;col++ ) {
				columnWidths_.insert( columnWidths_.begin() + col,
				                         defaultColumnWidth_ );
			}


			uint32 rowCount = tm->getRowCount();
			for ( uint32 row=0;row<rowCount;row++){

				for (int col=start;col<event->getNumberOfColumnsAffected()+start;col++ ) {

					TableCellItem* item = tm->getItem( row, col );
					if ( NULL != item ){
						if ( NULL != itemHandler ) {
							item->ItemSelected += itemHandler;
						}
						item->setControl( this );
						item->setColor( getDefaultTableCellColor() );
						item->setFont( getDefaultTableCellFont() );
					}
				}
			}

		}
		break;

		case ROWS_DELETED:{

		}
		break;

		case ROWS_ADDED:{
			int start = event->getStartRowThatChanged();

			uint32 colCount = tm->getColumnCount();

			for (int row=start;row<event->getNumberOfRowsAffected()+start;row++ ) {
				rowHeights_.insert( rowHeights_.begin() + row, defaultRowHeight_ );

				for (uint32 col=0;col<colCount;col++ ) {

					TableCellItem* item = tm->getItem( row, col );
					if ( NULL != item ){
						if ( NULL != itemHandler ) {
							item->ItemSelected += itemHandler;
						}
						item->setControl( this );
						item->setColor( getDefaultTableCellColor() );
						item->setFont( getDefaultTableCellFont() );
					}
				}
			}

		}
		break;

		case ALL_COLUMNS_CHANGED:{

		}
		break;

		case ALL_ROWS_CHANGED:{

		}
		break;

		case CELL_CHANGED:{
			repaint();
		}
		break;
	}
}

uint32 TableControl::getDefaultRowHeight()
{
	return defaultRowHeight_;
}

void TableControl::setDefaultRowHeight( const uint32& defaultRowHeight )
{
	defaultRowHeight_ = defaultRowHeight;
}

uint32 TableControl::getDefaultColumnWidth()
{
	return defaultColumnWidth_;
}

void TableControl::setDefaultColumnWidth( const uint32& defaultColumnWidth )
{
	defaultColumnWidth_ = defaultColumnWidth;
}


TableModel* TableControl::getTableModel()
{
	return dynamic_cast<TableModel*>(getViewModel());
}

void TableControl::setTableModel( TableModel* model )
{
	setViewModel( dynamic_cast<Model*>(model) );
}

void TableControl::setColumnCount( const uint32& colCount )
{

}

void TableControl::setRowCount( const uint32& rowCount )
{

}


void TableControl::onFocusLost( FocusEvent* e )
{
	finishEditing();
}

void TableControl::mouseDown( MouseEvent* event ){
	CustomControl::mouseDown( event );

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}
	
	finishEditing();

	if ( event->hasLeftButton() ) {
		TableModel* tm = getTableModel();


		leftClickPoint_ = *event->getPoint();
		clickCell_ = getCellIDFromPoint( *event->getPoint() );

		if ( !clickCell_.isValid() ) {
			return;
		}

		if ( !event->hasShiftKey() ) {
			selectionStartCell_ = clickCell_;
		}
		else {
			if ( !selectionStartCell_.isValid() ) {
				selectionStartCell_ = currentCell_;
			}
		}

		//end editing here

		TableCellEvent clickEvent( this, TableControl::TableCellClickedEvent, clickCell_ );
		TableCellDown( &clickEvent );


		TableCellItem* item = getItem( clickCell_ );

		if ( (clickCell_ == currentCell_) && (!event->hasControlKey()) && (item->isEditable()) ) {
			mouseState_ = TableControl::msPrepareForEdit;
			return;
		}
		/*
		else if ( clickCell_.isValid() ) {

			tm->setSelectedCell( true, clickCell_.row, clickCell_.column );

		}
		*/
		else if ( item->isSelected() ){
			if ( event->hasControlKey() ) {
				setFocusedCell( clickCell_ );
				return;
			}
			else {
				mouseState_ = TableControl::msPrepareForDrag;
			}
		}
		else if ( (mouseState_ != TableControl::msPrepareColResize) &&
			(mouseState_ != TableControl::msPrepareRowResize) ) {
			if ( (clickCell_.row >= tm->getFixedRowsCount()) &&
					 (clickCell_.column >= tm->getFixedColumnsCount()) ) {

				setFocusedCell( clickCell_ );
			}
			else {
				setFocusedCell( CellID(-1,-1) );
			}
		}


		keepMouseEvents();

		if ( TableControl::msNone == mouseState_ ) {
			if ( allowColumnResizing_ && columnResizeAreaHitTest( *event->getPoint() ) ) {
				if ( TableControl::msPrepareColResize != mouseState_ ) {
					mouseState_ = TableControl::msPrepareColResize;

					//change the cursor
					setCursorID( Cursor::SCT_SIZE_HORZ );
				}
				else {
					setCursorID( Cursor::SCT_DEFAULT );
				}
			}
			else if ( allowRowResizing_ && rowResizeAreaHitTest( *event->getPoint() ) ) {
				if ( TableControl::msPrepareRowResize != mouseState_ ) {
					mouseState_ = TableControl::msPrepareRowResize;

					//change the cursor
					setCursorID( Cursor::SCT_SIZE_VERT );
				}
				else {
					setCursorID( Cursor::SCT_DEFAULT );
				}
			}
		}

		if ( TableControl::msPrepareColResize == mouseState_ ) {
			mouseState_ = TableControl::msColResizing;

			if ( columnWidths_[tm->getColumnCount()-1] < resizeCaptureRange_ ) {
				Rect visibleRect;

				getVisibleNonFixedCellRange( &visibleRect );


				if ( abs( (int32)((event->getPoint()->x_ - visibleRect.right_ ) < resizeCaptureRange_)) ) {

					clickCell_.column = tm->getColumnCount()-1;
				}
			}

			Point start;

			if ( !getCellOrigin( CellID(0, clickCell_.column), start ) ) {

				return;
			}

			if ( !hiddenColumnUnhide_ ) {
				//  ignore columns that are hidden and look left towards first visible column
				bool lookForVisible = true;
				bool isCellRightBorder = abs((int32)(event->getPoint()->x_ - start.x_)) >= resizeCaptureRange_;

				if( isCellRightBorder && ((clickCell_.column + 1) >= tm->getColumnCount()) ) {
					// clicked on last column's right border

					// if last column is visible, don't do anything
					if( clickCell_.column >= 0)
						lookForVisible = false;
				}

				if( lookForVisible ) {
					// clicked on column divider other than last right border
					bool foundVisible = false;
					int offset = 1;

					if( isCellRightBorder) {
						offset = 0;
					}

					while( clickCell_.column - offset >= 0) {

						if( columnWidths_[clickCell_.column - offset] > 0)	{
							foundVisible = true;
							break;
						}
						clickCell_.column--;
					}
					if ( !foundVisible ) {
						return;
					}
				}
			}

			Rect clientRect = getClientBounds();
			Rect invertedRect( event->getPoint()->x_, clientRect.top_,
								event->getPoint()->x_ + 2, clientRect.bottom_ );

			/**
			We need to paint an inverse rect as measured by invertedRect
			on the current graphics context
			*/
			/*
			CDC* pDC = GetDC();
			if (pDC)
			{
				pDC->InvertRect(&invertedRect);
				ReleaseDC(pDC);
			}
			*/

			// If we clicked to the right of the colimn divide, then reset the click-down cell
			// as the cell to the left of the column divide - UNLESS we clicked on the last column
			// and the last column is teensy (kludge fix)
			if ( (event->getPoint()->x_ - start.x_) < resizeCaptureRange_) {
				if (clickCell_.column < tm->getColumnCount()-1 ||
					columnWidths_[tm->getColumnCount()-1] >= resizeCaptureRange_) {
					clickCell_.column --;
					if ( !getCellOrigin( CellID(0,clickCell_.column), start) ) {
						return;
					}
				}
			}

			// Allow a cell resize width no greater than that which can be viewed within
			// the grid itself
			int maxCellWidth = clientRect.getWidth() - getFixedColumnWidth();
			clientRect.left_  = start.x_ + 1;
			clientRect.right_ = clientRect.left_ + maxCellWidth;

			/**
			Do we need to really clip the cursor like this?
			*/
			//ClientToScreen(rect);

			//ClipCursor(rect);
		}
		else if ( TableControl::msPrepareRowResize == mouseState_ ) {
			mouseState_ = TableControl::msRowResizing;

			// Kludge for if we are over the last column...
			if ( rowHeights_[tm->getRowCount()-1] < resizeCaptureRange_ ) 	{
				Rect visibleRect;
				getVisibleNonFixedCellRange( &visibleRect );

				if ( abs((int32)(event->getPoint()->y_ - visibleRect.bottom_)) < resizeCaptureRange_ ) {
					clickCell_.row = tm->getRowCount()-1;
				}
			}

			Point start;
			if ( !getCellOrigin(clickCell_, start) ) {
				return;
			}

			if( !hiddenRowUnhide_ )  {
				//  ignore rows that are hidden and look up towards first visible row
				bool lookForVisible = true;
				bool isCellBottomBorder = abs((int32)(event->getPoint()->y_ - start.y_)) >= resizeCaptureRange_;

				if( isCellBottomBorder && ( clickCell_.row + 1 >= tm->getRowCount()) ) {
					// clicked on last row's bottom border

					// if last row is visible, don't do anything
					if( clickCell_.row >= 0)
						lookForVisible = false;
				}

				if( lookForVisible ) {
					// clicked on row divider other than last bottom border
					bool foundVisible = false;
					int offset = 1;

					if( isCellBottomBorder) {
						offset = 0;
					}

					while( clickCell_.row - offset >= 0 ) {
						if( rowHeights_[ clickCell_.row - offset] > 0) {
							foundVisible = true;
							break;
						}
						clickCell_.row--;
					}
					if( !foundVisible)
						return;
				}
			}

			Rect clientRect = getClientBounds();

			Rect invertedRect(clientRect.left_, event->getPoint()->y_,
								clientRect.right_, event->getPoint()->y_ + 2);

			/**
			We need to paint an inverse rect as measured by invertedRect
			on the current graphics context
			*/
			/*
			CDC* pDC = GetDC();
			if (pDC)
			{
				pDC->InvertRect(&invertedRect);
				ReleaseDC(pDC);
			}
			*/

			// If we clicked below the row divide, then reset the click-down cell
			// as the cell above the row divide - UNLESS we clicked on the last row
			// and the last row is teensy (kludge fix)
			if ( abs((int32)(event->getPoint()->y_ - start.y_)) < resizeCaptureRange_ ) {  // clicked below border
				if ( clickCell_.row < tm->getRowCount()-1 ||
					rowHeights_[tm->getRowCount()-1] >= resizeCaptureRange_ ) {

					clickCell_.row -- ;

					if ( !getCellOrigin(CellID(clickCell_.row,0), start)) {
						return;
					}
				}
			}

			uint32 maxCellHeight = clientRect.getHeight()-getFixedRowHeight();
			clientRect.top_ = start.y_ + 1;
			clientRect.bottom_ = clientRect.top_ + maxCellHeight;

			/*
			ClientToScreen(rect);


			ClipCursor(rect);
			*/
		}
		else if ( TableControl::msPrepareForDrag != mouseState_ ) {
			//should we fire an event to a delegate here???? tablemodel? control??


			// If Ctrl pressed, save the current cell selection. This will get added
			// to the new cell selection at the end of the cell selection process
			if ( event->hasControlKey() ) {
				Enumerator<TableCellItem*>* selectedCells = tm->getSelectedCells();

				while ( selectedCells->hasMoreElements() ) {

					TableCellItem* item = selectedCells->nextElement();

					previouslySelectedCellMap_[ tm->getCellIDForItem(item) ] = item;
				}
			}

			if ( clickCell_.row < tm->getFixedRowsCount() ) {

				fixedRowClicked( clickCell_ );

				TableCellEvent event(this,FixedRowClickedEvent,clickCell_);

				FixedRowClicked( &event );
			}
			else if ( clickCell_.column < tm->getFixedColumnsCount() ) {

				fixedColumnClicked( clickCell_ );

				TableCellEvent event(this,FixedColumnClickedEvent,clickCell_);

				FixedColumnClicked( &event );
			}
			else {
				mouseState_ = listMode_ ? TableControl::msSelectRow : TableControl::msSelectCells;

				doSelection( clickCell_ );

				TableCellEvent event(this,SelectingEvent,clickCell_);

				TableSelecting( &event );

				//m_nTimerID = SetTimer(WM_LBUTTONDOWN, m_nTimerInterval, 0);
			}
		}



		lastMousePoint_ = *event->getPoint();
	}
}

Rect TableControl::getBoundsForCell( const CellID& cell )
{
	Rect result;

	for ( int row=0;row<=cell.row;row++ ) {
		result.bottom_ += rowHeights_[row];
	}

	for ( int col=0;col<=cell.column;col++ ) {
		result.right_ += columnWidths_[col];
	}

	result.left_ = result.right_ - columnWidths_[cell.column];
	result.top_ = result.bottom_ - rowHeights_[cell.row];

	return result;
}

Rect TableControl::getBoundsForItem( TableCellItem* item )
{
	Rect result;

	TableModel* tm = getTableModel();
	CellID cell = tm->getCellIDForItem( item );
	for ( int row=0;row<cell.row;row++ ) {
		result.bottom_ += rowHeights_[row];
	}

	for ( int col=0;col<cell.column;col++ ) {
		result.right_ += columnWidths_[col];
	}

	result.left_ = result.right_ - columnWidths_[cell.column];
	result.top_ = result.bottom_ - rowHeights_[cell.row];

	return result;
}

void TableControl::mouseMove( MouseEvent* event ){
	CustomControl::mouseMove( event );

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}

	if ( !event->hasLeftButton() || ( event->hasLeftButton() && (msNone == mouseState_) ) ) {
		if ( allowColumnResizing_ && columnResizeAreaHitTest( *event->getPoint() ) ) {
			if ( msPrepareColResize != mouseState_ ) {
				mouseState_ = msPrepareColResize;
				setCursorID( Cursor::SCT_SIZE_HORZ );
			}
		}
		else if ( allowRowResizing_ && rowResizeAreaHitTest( *event->getPoint() ) ) {
			if ( msPrepareRowResize != mouseState_ ) {
				mouseState_ = msPrepareRowResize;
				setCursorID( Cursor::SCT_SIZE_VERT );
			}
		}
		else if ( msNone != mouseState_ ) {
			mouseState_ = msNone;
			setCursorID( Cursor::SCT_DEFAULT );
		}

		if ( msNone == mouseState_ ) {
			CellID currentCell;

			//notify of mouse over a cell?
			currentCell = getCellIDFromPoint( *event->getPoint() );

		}

		lastMousePoint_ = *event->getPoint();

		return;
	}

	if ( !clickCell_.isValid() ) {
		lastMousePoint_ = *event->getPoint();

		return;
	}

	if ( event->hasLeftButton() ) {
		switch ( mouseState_ ) {
			case msSelectAll : {

			}
			break;

			case msSelectCells : case msSelectRow: case msSelectColumn : {
				CellID currentCell = getCellIDFromPoint( *event->getPoint() );

				if ( !currentCell.isValid() ) {
					return;
				}

				if ( currentCell != currentCell_ ) {
					//fire selecting event

					doSelection( currentCell );

					TableModel* tm = getTableModel();

					if ( (currentCell.column >= tm->getFixedColumnsCount() &&
						currentCell.row >= tm->getFixedRowsCount()) ) {

						setFocusedCell( currentCell );
					}

				}
			}
			break;

			case msColResizing : {
				//paint resize rect
				setCursorID( Cursor::SCT_SIZE_HORZ );

				if ( allowLiveResizing_ ) {
					Point& point = *event->getPoint();
					if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
						Point start;
						if ( !getCellOrigin( clickCell_, start ) ) {
							return;
						}

						int columnWidth = maxVal<int>( point.x_ - start.x_, allowColumnHide_ ? 0 : 1 );
						setColumnWidth( clickCell_.column, columnWidth );

						//adjust scroll bars
					}
				}
			}
			break;

			case msRowResizing : {
				//paint resize rect
				setCursorID( Cursor::SCT_SIZE_VERT );

				if ( allowLiveResizing_ ) {
					Point& point = *event->getPoint();
					if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
						Point start;
						if ( !getCellOrigin( clickCell_, start ) ) {
							return;
						}

						int rowHeight = maxVal<int>( point.y_ - start.y_, allowRowHide_ ? 0 : 1 );
						setRowHeight( clickCell_.row, rowHeight );

						//adjust scroll bars

					}
				}
			}
			break;

			case msPrepareForEdit : case msPrepareForDrag : {
				//start drag
				mouseState_ = msPrepareForDrag;

				beginDragDrop( event );
			}
			break;
		}
	}
}

void TableControl::mouseUp( MouseEvent* event ){
	CustomControl::mouseUp( event );

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}


	if ( event->hasLeftButton() ) {
		releaseMouseEvents();
	}

	Point pointClickedRel = getClickedPoint( currentCell_, *event->getPoint() );

	if ( msPrepareForEdit == mouseState_ ) {
		//edit cell here
	}
	else if ( msPrepareForDrag == mouseState_ ) {
		clearSelectionRange();

		Event event (this, TableSelectionChangedEvent );
		TableSelectionChanged( &event );
	}
	else if ( msColResizing == mouseState_ ) {
		//clean up sizing rect
		Point& point = *event->getPoint();
		if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
			Point start;
			if ( !getCellOrigin( clickCell_, start ) ) {
				return;
			}

			int columnWidth = maxVal<int>( point.x_ - start.x_, allowColumnHide_ ? 0 : 1 );
			setColumnWidth( clickCell_.column, columnWidth );

			//adjust scroll bars
		}
	}
	else if ( msRowResizing == mouseState_ ) {
		Point& point = *event->getPoint();
		if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
			Point start;
			if ( !getCellOrigin( clickCell_, start ) ) {
				return;
			}

			int rowHeight = maxVal<int>( point.y_ - start.y_, allowRowHide_ ? 0 : 1 );
			setRowHeight( clickCell_.row, rowHeight );

			//adjust scroll bars

		}
	}
	else {
		Event event (this, TableSelectionChangedEvent );
		TableSelectionChanged( &event );
	}

	setCursorID( Cursor::SCT_DEFAULT );

	mouseState_ = msNone;
}

void TableControl::mouseClick(  MouseEvent* event )
{
	CustomControl::mouseClick( event );

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}

	Point &pt = *event->getPoint();

	CellID cell = getCellIDFromPoint( pt );
	if ( !cell.isValid() ) {
		return;
	}


	if ( columnResizeAreaHitTest( pt ) ) {
		Point start;

        if (!getCellOrigin(CellID(0, cell.column), start)) {
            return;
		}

        if ( pt.x_ - start.x_ < resizeCaptureRange_ ) {    // Clicked right of border
            cell.column --;
		}

        //  ignore columns that are hidden and look left towards first visible column
        bool foundVisible = false;
        while( cell.column >= 0) {
            if( columnWidths_[cell.column] > 0) {
                foundVisible = true;
                break;
            }
            cell.column --;
        }

        if( !foundVisible) {
            return;
		}

        autoSizeColumn(cell.column, autoSizeStyle_ );
		repaint();
	}
	else if ( rowResizeAreaHitTest( pt ) ) {
		Point start;
        if (!getCellOrigin( CellID(0, cell.column), start))
            return;

        if (pt.y_ - start.y_ < resizeCaptureRange_)  {    // Clicked below border
            cell.row-- ;
		}

        //  ignore rows that are hidden and look up towards first visible row
        bool foundVisible = false;
        while( cell.row >= 0)  {
            if( rowHeights_[cell.row] > 0) {
                foundVisible = true;
                break;
            }
            cell.row --;
        }

        if( !foundVisible) {
            return;
		}

        autoSizeRow(cell.row);
        repaint();
	}
	else if ( mouseState_ == TableControl::msNone ) {
        TableModel* tm = getTableModel();

		Point pointClickedRel = getClickedPoint( cell, pt );

		TableCellItem* item = tm->getItem( cell.row, cell.column );

		/*
        // Clicked in the text area? Only then will cell selection work
        BOOL bInTextArea = FALSE;
        Rect rectCell;
        if (GetCellRect(cell.row, cell.col, rectCell) && pCell->GetTextRect(rectCell))
                bInTextArea = rectCell.PtInRect(point);

		*/

        if ( cell.row >= tm->getFixedRowsCount() && clickCell_.isValid() &&
            cell.column >= tm->getFixedColumnsCount() )  {

			editCell( cell, pointClickedRel );
        }
    }
}

void TableControl::editCell( const CellID& cell, const Point& pt )
{
	if ( !cell.isValid() ) {
		return;
	}
	TableModel* tm = getTableModel();

	if ( cell.row < tm->getFixedRowsCount() ||
		cell.column < tm->getFixedColumnsCount() ) {

		return;
	}

	TableCellItem* item = tm->getItem( cell.row, cell.column );



	if ( item->isEditable() ) {	

		if ( NULL != currentItemEditor_ ) {
			finishEditing();
		}

		currentItemEditor_ = item->createItemEditor();

		if ( NULL != currentItemEditor_ ) {			
			Control* editorControl = currentItemEditor_->getEditingControl();
			if ( NULL != editorControl ){
				Rect bounds = bounds = getEditCellRect( cell );
				bounds.inflate( -1, -1 );
				
				editorControl->setBounds( &bounds );

				CallBack* ev = getCallback( "TableControl::onFocusLost" );
				editorControl->FocusLost += ev;


				add( editorControl );
				
				editorControl->setVisible( true );
				editorControl->setFocused();

				CallBack* kl = getCallback( TABLECONTROL_KBRD_HANDLER );
				editorControl->KeyDown += kl;

				currentEditingControl_ = editorControl;
			}
			else {
				finishEditing();
			}
		}

	}

}

Rect TableControl::getEditCellRect( const CellID& editCellID )
{
	Rect result;

	Rect visibleRect;
	CellRange visibleCellRange = getVisibleNonFixedCellRange(&visibleRect,true);

	Rect bounds = getBoundsForCell(editCellID);
	Rect visibleTopLeftNonFixedBounds = getBoundsForCell( CellID(visibleCellRange.getMinRow(),visibleCellRange.getMinCol()) );
	
	//offset bounds to "origin" of the visibleTopLeftNonFixedBounds
	bounds.offset( -visibleTopLeftNonFixedBounds.left_, -visibleTopLeftNonFixedBounds.top_ );
	//offset of fixed cols/rows
	bounds.offset( getFixedColumnWidth(), getFixedRowHeight() );

	//now bounds is OK, it's in the regular coord space of the visible control area
	//but we need to adjust for the presense of scroll bars and possibly clip
	//the bounds accordingly
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		Rect clientRect = getClientBounds();
		if ( (editCellID.column >= (visibleCellRange.getMaxCol()-1)) && 
				scrollable->isVerticalScrollbarVisible() ) {
			if ( bounds.right_ > (clientRect.right_ - scrollable->getVerticalScrollbarWidth()) ) {
				bounds.right_ = clientRect.right_;
				bounds.right_ -= scrollable->getVerticalScrollbarWidth();
			}
		}
		
		if ( (editCellID.row >= (visibleCellRange.getMaxRow()-1)) && 
				scrollable->isHorizontalScrollbarVisible() ) {
			if ( bounds.bottom_ > (clientRect.bottom_ - scrollable->getHorizontalScrollbarHeight()) ) {
				bounds.bottom_ = clientRect.bottom_;
				bounds.bottom_ -= scrollable->getHorizontalScrollbarHeight();
			}
		}
	}

	result = bounds;

	return result;
}

void TableControl::setColumnWidth( const uint32& column, const uint32& width )
{
	columnWidths_[column] = width;
	uint32 colCount = columnWidths_.size();
	if ( (true == autoResizeColumns_) && (colCount>1) ) {
		double w = getWidth();
		int32 totwidth = 0;
		for ( uint32 i=0;i<colCount-1;i++) {
			totwidth += columnWidths_[i];
		}
		if ( totwidth < w ){
			columnWidths_[colCount-1] = w-totwidth;
		}
	}
	recalcScrollBars();
	repaint();
}

void TableControl::setRowHeight( const uint32& row, const uint32& height )
{

	rowHeights_[row] = height;

	recalcScrollBars();

	repaint();
}

void TableControl::handleEvent( Event* e )
{
	CustomControl::handleEvent( e );

	if ( e->getType() == CONTROL_SIZED ) {
		Rect clientBounds = getClientBounds();
		uint32 colCount = columnWidths_.size();
		if ( (true == autoResizeColumns_) && (colCount>1) ) {
			//setColumnWidth( colCount-1, columnWidths_[colCount-1] );
		}

		recalcScrollBars();
	}
}


void TableControl::setAutoResizeColumns( const bool& autoResizeColumns )
{
	autoResizeColumns_ = autoResizeColumns;
}

void TableControl::resizeColumnWidths()
{
	TableModel* tm = getTableModel();

	for ( int col=0;col<tm->getColumnCount();col++ ) {
		autoSizeColumn( col );
	}
}

void TableControl::resizeRowHeights()
{
	TableModel* tm = getTableModel();

	for ( int row=0;row<tm->getRowCount();row++ ) {
		autoSizeRow( row );
	}
}

void TableControl::resizeColumnRowDimensions()
{
	resizeColumnWidths();
	resizeRowHeights();
}

void TableControl::onEditingControlKeyPressed( KeyboardEvent* event )
{
	switch ( event->getVirtualCode() ) {
		case vkEscape : {
			cancelEditing();
		}
		break;

		case vkReturn : {
			event->setConsumed( true );
			finishEditing();
		}
		break;

		case vkDownArrow : case vkUpArrow : {
			setFocused(); // this will kill the edit


			KeyboardEvent* event2 =
				new KeyboardEvent( this, event->getType(),
									event->getRepeatCount(),
									event->getKeyMask(),
									event->getKeyValue(),
									event->getVirtualCode() );

			handleEvent( event2 );

			event2->free();

		}
		break;
	}
}


void TableControl::onFinishEditing( Event* e )
{
	FinishEditingEvent* fe = (FinishEditingEvent*)e;

	Control* editingControl = (Control*)e->getSource();
	TableItemEditor* editor = fe->editor_;
	if ( NULL != editingControl ){
		//StringUtils::traceWithArgs( Format("TableControl::onFinishEditing(), editor[%s]@ %s\n") %
		//							editor->getClassName() % editor->toString() );
		remove( editingControl );
		removeComponent( editingControl );
		editingControl->free();
		repaint();
	}

	editor->free();
}

void TableControl::cancelEditing()
{
	EventHandler* ev =
		new ClassProcedure1<Event*,TableControl>( this, &TableControl::onFinishEditing );

	Event* e = new FinishEditingEvent( currentEditingControl_, currentItemEditor_ );

	UIToolkit::postEvent( ev, e );

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;
}

void TableControl::finishEditing()
{
	if ( NULL == currentItemEditor_ ){
		return;
	}

	//StringUtils::trace( "TableControl::finishEditing()\n" );

	currentItemEditor_->updateItem();

	EventHandler* ev =
		new ClassProcedure1<Event*,TableControl>( this, &TableControl::onFinishEditing );

	Event* e = new FinishEditingEvent( currentEditingControl_, currentItemEditor_ );

	UIToolkit::postEvent( ev, e );

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;
}

double TableControl::getRowHeight( uint32 row )
{
	VCF_ASSERT( row < rowHeights_.size() );
	double result = 0;
	int i = 0;
	std::vector<uint32>::iterator it = rowHeights_.begin();
	while ( i <= row ) {
		i ++;

		result += *it;

		it ++;
	}

	return result;
}

double TableControl::getColumnWidth( uint32 col )
{
	VCF_ASSERT( col < columnWidths_.size() );
	double result = 0;
	int i = 0;
	std::vector<uint32>::iterator it = columnWidths_.begin();
	while ( i <= col ) {
		i ++;

		result += *it;

		it ++;
	}

	return result;
}

double TableControl::getFixedColumnWidth()
{
	double result = 0.0;
	TableModel* tm = getTableModel();

	for ( int i=0;i<tm->getFixedColumnsCount();i++ ) {
		result += columnWidths_[i];
	}
	return result;
}

double TableControl::getFixedRowHeight()
{
	double result = 0.0;
	TableModel* tm = getTableModel();

	for ( int i=0;i<tm->getFixedRowsCount();i++ ) {
		result += rowHeights_[i];
	}
	return result;
}


CellID TableControl::getCellIDFromPoint( const Point& pt, bool allowFixedCellCheck )
{
	CellID result ;

	TableModel* tm = getTableModel();

    CellID topLeft = getTopLeftNonFixedCell();

	if (!allowFixedCellCheck && !topLeft.isValid() ) {
		return result;
	}

    // calculate column index
    int fixedColWidth = getFixedColumnWidth();

    if ( pt.x_ < 0 || (!allowFixedCellCheck && pt.x_ < fixedColWidth)) {
		// not in window
        result.column = -1;
	}
    else if (pt.x_ < fixedColWidth) {
		// in fixed col
        int xpos = 0;
        int col = 0;
        while ( col < tm->getFixedColumnsCount() )  {
            xpos += columnWidths_[col];
            if ( xpos > pt.x_ ) {
                break;
			}
			col++;
        }
        result.column = col;
    }
    else {
		// in non-fixed col
        int xpos = fixedColWidth;
		int col = topLeft.column; //m_nFixedCols;
        while ( col < tm->getColumnCount() )  {
            xpos += columnWidths_[col];
            if ( xpos > pt.x_ ) {
                break;
			}
			col++;
        }

        if ( col >= tm->getColumnCount() ) {
            result.column = -1;
		}
        else {
            result.column = col;
		}
    }

    // calculate row index
    int fixedRowHeight = getFixedRowHeight();
    if (pt.y_ < 0 || (!allowFixedCellCheck && pt.y_ < fixedRowHeight)) {
		// not in window
        result.row = -1;
	}
    else if (pt.y_ < fixedRowHeight) {
		// in fixed col
        int ypos = 0;
        int row = 0;
        while ( row < tm->getFixedRowsCount() )  {
            ypos += rowHeights_[row];
            if ( ypos > pt.y_ ) {
                break;
			}
			row++;
        }
        result.row = row;
    }
    else  {
        int ypos = fixedRowHeight;
		int row = topLeft.row;
        while ( row < tm->getRowCount() )  {
            ypos += rowHeights_[row];
            if ( ypos > pt.y_ ) {
                break;
			}
			row++;
        }

        if ( row >= tm->getRowCount() ) {
            result.row = -1;
		}
        else {
            result.row = row;
		}
    }

	return result;
}


TableCellItem* TableControl::getItem( const CellID& cell )
{
	TableModel* tm = getTableModel();

	TableCellItem* result = NULL;

	if ( (tm->getRowCount() > cell.row) && (tm->getColumnCount() > cell.column) ) {
		result = tm->getItem( cell.row, cell.column );
	}

	return result;
}

CellID TableControl::setFocusedCell( const CellID& cell )
{
	CellID result = cell;
	if ( cell == currentCell_ ) {
		return currentCell_;
	}

	CellID prevCell = currentCell_;

	TableModel* tm = getTableModel();
	if ( (cell.row != -1) && (cell.row < tm->getFixedRowsCount()) ) {
		result.row = tm->getFixedRowsCount();
	}

	if ( (cell.column != -1) && (cell.column < tm->getFixedColumnsCount()) ) {
		result.column = tm->getFixedColumnsCount();
	}

	currentCell_ = result;

	tm->setFocusedCell( currentCell_.row, currentCell_.column );

	return prevCell;
}

bool TableControl::columnResizeAreaHitTest( const Point& pt )
{
	CellID cell = getCellIDFromPoint( pt );

	Point start;

	if ( !getCellOrigin( cell, start ) ) {
		return false;
	}

	int endx = start.x_ + columnWidths_[cell.column];

	bool result = false;

	if ( (((pt.x_ - start.x_) < resizeCaptureRange_) && (cell.column != 0)) ||
        ((endx - pt.x_) < resizeCaptureRange_) )  {
        result = true;
    }
    else {
		result = false;
	}

	return result;
}

bool TableControl::rowResizeAreaHitTest( const Point& pt )
{
	CellID cell = getCellIDFromPoint( pt );

	Point start;

	if ( !getCellOrigin( cell, start ) ) {
		return false;
	}

	int endy = start.y_ + rowHeights_[cell.row];

	bool result = false;

	if ( (((pt.y_ - start.y_) < resizeCaptureRange_) && (cell.row != 0)) ||
        ((endy - pt.y_) < resizeCaptureRange_) )  {
        result = true;
    }
    else {
		result = false;
	}

	return result;
}

bool TableControl::getCellOrigin( const CellID& cell, Point& pt )
{
	if ( !cell.isValid() ) {
		return false;
	}

	CellID topLeft(0,0);


	TableModel* tm = getTableModel();
	uint32 fixedCols = tm->getFixedColumnsCount();
	uint32 fixedRows = tm->getFixedRowsCount();


	if ( cell.column >= fixedCols || cell.row >= fixedRows ) {
		topLeft = getTopLeftNonFixedCell();
	}

	if ( (cell.row >= fixedRows && cell.row < topLeft.row) ||
			(cell.column >= fixedCols && cell.column < topLeft.column)  ) {
		return false;
	}

	pt.x_ = 0;

	if ( cell.column < fixedCols ) {
		for ( int i=0;i<cell.column;i++ ) {
			pt.x_ += columnWidths_[i];
		}
	}
	else {
		{//this block is here cause the stupid  #$@!%^&# MSVC6 compiler is lame
			for ( int i=0;i<fixedCols;i++ ) {
				pt.x_ += columnWidths_[i];
			}
		}

		{
			for (int i=topLeft.column;i<cell.column;i++ ){
				pt.x_ += columnWidths_[i];
			}
		}
	}


	pt.y_ = 0;

	if ( cell.row < fixedRows ) {
		for ( int i=0;i<cell.row;i++ ) {
			pt.y_ += rowHeights_[i];
		}
	}
	else {
		{
			for ( int i=0;i<fixedRows;i++ ) {
				pt.y_ += rowHeights_[i];
			}
		}


		{
			for (int i=topLeft.row;i<cell.row;i++ ){
				pt.y_ += rowHeights_[i];
			}
		}
	}

	return true;
}

CellID TableControl::getTopLeftNonFixedCell( const bool& recalc )
{
	if ( topLeftCell_.isValid() && !recalc ) {
		return topLeftCell_;
	}

	double vscrollPos = 0;
	double hscrollPos = 0;
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		vscrollPos = scrollable->getVerticalPosition();
		hscrollPos = scrollable->getHorizontalPosition();
	}

	TableModel* tm = getTableModel();

	topLeftCell_.column = tm->getFixedColumnsCount();

	int right = 0;
	while ( (right < hscrollPos) && (topLeftCell_.column < (tm->getColumnCount()-1)) ) {
		right += columnWidths_[topLeftCell_.column];
		topLeftCell_.column ++;
	}

	topLeftCell_.row = tm->getFixedRowsCount();

	int top = 0;
	while ( (top < vscrollPos) && (topLeftCell_.row < (tm->getRowCount()-1)) ) {
		top += rowHeights_[topLeftCell_.row];
		topLeftCell_.row ++;
	}

	return topLeftCell_;
}


CellRange TableControl::getVisibleNonFixedCellRange( Rect* rect, bool forceRecalculation )
{
	TableModel* tm = getTableModel();

	Rect clientBounds = getClientBounds();

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		//clientBounds.offset( -scrollable->getHorizontalPosition(), -scrollable->getVerticalPosition() );
	}


	CellID topLeft = getTopLeftNonFixedCell( forceRecalculation );

	// calc bottom
	int bottom = getFixedRowHeight();
	int i = 0;
	for (i = topLeft.row; i < tm->getRowCount(); i++) {
		bottom += rowHeights_[i];
		if (bottom >= clientBounds.bottom_) {
			bottom = clientBounds.bottom_;
			break;
		}
	}


	int maxVisibleRow = minVal<uint32>(i, tm->getRowCount() - 1);


	// calc right
	int right = getFixedColumnWidth();

	for (i = topLeft.column; i < tm->getColumnCount(); i++) {
		right += columnWidths_[i];
		if (right >= clientBounds.right_)  {
			right = clientBounds.right_;
			break;
		}
	}


    int maxVisibleCol = minVal<int>(i, tm->getColumnCount() - 1);


	if (NULL != rect) {
		rect->left_ = rect->top_ = 0;
		rect->right_ = right;
		rect->bottom_ = bottom;
	}

	return CellRange(topLeft.row, topLeft.column, maxVisibleRow, maxVisibleCol);
}

Point TableControl::getClickedPoint( const CellID& cell, const Point& pt )
{
	Point result;

	Point cellOrigin;
    if( getCellOrigin( cell, cellOrigin )  ) {
		result = pt;

		result -= cellOrigin;
	}

	return result;
}

void TableControl::clearSelectionRange()
{
	previouslySelectedCellMap_.clear();

	TableModel* tm = getTableModel();
	tm->clearSelection();
}

void TableControl::doSelection( const CellID& cell )
{
	if ( !enableSelection_ ) {
		return;
	}

	switch ( mouseState_ ) {
		case TableControl::msSelectAll : {
			selectAllCells();
		}
		break;

		case TableControl::msSelectColumn : {
			selectColumns( cell );
		}
		break;

		case TableControl::msSelectRow : {
			selectRows( cell );
		}
		break;

		case TableControl::msSelectCells : {
			selectCells( cell );
		}
		break;
	}
}

void TableControl::selectAllCells()
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = getTableModel();
	tm->setSelectedRange( true, tm->getFixedRowsCount(),
							tm->getFixedColumnsCount(),
							tm->getRowCount()-1,
							tm->getColumnCount()-1 );

}

void TableControl::selectColumns( CellID currentCell, bool forceRedraw, bool selectCells )
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = getTableModel();

    //if (currentCell.col == m_idCurrentCell.col) return;
    if ( currentCell.column < tm->getFixedColumnsCount() ) {
        return;
	}
    if ( !currentCell.isValid() ) {
        return;
	}



    if ( allowSingleColumnSelection_ ) {
		tm->setSelectedRange( selectCells,
								tm->getFixedRowsCount(),
								currentCell.column,
								tm->getRowCount()-1,
								currentCell.column );

	}
    else {
		tm->setSelectedRange( selectCells,
								tm->getFixedRowsCount(),
								minVal<>(selectionStartCell_.column,currentCell.column),
								tm->getRowCount()-1,
								maxVal<>(selectionStartCell_.column, currentCell.column ) );
	}
}

void TableControl::selectRows( CellID currentCell, bool forceRedraw, bool selectCells )
{

	if (!enableSelection_) {
        return;
	}

	TableModel* tm = getTableModel();

    if ( currentCell.row < tm->getFixedRowsCount() ) {
        return;
	}
    if ( !currentCell.isValid() ) {
        return;
	}

    if ( allowSingleColumnSelection_ ) {
		tm->setSelectedRange( selectCells,
								currentCell.row,
								tm->getFixedColumnsCount(),
								currentCell.row,
								tm->getColumnCount()-1 );

	}
    else {
		tm->setSelectedRange( selectCells,
								minVal<>(selectionStartCell_.row,currentCell.row),
								tm->getFixedColumnsCount(),
								maxVal<>(selectionStartCell_.row,currentCell.row),
								tm->getColumnCount()-1 );
	}
}

void TableControl::selectCells( CellID currentCell, bool forceRedraw, bool selectCells )
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = getTableModel();


    int row = currentCell.row;
    int col = currentCell.column;
    if (row < tm->getFixedRowsCount() || col < tm->getFixedColumnsCount() ) {
        return;
	}

    if ( !currentCell.isValid() ) {
        return;
	}

    // Prevent unnecessary redraws
    //if (currentCell == m_LeftClickDownCell)  return;
    //else if (currentCell == m_idCurrentCell) return;

	tm->setSelectedRange( selectCells,
							minVal<>(selectionStartCell_.row, row),
							minVal<>(selectionStartCell_.column, col),
							maxVal<>(selectionStartCell_.row, row),
							maxVal<>(selectionStartCell_.column, col) );

}

void TableControl::fixedRowClicked( CellID cell )
{
	if ( !cell.isValid() ) {
        return;
	}

	/*
    if (GetHeaderSort())
    {
        CWaitCursor waiter;
        if (cell.col == GetSortColumn())
            SortItems(cell.col, !GetSortAscending());
        else
            SortItems(cell.col, TRUE);
        Invalidate();
    }
	*/

	TableModel* tm = getTableModel();

	// Did the user click on a fixed column cell (so the cell was within the overlap of
	// fixed row and column cells) - (fix by David Pritchard)
    if ( allowFixedColumnSelection_ )  {
        if ( cell.column < tm->getFixedColumnsCount() ) {
            mouseState_ = TableControl::msSelectAll;
            doSelection( cell );
        }
        else {
            mouseState_ = TableControl::msSelectColumn;
            doSelection( cell );
        }
    }
}

void TableControl::fixedColumnClicked( CellID cell )
{
	if ( !cell.isValid() ) {
        return;
	}

	TableModel* tm = getTableModel();

	// Did the user click on a fixed column cell (so the cell was within the overlap of
	// fixed row and column cells) - (fix by David Pritchard)
    if ( allowFixedRowSelection_ )  {
        if ( cell.row < tm->getFixedRowsCount() ) {
            mouseState_ = TableControl::msSelectAll;
            doSelection( cell );
        }
        else {
            mouseState_ = TableControl::msSelectRow;
            doSelection( cell );
        }
    }
}

void TableControl::recalcScrollBars()
{

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		double totalHeight = getTotalRowHeight();

		double totalWidth = getTotalColumnWidth();

		Rect bounds = getBounds();
		/*
		if ( (getHeight() > totalRowHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}
		else if ( oldTotalHeight > totalRowHeight_ ) {
			double newPos = minVal<double>( abs(totalRowHeight_ - getHeight())+1.0, scrollable->getVerticalPosition() );

			scrollable->setVerticalPosition( newPos );

		}
		*/

		if ( totalWidth > bounds.getWidth() ) {

		}

		scrollable->setVirtualViewWidth(totalWidth);

		scrollable->setVirtualViewHeight( totalHeight );
	}

}

double TableControl::getTotalRowHeight()
{
	double result= 0.0;
	std::vector<uint32>::iterator it = rowHeights_.begin();
	while ( it != rowHeights_.end() ) {
		result += *it;
		it ++;
	}
	return result;
}

double TableControl::getTotalColumnWidth()
{
	double result= 0.0;

	std::vector<uint32>::iterator it = columnWidths_.begin();
	while ( it != columnWidths_.end() ) {
		result += *it;
		it ++;
	}

	return result;
}

void TableControl::onVerticalScrolling( Event* e )
{
	topLeftCell_.row = -1;
	getTopLeftNonFixedCell();

	if ( NULL != currentEditingControl_ ) {
		Rect bounds = getEditCellRect( currentCell_ );
		currentEditingControl_->setBounds( &bounds );
	}	
}

void TableControl::onHorizontalScrolling( Event* e )
{
	topLeftCell_.column = -1;
	getTopLeftNonFixedCell();

	if ( NULL != currentEditingControl_ ) {
		Rect bounds = getEditCellRect( currentCell_ );
		currentEditingControl_->setBounds( &bounds );
	}
}

bool TableControl::autoSizeColumn( int column, AutoSizeOption autoSizeStyle/*=asoDefault*/,
									bool resetScroll/*=true*/ )
{
	TableModel* tm = getTableModel();

	VCF_ASSERT( column >= 0 && column < tm->getColumnCount() );

    if ( column < 0 || column >= tm->getColumnCount()) {
        return false;
	}



    //  Skip hidden columns when autosizing
    if( columnWidths_[column] <=0 ) {
        return false;
	}


	int columnWidth = 0;


    if (TableControl::asoDefault == autoSizeStyle ) {
        autoSizeStyle = autoSizeStyle_;
	}

    int startRow = (autoSizeStyle & TableControl::asoHeader)? 0 : tm->getFixedRowsCount();
    int endRow   = (autoSizeStyle & TableControl::asoData)? tm->getRowCount()-1 : tm->getFixedRowsCount()-1;

	GraphicsContext* ctx = getContext();
	double width = 0;

	for (int row = startRow; row <= endRow; row++)  {
        TableCellItem* cell = tm->getItem( row, column );
		width = cell->getTextCellWidth( ctx );

        if ( width > columnWidth ) {
            columnWidth = width;
		}
    }


    columnWidths_[column] = columnWidth;


    if ( resetScroll) {
		recalcScrollBars();
	}

    return true;
}

bool TableControl::autoSizeRow( int row, bool resetScroll /*=true*/)
{
	TableModel* tm = getTableModel();

    VCF_ASSERT(row >= 0 && row < tm->getRowCount() );
    if (row < 0 || row >= tm->getRowCount()) {
        return false;
	}

    //  Skip hidden rows when autosizing
    if( rowHeights_[row] <=0 ) {
        return false;
	}


    int rowHeight = 0;
    int columnCount = tm->getColumnCount();

	GraphicsContext* ctx = getContext();
	double height = 0;

    for (int col = 0; col < columnCount; col++) {
		TableCellItem* cell = tm->getItem( row, col );

        height = cell->getTextCellHeight( ctx );

        if ( height > rowHeight) {
            rowHeight = height;
		}
    }

    rowHeights_[row] = rowHeight;

    if ( resetScroll ) {
		recalcScrollBars();
	}

    return true;
}

void TableControl::keyDown( KeyboardEvent* e )
{
	CustomControl::keyDown( e );

	TableModel* tm = getTableModel();

	switch( e->getVirtualCode() ) {
		case vkReturn : {

			editCell( clickCell_, Point() );

		}
		break;

		case vkDownArrow : {
			clickCell_.row ++;
			if ( clickCell_.row >= tm->getRowCount() ) {
				clickCell_.row  = 0;
			}

			tm->clearSelection();

			if ( clickCell_.isValid() && (clickCell_.row < tm->getRowCount()) ) {
				selectionStartCell_ = clickCell_;
				clickCell_ = clickCell_;

				setFocusedCell(clickCell_);
				selectCells( clickCell_, true );

				editCell( clickCell_, Point() );
			}
		}
		break;

		case vkUpArrow : {
			clickCell_.row --;
			if ( clickCell_.row < 0 ) {
				clickCell_.row  = tm->getRowCount()-1;
			}

			tm->clearSelection();

			if ( clickCell_.isValid() ) {
				selectionStartCell_ = clickCell_;
				clickCell_ = clickCell_;

				setFocusedCell(clickCell_);
				selectCells( clickCell_, true );

				editCell( clickCell_, Point() );
			}
		}
		break;
	}
}

Color* TableControl::getDefaultTableCellColor()
{
	return defaultCellColor_;
}

void TableControl::setDefaultTableCellColor( Color* color )
{
	*defaultCellColor_ = *color;
}

Font* TableControl::getDefaultTableCellFont()
{
	return defaultCellFont_;
}

void TableControl::setDefaultTableCellFont( Font* font )
{
	*defaultCellFont_ = *font;
}


/**
$Id$
*/
