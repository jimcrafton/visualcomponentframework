//TableControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/TableControl.h"
#include "vcf/ApplicationKit/DefaultTableModel.h"
#include "vcf/ApplicationKit/TableItemEditor.h"
#include "vcf/ApplicationKit/Containers.h"

using namespace VCF;


#define TABLECONTROL_KBRD_HANDLER		"TCKeyboardHandler"


class FinishEditingEvent : public Event {
public:
	FinishEditingEvent( Control* source, TableItemEditor* editor ): Event(source,0), editor_(editor){

	}
	TableItemEditor* editor_;
};



TableControl::TableControl( TableModel* model ):
	CustomControl( true ),
	totalRowHeight_(0.0),
	drawGridLinesStyle_(TableControl::dglDrawBoth),
	enableSelection_(true),
	allowSingleColumnSelection_(true),
	allowSingleRowSelection_(true),
	allowFixedColumnSelection_(true),
	allowFixedRowSelection_(true),
	allowLiveResizing_(true),
	autoSizeStyle_(TableControl::asoBoth)
{
	setContainerDelegate( this );

	setViewModel( model );

	init();
}

TableControl::~TableControl()
{

}

void TableControl::setDrawGridLinesStyle( DrawGridLines val )
{
	drawGridLinesStyle_ = val;
	repaint();
}

void TableControl::paint( GraphicsContext * context )
{
	Point oldOrigin = context->getOrigin();
	Rect oldViewBounds = context->getViewableBounds();

	CustomControl::paint( context );


	Point origin = context->getOrigin();
	Rect viewBounds = context->getViewableBounds();

	bool hasScrollable = false;
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		hasScrollable = true;
	}

	if ( hasScrollable ) {
		//reset origin
		context->setOrigin( oldOrigin );
		context->setViewableBounds( oldViewBounds );
	}

	TableModel* tm = (TableModel*) getViewModel();
	ulong32 rowCount = tm->getRowCount();
	ulong32 columnCount = tm->getColumnCount();

	if ( (rowCount > 0) && (columnCount > 0) ) {

		ulong32 fixedRowCount = tm->getFixedRowsCount();
		ulong32 fixedColumnCount = tm->getFixedColumnsCount();



		int fixedRowHeight = getFixedRowHeight();
		int fixedColWidth  = getFixedColumnWidth();

		CellID topLeft = getTopLeftNonFixedCell();
		int minVisibleRow = topLeft.row;
		int minVisibleCol = topLeft.column;

		Rect visibleRect;
		CellRange visibleCellRange = getVisibleNonFixedCellRange(&visibleRect);
		int maxVisibleRow = visibleCellRange.getMaxRow();
		int maxVisibleCol = visibleCellRange.getMaxCol();

		Rect rect;
		rect.bottom_ = -1;
		ulong32 rowHeight = 0;
		ulong32 colWidth = 0;
		TableCellItem* cellItem = NULL;

		ulong32 row, col;

		Rect clipRect = context->getViewableBounds();
		//getClippingRect();


		for (row = 0; row < fixedRowCount; row++)  {
			rowHeight = rowHeights_[row];

			if ( rowHeight <= 0 ) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;
			rect.right_ = -1;

			for (col = 0; col < fixedColumnCount; col++) {
				colWidth = columnWidths_[col];
				if ( colWidth <= 0) {
					continue;
				}

				rect.left_ = rect.right_+1;
				rect.right_ = rect.left_ + colWidth-1;

				cellItem = tm->getItem( row, col );
				cellItem->paint( context, &rect );
			}
		}

		// draw fixed column cells:  m_nFixedRows..n, 0..m_nFixedCols-1
		rect.bottom_ = fixedRowHeight-1;
		for (row = minVisibleRow; row <= maxVisibleRow; row++)  {
			rowHeight = rowHeights_[row];
			if ( rowHeight <= 0 ) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;

			// rect.bottom = bottom pixel of previous row
			if ( rect.top_ > clipRect.bottom_ ) {
				break;                // Gone past cliprect
			}

			if ( rect.bottom_ < clipRect.top_ ) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = -1;
			for (col = 0; col < fixedColumnCount; col++)  {
				colWidth = columnWidths_[col];

				if ( colWidth <= 0 )  {
					continue;
				}

				rect.left_ = rect.right_+1;
				rect.right_ = rect.left_ + colWidth-1;

				if ( rect.left_ > clipRect.right_ ) {
					break;            // gone past cliprect
				}

				if ( rect.right_ < clipRect.left_ ) {
					continue;         // Reached cliprect yet?
				}

				cellItem = tm->getItem( row, col );
				cellItem->paint( context, &rect );
			}
		}

		// draw fixed row cells  0..m_nFixedRows, m_nFixedCols..n
		rect.bottom_ = -1;
		for (row = 0; row < fixedRowCount; row++)  {
			rowHeight = rowHeights_[row];
			if ( rowHeight <= 0) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;



			// rect.bottom = bottom pixel of previous row
			if ( rect.top_ > clipRect.bottom_ ) {
				break;                // Gone past cliprect
			}

			if ( rect.bottom_ < clipRect.top_ ) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = fixedColWidth-1;

			TableRowItemEnumerator* rowItemEnum = tm->getRowItemEnumerator( row );
			col = 0;
			while ( rowItemEnum->hasMoreElements() && (col <= maxVisibleCol) ){
				cellItem = rowItemEnum->nextElement();

				if ( col >= minVisibleCol ) {
					colWidth = columnWidths_[col];

					if ( colWidth > 0 ) {
						rect.left_ = rect.right_+1;
						rect.right_ = rect.left_ + colWidth-1;

						if (rect.left_ > clipRect.right_ ) {
							break;        // gone past cliprect
						}

						if (rect.right_ < clipRect.left_) {
							continue;     // Reached cliprect yet?
						}


						cellItem->paint( context, &rect );
					}
				}

				col ++;
			}

		}

		// draw rest of non-fixed cells

		if ( hasScrollable ) {
			Rect tmp( fixedColWidth, fixedRowHeight,
						viewBounds.right_, viewBounds.bottom_ );

			//set clipping region
			clipRect = tmp;
			//context->setClippingRect( &tmp );
		}


		rect.bottom_ = fixedRowHeight-1;
		for (row = minVisibleRow; row <= maxVisibleRow; row++)  {
			rowHeight = rowHeights_[row];

			if ( rowHeight <= 0) {
				continue;
			}

			rect.top_ = rect.bottom_+1;
			rect.bottom_ = rect.top_ + rowHeight-1;

			// rect.bottom = bottom pixel of previous row
			if (rect.top_ > clipRect.bottom_) {
				break;                // Gone past cliprect
			}

			if (rect.bottom_ < clipRect.top_) {
				continue;             // Reached cliprect yet?
			}

			rect.right_ = fixedColWidth-1;

			TableRowItemEnumerator* rowItemEnum = tm->getRowItemEnumerator( row );

			col = 0;
			while ( rowItemEnum->hasMoreElements() && (col <= maxVisibleCol) ) {
				cellItem = rowItemEnum->nextElement();

				if ( col >= minVisibleCol ) {
					colWidth = columnWidths_[col];

					if ( colWidth > 0 ) {
						rect.left_ = rect.right_+1;
						rect.right_ = rect.left_ + colWidth-1;

						StringUtils::traceWithArgs( "Cliprect: %s\n", clipRect.toString().c_str() );

						if (rect.left_ > clipRect.right_ ) {
							break;        // gone past cliprect
						}

						if (rect.right_ < clipRect.left_ ) {
							continue;     // Reached cliprect yet?
						}

						//context->setColor( &Color(0xCCCCCC) );
						//context->rectangle( &rect );
						//context->fillPath();
						cellItem->paint( context, &rect );

					}
				}
				col ++;
			}
		}

		context->setStrokeWidth( 1 );
		context->setColor( &Color(0.0,0.0,0.0) );
		// draw vertical lines (drawn at ends of cells)
		if ( drawGridLinesStyle_ == TableControl::dglDrawBoth ||
			drawGridLinesStyle_ == TableControl::dglDrawVerticalLines ) {

			int x = fixedColWidth;
			for (col = minVisibleCol; col <= maxVisibleCol; col++)  {
				colWidth = columnWidths_[col];
				if ( colWidth <= 0 ) {
					continue;
				}

				x += colWidth;
				context->moveTo( x-1, fixedRowHeight );
				context->lineTo( x-1, visibleRect.bottom_ );
			}

			context->strokePath();

		}

		// draw horizontal lines (drawn at bottom of each cell)
		if ( drawGridLinesStyle_ == TableControl::dglDrawBoth ||
			drawGridLinesStyle_ == TableControl::dglDrawHorizontalLines ) {

			int y = fixedRowHeight;
			for (row = minVisibleRow; row <= maxVisibleRow; row++) {
				rowHeight = rowHeights_[row];
				if ( rowHeight <= 0 ) {
					continue;
				}

				y += rowHeight;
				context->moveTo( fixedColWidth, y-1 );
				context->lineTo( visibleRect.right_,  y-1 );
			}
			context->strokePath();
		}

	}

	paintChildren( context );
}

void TableControl::init()
{
	autoResizeColumns_ = true;
	allowColumnResizing_ = true;
	allowRowResizing_ = true;
	hiddenColumnUnhide_ = false;
	hiddenRowUnhide_ = false;
	listMode_ = false;
	allowColumnHide_ = false;
	allowRowHide_ = false;

	//selectedCellItem_ = NULL;

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;

	setContainer( new StandardContainer() );


	defaultColumnWidth_ = DEFAULT_COLUMN_WIDTH;
	defaultRowHeight_ = UIToolkit::getUIMetricsManager()->getDefaultHeightFor( UIMetricsManager::htLabelHeight );

	mouseState_ = msNone;

	resizeCaptureRange_ = 5;

	if ( NULL == this->getViewModel() ){
		setTableModel( new DefaultTableModel() );
	}
	EventHandler* tmh =
		new TableModelEventHandler<TableControl>( this, &TableControl::onTableModelChanged, "TableModelHandler" );

	TableModel* model = getTableModel();

	model->TableCellAdded += tmh;
	model->TableCellDeleted += tmh;
	model->TableColumnsAdded += tmh;
	model->TableColumnsDeleted += tmh;
	model->TableRowsAdded += tmh;
	model->TableRowsDeleted += tmh;
	model->TableCellsSelected += tmh;

	ModelEventHandler<TableControl>* modelHandler =
		new ModelEventHandler<TableControl>( this, &TableControl::onTableModelEmptied, "ModelHandler" );
	model->addModelHandler( modelHandler );

	KeyboardEventHandler<TableControl>* kh =
		new KeyboardEventHandler<TableControl>( this, &TableControl::onEditingControlKeyPressed, TABLECONTROL_KBRD_HANDLER );


	EventHandler* focusLost =
		new FocusEventHandler<TableControl>( this, &TableControl::onFocusLost, "TableControl::onFocusLost" );


	ScrollbarManager* scroller = new ScrollbarManager();
	addComponent( scroller ) ;
	scroller->setHasHorizontalScrollbar( true );
	scroller->setHasVerticalScrollbar( true );
	scroller->setTarget( this );

	EventHandler* ev = new GenericEventHandler<TableControl>(this, &TableControl::onVerticalScrolling, "TableControl::onVerticalScrolling" );
	scroller->VerticalScrolling += ev;

	ev = new GenericEventHandler<TableControl>(this, &TableControl::onHorizontalScrolling, "TableControl::onHorizontalScrolling" );
	scroller->HorizontalScrolling += ev;

}

void TableControl::onTableModelEmptied( ModelEvent* e )
{
	//this needs to happen here cause we receive this event
	//AFTER the table model's items have been cleared so the
	//model is now empty at this point

	currentItemEditor_ = NULL;

	finishEditing();

	columnWidths_.clear();
	rowHeights_.clear();

	//selectedCellItem_ = NULL;


	resizeDragPt_.setNull();
	lastMousePoint_.setNull();
	leftClickPoint_.setNull();

	clickCell_.row = -1;
	clickCell_.column = -1;

	selectionStartCell_.row = -1;
	selectionStartCell_.column = -1;

	currentCell_.row = -1;
	currentCell_.column = -1;
}

void TableControl::onTableModelChanged( TableModelEvent* event )
{
	finishEditing();

	//selectedCellItem_ = NULL;

	TableModel* tm = (TableModel*)getViewModel();

	EventHandler* itemHandler = getEventHandler(TABLECELL_HANDLER);
	switch ( event->getType() ){
		case COLUMNS_DELETED:{

		}
		break;

		case COLUMNS_ADDED:{
			int start = event->getStartColumnThatChanged();
			for (int col=start;col<event->getNumberOfColumnsAffected()+start;col++ ) {
				columnWidths_.insert( columnWidths_.begin() + col,
				                         defaultColumnWidth_ );
			}


			uint32 rowCount = tm->getRowCount();
			for ( ulong32 row=0;row<rowCount;row++){

				for (int col=start;col<event->getNumberOfColumnsAffected()+start;col++ ) {

					Item* item = tm->getItem( row, col );
					if ( NULL != item ){
						item->addItemSelectedHandler( itemHandler );
						item->setControl( this );
					}
				}
			}

		}
		break;

		case ROWS_DELETED:{

		}
		break;

		case ROWS_ADDED:{
			int start = event->getStartRowThatChanged();

			uint32 colCount = tm->getColumnCount();

			for (int row=start;row<event->getNumberOfRowsAffected()+start;row++ ) {
				rowHeights_.insert( rowHeights_.begin() + row, defaultRowHeight_ );

				for (int col=0;col<colCount;col++ ) {

					Item* item = tm->getItem( row, col );
					if ( NULL != item ){
						item->addItemSelectedHandler( itemHandler );
					}
					item->setControl( this );
				}
			}

		}
		break;

		case ALL_COLUMNS_CHANGED:{

		}
		break;

		case ALL_ROWS_CHANGED:{

		}
		break;

		case CELL_CHANGED:{
			repaint();
		}
		break;
	}
}

uint32 TableControl::getDefaultRowHeight()
{
	return defaultRowHeight_;
}

void TableControl::setDefaultRowHeight( const uint32& defaultRowHeight )
{
	defaultRowHeight_ = defaultRowHeight;
}

uint32 TableControl::getDefaultColumnWidth()
{
	return defaultColumnWidth_;
}

void TableControl::setDefaultColumnWidth( const uint32& defaultColumnWidth )
{
	defaultColumnWidth_ = defaultColumnWidth;
}


TableModel* TableControl::getTableModel()
{
	return (TableModel*)getViewModel();
}

void TableControl::setTableModel( TableModel* model )
{
	setViewModel( model );
}

void TableControl::setColumnCount( const uint32& colCount )
{

}

void TableControl::setRowCount( const uint32& rowCount )
{

}


void TableControl::onFocusLost( FocusEvent* e )
{
	//if ( e->getType() == 0 ) {
		finishEditing();
	//	e->setConsumed( true );
	//}
	//else {
	//	EventHandler* ev = getEventHandler( "TableControl::onFocusLost" );
	//	FocusEvent* newEvent = new FocusEvent( e->getSource(), 0 );
	//	StringUtils::traceWithArgs( "newEvent: %s\n", newEvent->toString().c_str() );
	//	UIToolkit::postEvent( ev, newEvent, false );
	//}
}

void TableControl::mouseDown( MouseEvent* event ){
	CustomControl::mouseDown( event );

	Scrollable* scrollable = this->getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}

	finishEditing();

	if ( event->hasLeftButton() ) {
		TableModel* tm = (TableModel*)getViewModel();


		leftClickPoint_ = *event->getPoint();
		clickCell_ = getCellIDFromPoint( *event->getPoint() );

		if ( !clickCell_.isValid() ) {
			return;
		}

		if ( !event->hasShiftKey() ) {
			selectionStartCell_ = clickCell_;
		}
		else {
			if ( !selectionStartCell_.isValid() ) {
				selectionStartCell_ = currentCell_;
			}
		}

		//end editing here

		TableCellClickEvent clickEvent( this, TableControl::TableCellClickedEvent, clickCell_ );
		TableCellDown.fireEvent( &clickEvent );


		TableCellItem* item = getItem( clickCell_ );

		if ( (clickCell_ == currentCell_) && (!event->hasControlKey()) && (item->isEditable()) ) {
			mouseState_ = TableControl::msPrepareForEdit;
			return;
		}
		/*
		else if ( clickCell_.isValid() ) {

			tm->setSelectedCell( true, clickCell_.row, clickCell_.column );

		}
		*/
		else if ( item->isSelected() ){
			if ( event->hasControlKey() ) {
				setFocusedCell( clickCell_ );
				return;
			}
			else {
				mouseState_ = TableControl::msPrepareForDrag;
			}
		}
		else if ( (mouseState_ != TableControl::msPrepareColResize) &&
			(mouseState_ != TableControl::msPrepareRowResize) ) {
			if ( (clickCell_.row >= tm->getFixedRowsCount()) &&
					 (clickCell_.column >= tm->getFixedColumnsCount()) ) {

				setFocusedCell( clickCell_ );
			}
			else {
				setFocusedCell( CellID(-1,-1) );
			}
		}


		keepMouseEvents();

		if ( TableControl::msNone == mouseState_ ) {
			if ( allowColumnResizing_ && columnResizeAreaHitTest( *event->getPoint() ) ) {
				if ( TableControl::msPrepareColResize != mouseState_ ) {
					mouseState_ = TableControl::msPrepareColResize;

					//change the cursor
					setCursorID( Cursor::SCT_SIZE_HORZ );
				}
				else {
					setCursorID( Cursor::SCT_DEFAULT );
				}
			}
			else if ( allowRowResizing_ && rowResizeAreaHitTest( *event->getPoint() ) ) {
				if ( TableControl::msPrepareRowResize != mouseState_ ) {
					mouseState_ = TableControl::msPrepareRowResize;

					//change the cursor
					setCursorID( Cursor::SCT_SIZE_VERT );
				}
				else {
					setCursorID( Cursor::SCT_DEFAULT );
				}
			}
		}

		if ( TableControl::msPrepareColResize == mouseState_ ) {
			mouseState_ = TableControl::msColResizing;

			if ( columnWidths_[tm->getColumnCount()-1] < resizeCaptureRange_ ) {
				Rect visibleRect;

				getVisibleNonFixedCellRange( &visibleRect );


				if ( abs( (long)((event->getPoint()->x_ - visibleRect.right_ ) < resizeCaptureRange_)) ) {

					clickCell_.column = tm->getColumnCount()-1;
				}
			}

			Point start;

			if ( !getCellOrigin( CellID(0, clickCell_.column), start ) ) {

				return;
			}

			if ( !hiddenColumnUnhide_ ) {
				//  ignore columns that are hidden and look left towards first visible column
				bool lookForVisible = true;
				bool isCellRightBorder = abs((long)(event->getPoint()->x_ - start.x_)) >= resizeCaptureRange_;

				if( isCellRightBorder && ((clickCell_.column + 1) >= tm->getColumnCount()) ) {
					// clicked on last column's right border

					// if last column is visible, don't do anything
					if( clickCell_.column >= 0)
						lookForVisible = false;
				}

				if( lookForVisible ) {
					// clicked on column divider other than last right border
					bool foundVisible = false;
					int offset = 1;

					if( isCellRightBorder) {
						offset = 0;
					}

					while( clickCell_.column - offset >= 0) {

						if( columnWidths_[clickCell_.column - offset] > 0)	{
							foundVisible = true;
							break;
						}
						clickCell_.column--;
					}
					if ( !foundVisible ) {
						return;
					}
				}
			}

			Rect clientRect = getClientBounds();
			Rect invertedRect( event->getPoint()->x_, clientRect.top_,
								event->getPoint()->x_ + 2, clientRect.bottom_ );

			/**
			We need to paint an inverse rect as measured by invertedRect
			on the current graphics context
			*/
			/*
			CDC* pDC = GetDC();
			if (pDC)
			{
				pDC->InvertRect(&invertedRect);
				ReleaseDC(pDC);
			}
			*/

			// If we clicked to the right of the colimn divide, then reset the click-down cell
			// as the cell to the left of the column divide - UNLESS we clicked on the last column
			// and the last column is teensy (kludge fix)
			if ( (event->getPoint()->x_ - start.x_) < resizeCaptureRange_) {
				if (clickCell_.column < tm->getColumnCount()-1 ||
					columnWidths_[tm->getColumnCount()-1] >= resizeCaptureRange_) {
					clickCell_.column --;
					if ( !getCellOrigin( CellID(0,clickCell_.column), start) ) {
						return;
					}
				}
			}

			// Allow a cell resize width no greater than that which can be viewed within
			// the grid itself
			int maxCellWidth = clientRect.getWidth() - getFixedColumnWidth();
			clientRect.left_  = start.x_ + 1;
			clientRect.right_ = clientRect.left_ + maxCellWidth;

			/**
			Do we need to really clip the cursor like this?
			*/
			//ClientToScreen(rect);

			//ClipCursor(rect);
		}
		else if ( TableControl::msPrepareRowResize == mouseState_ ) {
			mouseState_ = TableControl::msRowResizing;

			// Kludge for if we are over the last column...
			if ( rowHeights_[tm->getRowCount()-1] < resizeCaptureRange_ ) 	{
				Rect visibleRect;
				getVisibleNonFixedCellRange( &visibleRect );

				if ( abs((long)(event->getPoint()->y_ - visibleRect.bottom_)) < resizeCaptureRange_ ) {
					clickCell_.row = tm->getRowCount()-1;
				}
			}

			Point start;
			if ( !getCellOrigin(clickCell_, start) ) {
				return;
			}

			if( !hiddenRowUnhide_ )  {
				//  ignore rows that are hidden and look up towards first visible row
				bool lookForVisible = true;
				bool isCellBottomBorder = abs((long)(event->getPoint()->y_ - start.y_)) >= resizeCaptureRange_;

				if( isCellBottomBorder && ( clickCell_.row + 1 >= tm->getRowCount()) ) {
					// clicked on last row's bottom border

					// if last row is visible, don't do anything
					if( clickCell_.row >= 0)
						lookForVisible = false;
				}

				if( lookForVisible ) {
					// clicked on row divider other than last bottom border
					bool foundVisible = false;
					int offset = 1;

					if( isCellBottomBorder) {
						offset = 0;
					}

					while( clickCell_.row - offset >= 0 ) {
						if( rowHeights_[ clickCell_.row - offset] > 0) {
							foundVisible = true;
							break;
						}
						clickCell_.row--;
					}
					if( !foundVisible)
						return;
				}
			}

			Rect clientRect = getClientBounds();

			Rect invertedRect(clientRect.left_, event->getPoint()->y_,
								clientRect.right_, event->getPoint()->y_ + 2);

			/**
			We need to paint an inverse rect as measured by invertedRect
			on the current graphics context
			*/
			/*
			CDC* pDC = GetDC();
			if (pDC)
			{
				pDC->InvertRect(&invertedRect);
				ReleaseDC(pDC);
			}
			*/

			// If we clicked below the row divide, then reset the click-down cell
			// as the cell above the row divide - UNLESS we clicked on the last row
			// and the last row is teensy (kludge fix)
			if ( abs((long)(event->getPoint()->y_ - start.y_)) < resizeCaptureRange_ ) {  // clicked below border
				if ( clickCell_.row < tm->getRowCount()-1 ||
					rowHeights_[tm->getRowCount()-1] >= resizeCaptureRange_ ) {

					clickCell_.row -- ;

					if ( !getCellOrigin(CellID(clickCell_.row,0), start)) {
						return;
					}
				}
			}

			int maxCellHeight = clientRect.getHeight()-getFixedRowHeight();
			clientRect.top_ = start.y_ + 1;
			clientRect.bottom_ = clientRect.top_ + maxCellHeight;

			/*
			ClientToScreen(rect);


			ClipCursor(rect);
			*/
		}
		else if ( TableControl::msPrepareForDrag != mouseState_ ) {
			//should we fire an event to a delegate here???? tablemodel? control??


			// If Ctrl pressed, save the current cell selection. This will get added
			// to the new cell selection at the end of the cell selection process
			if ( event->hasControlKey() ) {
				Enumerator<TableCellItem*>* selectedCells = tm->getSelectedCells();

				while ( selectedCells->hasMoreElements() ) {

					TableCellItem* item = selectedCells->nextElement();

					previouslySelectedCellMap_[ tm->getCellIDForItem(item) ] = item;
				}
			}

			if ( clickCell_.row < tm->getFixedRowsCount() ) {

				fixedRowClicked( clickCell_ );

				TableCellClickEvent event(this,FixedRowClickedEvent,clickCell_);

				FixedRowClicked.fireEvent( &event );
			}
			else if ( clickCell_.column < tm->getFixedColumnsCount() ) {

				fixedColumnClicked( clickCell_ );

				TableCellClickEvent event(this,FixedColumnClickedEvent,clickCell_);

				FixedColumnClicked.fireEvent( &event );
			}
			else {
				mouseState_ = listMode_ ? TableControl::msSelectRow : TableControl::msSelectCells;

				doSelection( clickCell_ );

				TableCellClickEvent event(this,SelectingEvent,clickCell_);

				TableSelecting.fireEvent( &event );

				//m_nTimerID = SetTimer(WM_LBUTTONDOWN, m_nTimerInterval, 0);
			}
		}



		lastMousePoint_ = *event->getPoint();
	}
}

Rect TableControl::getBoundsForCell( const CellID& cell )
{
	Rect result;

	for ( int row=0;row<=cell.row;row++ ) {
		result.bottom_ += rowHeights_[row];
	}

	for ( int col=0;col<=cell.column;col++ ) {
		result.right_ += columnWidths_[col];
	}

	result.left_ = result.right_ - columnWidths_[cell.column];
	result.top_ = result.bottom_ - rowHeights_[cell.row];

	return result;
}

Rect TableControl::getBoundsForItem( TableCellItem* item )
{
	Rect result;

	TableModel* tm = (TableModel*)getViewModel();
	CellID cell = tm->getCellIDForItem( item );
	for ( int row=0;row<cell.row;row++ ) {
		result.bottom_ += rowHeights_[row];
	}

	for ( int col=0;col<cell.column;col++ ) {
		result.right_ += columnWidths_[col];
	}

	result.left_ = result.right_ - columnWidths_[cell.column];
	result.top_ = result.bottom_ - rowHeights_[cell.row];

	return result;
}

void TableControl::mouseMove( MouseEvent* event ){
	CustomControl::mouseMove( event );

	Scrollable* scrollable = this->getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}

	if ( !event->hasLeftButton() || ( event->hasLeftButton() && (msNone == mouseState_) ) ) {
		if ( allowColumnResizing_ && columnResizeAreaHitTest( *event->getPoint() ) ) {
			if ( msPrepareColResize != mouseState_ ) {
				mouseState_ = msPrepareColResize;
				setCursorID( Cursor::SCT_SIZE_HORZ );
			}
			else {
				setCursorID( Cursor::SCT_DEFAULT );
			}
		}
		else if ( allowRowResizing_ && rowResizeAreaHitTest( *event->getPoint() ) ) {
			if ( msPrepareRowResize != mouseState_ ) {
				mouseState_ = msPrepareRowResize;
				setCursorID( Cursor::SCT_SIZE_VERT );
			}
			else {
				setCursorID( Cursor::SCT_DEFAULT );
			}
		}
		else if ( msNone != mouseState_ ) {
			mouseState_ = msNone;
		}

		if ( msNone == mouseState_ ) {
			CellID currentCell;

			//notify of mouse over a cell?
			currentCell = getCellIDFromPoint( *event->getPoint() );

		}

		lastMousePoint_ = *event->getPoint();

		return;
	}

	if ( !clickCell_.isValid() ) {
		lastMousePoint_ = *event->getPoint();

		return;
	}

	if ( event->hasLeftButton() ) {
		switch ( mouseState_ ) {
			case msSelectAll : {

			}
			break;

			case msSelectCells : case msSelectRow: case msSelectColumn : {
				CellID currentCell = getCellIDFromPoint( *event->getPoint() );

				if ( !currentCell.isValid() ) {
					return;
				}

				if ( currentCell != currentCell_ ) {
					//fire selecting event

					doSelection( currentCell );

					TableModel* tm = (TableModel*) getViewModel();

					if ( (currentCell.column >= tm->getFixedColumnsCount() &&
						currentCell.row >= tm->getFixedRowsCount()) ) {

						setFocusedCell( currentCell );
					}

				}
			}
			break;

			case msColResizing : {
				//paint resize rect
				setCursorID( Cursor::SCT_SIZE_HORZ );

				if ( allowLiveResizing_ ) {
					Point& point = *event->getPoint();
					if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
						Point start;
						if ( !getCellOrigin( clickCell_, start ) ) {
							return;
						}

						int columnWidth = maxVal<int>( point.x_ - start.x_, allowColumnHide_ ? 0 : 1 );
						setColumnWidth( clickCell_.column, columnWidth );

						//adjust scroll bars
					}
				}
			}
			break;

			case msRowResizing : {
				//paint resize rect
				setCursorID( Cursor::SCT_SIZE_VERT );

				if ( allowLiveResizing_ ) {
					Point& point = *event->getPoint();
					if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
						Point start;
						if ( !getCellOrigin( clickCell_, start ) ) {
							return;
						}

						int rowHeight = maxVal<int>( point.y_ - start.y_, allowRowHide_ ? 0 : 1 );
						setRowHeight( clickCell_.row, rowHeight );

						//adjust scroll bars

					}
				}
			}
			break;

			case msPrepareForEdit : case msPrepareForDrag : {
				//start drag
				mouseState_ = msPrepareForDrag;

				beginDragDrop( event );
			}
			break;
		}
	}
}

void TableControl::mouseUp( MouseEvent* event ){
	CustomControl::mouseUp( event );

	Scrollable* scrollable = this->getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}


	if ( event->hasLeftButton() ) {
		releaseMouseEvents();
	}

	Point pointClickedRel = getClickedPoint( currentCell_, *event->getPoint() );

	if ( msPrepareForEdit == mouseState_ ) {
		//edit cell here
	}
	else if ( msPrepareForDrag == mouseState_ ) {
		clearSelectionRange();

		Event event (this, TableSelectionChangedEvent );
		TableSelectionChanged.fireEvent( &event );
	}
	else if ( msColResizing == mouseState_ ) {
		//clean up sizing rect
		Point& point = *event->getPoint();
		if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
			Point start;
			if ( !getCellOrigin( clickCell_, start ) ) {
				return;
			}

			int columnWidth = maxVal<int>( point.x_ - start.x_, allowColumnHide_ ? 0 : 1 );
			setColumnWidth( clickCell_.column, columnWidth );

			//adjust scroll bars
		}
	}
	else if ( msRowResizing == mouseState_ ) {
		Point& point = *event->getPoint();
		if ( (leftClickPoint_ != point) && (point.x_ != 0.0 && point.y_ != 0.0) ) {
			Point start;
			if ( !getCellOrigin( clickCell_, start ) ) {
				return;
			}

			int rowHeight = maxVal<int>( point.y_ - start.y_, allowRowHide_ ? 0 : 1 );
			setRowHeight( clickCell_.row, rowHeight );

			//adjust scroll bars

		}
	}
	else {
		Event event (this, TableSelectionChangedEvent );
		TableSelectionChanged.fireEvent( &event );
	}


	mouseState_ = msNone;
}

void TableControl::mouseDblClick(  MouseEvent* event )
{
	CustomControl::mouseDblClick( event );

	Scrollable* scrollable = this->getScrollable();
	if ( NULL != scrollable ) {
		event->getPoint()->x_ -= scrollable->getHorizontalPosition();
		event->getPoint()->y_ -= scrollable->getVerticalPosition();
	}

	Point &pt = *event->getPoint();

	CellID cell = this->getCellIDFromPoint( pt );
	if ( !cell.isValid() ) {
		return;
	}


	if ( columnResizeAreaHitTest( pt ) ) {
		Point start;

        if (!getCellOrigin(CellID(0, cell.column), start)) {
            return;
		}

        if ( pt.x_ - start.x_ < resizeCaptureRange_ ) {    // Clicked right of border
            cell.column --;
		}

        //  ignore columns that are hidden and look left towards first visible column
        bool foundVisible = false;
        while( cell.column >= 0) {
            if( columnWidths_[cell.column] > 0) {
                foundVisible = true;
                break;
            }
            cell.column --;
        }

        if( !foundVisible) {
            return;
		}

        autoSizeColumn(cell.column, this->autoSizeStyle_ );
		repaint();
	}
	else if ( this->rowResizeAreaHitTest( pt ) ) {
		Point start;
        if (!getCellOrigin( CellID(0, cell.column), start))
            return;

        if (pt.y_ - start.y_ < resizeCaptureRange_)  {    // Clicked below border
            cell.row-- ;
		}

        //  ignore rows that are hidden and look up towards first visible row
        bool foundVisible = false;
        while( cell.row >= 0)  {
            if( rowHeights_[cell.row] > 0) {
                foundVisible = true;
                break;
            }
            cell.row --;
        }

        if( !foundVisible) {
            return;
		}

        autoSizeRow(cell.row);
        repaint();
	}
	else if ( this->mouseState_ == TableControl::msNone ) {
        TableModel* tm = (TableModel*)getViewModel();

		Point pointClickedRel = getClickedPoint( cell, pt );

		TableCellItem* item = tm->getItem( cell.row, cell.column );

		/*
        // Clicked in the text area? Only then will cell selection work
        BOOL bInTextArea = FALSE;
        Rect rectCell;
        if (GetCellRect(cell.row, cell.col, rectCell) && pCell->GetTextRect(rectCell))
                bInTextArea = rectCell.PtInRect(point);

		*/

        if ( cell.row >= tm->getFixedRowsCount() && this->clickCell_.isValid() &&
            cell.column >= tm->getFixedColumnsCount() )  {

			editCell( cell, pointClickedRel );
        }
    }
}

void TableControl::editCell( const CellID& cell, const Point& pt )
{
	if ( !cell.isValid() ) {
		return;
	}
	TableModel* tm = (TableModel*)getViewModel();

	if ( cell.row < tm->getFixedRowsCount() ||
		cell.column < tm->getFixedColumnsCount() ) {

		return;
	}

	TableCellItem* item = tm->getItem( cell.row, cell.column );



	if ( item->isEditable() ) {
		Rect bounds = getBoundsForCell( cell );

		if ( NULL != currentItemEditor_ ) {
			finishEditing();
		}

		currentItemEditor_ = item->createItemEditor();

		if ( NULL != currentItemEditor_ ) {
			currentItemEditor_->setItemToEdit( item );
			Control* editorControl = currentItemEditor_->getEditingControl();
			if ( NULL != editorControl ){
				editorControl->setBounds( &bounds );

				EventHandler* ev = getEventHandler( "TableControl::onFocusLost" );
				editorControl->FocusLost += ev;


				add( editorControl );
				currentEditingControl_ = editorControl;
				currentEditingControl_->setVisible( true );
				currentEditingControl_->setFocused();

				EventHandler* kl = getEventHandler( TABLECONTROL_KBRD_HANDLER );
				currentEditingControl_->KeyPressed.addHandler( kl );
			}
			else {
				finishEditing();
			}
		}

	}

}

void TableControl::setColumnWidth( const uint32& column, const uint32& width )
{
	columnWidths_[column] = width;
	uint32 colCount = columnWidths_.size();
	if ( (true == autoResizeColumns_) && (colCount>1) ) {
		double w = getWidth();
		int32 totwidth = 0;
		for ( ulong32 i=0;i<colCount-1;i++) {
			totwidth += columnWidths_[i];
		}
		if ( totwidth < w ){
			columnWidths_[colCount-1] = w-totwidth;
		}
	}
	recalcScrollBars();
	repaint();
}

void TableControl::setRowHeight( const uint32& row, const uint32& height )
{

	rowHeights_[row] = height;

	recalcScrollBars();

	repaint();
}

void TableControl::handleEvent( Event* e )
{
	CustomControl::handleEvent( e );

	if ( e->getType() == CONTROL_SIZED ) {
		Rect clientBounds = getClientBounds();
		uint32 colCount = columnWidths_.size();
		if ( (true == autoResizeColumns_) && (colCount>1) ) {
			//setColumnWidth( colCount-1, columnWidths_[colCount-1] );
		}

		recalcScrollBars();
	}
}


void TableControl::setAutoResizeColumns( const bool& autoResizeColumns )
{
	autoResizeColumns_ = autoResizeColumns;
}

void TableControl::resetColumnWidths()
{

}

void TableControl::onEditingControlKeyPressed( KeyboardEvent* event )
{
	switch ( event->getVirtualCode() ) {
		case vkEscape : {
			cancelEditing();
		}
		break;

		case vkReturn : {
			event->setConsumed( true );
			finishEditing();
		}
		break;

		case vkDownArrow : case vkUpArrow : {
			setFocused(); // this will kill the edit


			KeyboardEvent* event2 =
				new KeyboardEvent( this, event->getType(),
									event->getRepeatCount(),
									event->getKeyMask(),
									event->getKeyValue(),
									event->getVirtualCode() );

			handleEvent( event2 );

			event2->free();

		}
		break;
	}
}


void TableControl::onFinishEditing( Event* e )
{
	FinishEditingEvent* fe = (FinishEditingEvent*)e;

	Control* editingControl = (Control*)e->getSource();
	TableItemEditor* editor = fe->editor_;
	if ( NULL != editingControl ){
		StringUtils::traceWithArgs( "TableControl::finishEditing(), editor[%s]@ %s\n",
									editor->getClassName().c_str(), editor->toString().c_str() );
		remove( editingControl );
		removeComponent( editingControl );
		editingControl->free();
		repaint();
	}

	editor->free();
}

void TableControl::cancelEditing()
{
	EventHandler* ev =
		new GenericEventHandler<TableControl>( this, &TableControl::onFinishEditing );

	Event* e = new FinishEditingEvent( currentEditingControl_, currentItemEditor_ );

	UIToolkit::postEvent( ev, e );

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;
}

void TableControl::finishEditing()
{
	if ( NULL != currentItemEditor_ ){
		currentItemEditor_->updateItem();
	}
	else {
		return;
	}

	EventHandler* ev =
		new GenericEventHandler<TableControl>( this, &TableControl::onFinishEditing );

	Event* e = new FinishEditingEvent( currentEditingControl_, currentItemEditor_ );

	UIToolkit::postEvent( ev, e );

	currentEditingControl_ = NULL;
	currentItemEditor_ = NULL;
}

double TableControl::getRowHeight( uint32 row )
{
	VCF_ASSERT( row < rowHeights_.size() );
	double result = 0;
	int i = 0;
	std::vector<uint32>::iterator it = rowHeights_.begin();
	while ( i <= row ) {
		i ++;

		result += *it;

		it ++;
	}

	return result;
}

double TableControl::getColumnWidth( uint32 col )
{
	VCF_ASSERT( col < columnWidths_.size() );
	double result = 0;
	int i = 0;
	std::vector<uint32>::iterator it = columnWidths_.begin();
	while ( i <= col ) {
		i ++;

		result += *it;

		it ++;
	}

	return result;
}

double TableControl::getFixedColumnWidth()
{
	double result = 0.0;
	TableModel* tm = (TableModel*) getViewModel();

	for ( int i=0;i<tm->getFixedColumnsCount();i++ ) {
		result += columnWidths_[i];
	}
	return result;
}

double TableControl::getFixedRowHeight()
{
	double result = 0.0;
	TableModel* tm = (TableModel*) getViewModel();

	for ( int i=0;i<tm->getFixedRowsCount();i++ ) {
		result += rowHeights_[i];
	}
	return result;
}


CellID TableControl::getCellIDFromPoint( const Point& pt, bool allowFixedCellCheck )
{
	CellID result ;

	TableModel* tm = (TableModel*) getViewModel();

    CellID topLeft = getTopLeftNonFixedCell();

	if (!allowFixedCellCheck && !topLeft.isValid() ) {
		return result;
	}

    // calculate column index
    int fixedColWidth = getFixedColumnWidth();

    if ( pt.x_ < 0 || (!allowFixedCellCheck && pt.x_ < fixedColWidth)) {
		// not in window
        result.column = -1;
	}
    else if (pt.x_ < fixedColWidth) {
		// in fixed col
        int xpos = 0;
        int col = 0;
        while ( col < tm->getFixedColumnsCount() )  {
            xpos += columnWidths_[col];
            if ( xpos > pt.x_ ) {
                break;
			}
			col++;
        }
        result.column = col;
    }
    else {
		// in non-fixed col
        int xpos = fixedColWidth;
		int col = topLeft.column; //m_nFixedCols;
        while ( col < tm->getColumnCount() )  {
            xpos += columnWidths_[col];
            if ( xpos > pt.x_ ) {
                break;
			}
			col++;
        }

        if ( col >= tm->getColumnCount() ) {
            result.column = -1;
		}
        else {
            result.column = col;
		}
    }

    // calculate row index
    int fixedRowHeight = getFixedRowHeight();
    if (pt.y_ < 0 || (!allowFixedCellCheck && pt.y_ < fixedRowHeight)) {
		// not in window
        result.row = -1;
	}
    else if (pt.y_ < fixedRowHeight) {
		// in fixed col
        int ypos = 0;
        int row = 0;
        while ( row < tm->getFixedRowsCount() )  {
            ypos += rowHeights_[row];
            if ( ypos > pt.y_ ) {
                break;
			}
			row++;
        }
        result.row = row;
    }
    else  {
        int ypos = fixedRowHeight;
		int row = topLeft.row;
        while ( row < tm->getRowCount() )  {
            ypos += rowHeights_[row];
            if ( ypos > pt.y_ ) {
                break;
			}
			row++;
        }

        if ( row >= tm->getRowCount() ) {
            result.row = -1;
		}
        else {
            result.row = row;
		}
    }

	return result;
}


TableCellItem* TableControl::getItem( const CellID& cell )
{
	TableModel* tm = (TableModel*)getViewModel();

	TableCellItem* result = NULL;

	if ( (tm->getRowCount() > cell.row) && (tm->getColumnCount() > cell.column) ) {
		result = tm->getItem( cell.row, cell.column );
	}

	return result;
}

CellID TableControl::setFocusedCell( const CellID& cell )
{
	CellID result = cell;
	if ( cell == currentCell_ ) {
		return currentCell_;
	}

	CellID prevCell = currentCell_;

	TableModel* tm = (TableModel*)getViewModel();
	if ( (cell.row != -1) && (cell.row < tm->getFixedRowsCount()) ) {
		result.row = tm->getFixedRowsCount();
	}

	if ( (cell.column != -1) && (cell.column < tm->getFixedColumnsCount()) ) {
		result.column = tm->getFixedColumnsCount();
	}

	currentCell_ = result;

	tm->setFocusedCell( currentCell_.row, currentCell_.column );

	return prevCell;
}

bool TableControl::columnResizeAreaHitTest( const Point& pt )
{
	if ( pt.y_ > getFixedRowHeight() ) {
		//return false;
	}

	CellID cell = getCellIDFromPoint( pt );

	Point start;

	if ( !getCellOrigin( cell, start ) ) {
		return false;
	}

	int endx = start.x_ + columnWidths_[cell.column];

	bool result = false;

	if ( ((abs((long)(pt.x_ - start.x_)) < resizeCaptureRange_) && (cell.column != 0)) ||
        (abs((long)(endx - pt.x_)) < resizeCaptureRange_) )  {
        result = true;
    }
    else {
		result = false;
	}

	return result;
}

bool TableControl::rowResizeAreaHitTest( const Point& pt )
{
	if ( pt.x_ > getFixedColumnWidth() ) {
		return false;
	}

	CellID cell = getCellIDFromPoint( pt );

	Point start;

	if ( !getCellOrigin( cell, start ) ) {
		return false;
	}

	int endy = start.y_ + rowHeights_[cell.row];

	bool result = false;

	if ( ((abs((long)(pt.y_ - start.y_)) < resizeCaptureRange_) && (cell.row != 0)) ||
        (abs((long)(endy - pt.y_)) < resizeCaptureRange_) )  {
        result = true;
    }
    else {
		result = false;
	}

	return result;
}

bool TableControl::getCellOrigin( const CellID& cell, Point& pt )
{
	if ( !cell.isValid() ) {
		return false;
	}

	CellID topLeft(0,0);


	TableModel* tm = (TableModel*)getViewModel();
	uint32 fixedCols = tm->getFixedColumnsCount();
	uint32 fixedRows = tm->getFixedRowsCount();


	if ( cell.column >= fixedCols || cell.row >= fixedRows ) {
		topLeft = getTopLeftNonFixedCell();
	}

	if ( (cell.row >= fixedRows && cell.row < topLeft.row) ||
			(cell.column >= fixedCols && cell.column < topLeft.column)  ) {
		return false;
	}

	pt.x_ = 0;

	if ( cell.column < fixedCols ) {
		for ( int i=0;i<cell.column;i++ ) {
			pt.x_ += columnWidths_[i];
		}
	}
	else {
		{//this block is here cause the stupid  #$@!%^&# MSVC6 compiler is lame
			for ( int i=0;i<fixedCols;i++ ) {
				pt.x_ += columnWidths_[i];
			}
		}

		{
			for (int i=topLeft.column;i<cell.column;i++ ){
				pt.x_ += columnWidths_[i];
			}
		}
	}


	pt.y_ = 0;

	if ( cell.row < fixedRows ) {
		for ( int i=0;i<cell.row;i++ ) {
			pt.y_ += rowHeights_[i];
		}
	}
	else {
		{
			for ( int i=0;i<fixedRows;i++ ) {
				pt.y_ += rowHeights_[i];
			}
		}


		{
			for (int i=topLeft.row;i<cell.row;i++ ){
				pt.y_ += rowHeights_[i];
			}
		}
	}

	return true;
}

CellID TableControl::getTopLeftNonFixedCell( const bool& recalc )
{
	if ( topLeftCell_.isValid() && !recalc ) {
		return topLeftCell_;
	}

	double vscrollPos = 0;
	double hscrollPos = 0;
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		vscrollPos = scrollable->getVerticalPosition();
		hscrollPos = scrollable->getHorizontalPosition();
	}

	TableModel* tm = (TableModel*)getViewModel();

	topLeftCell_.column = tm->getFixedColumnsCount();

	int right = 0;
	while ( (right < hscrollPos) && (topLeftCell_.column < (tm->getColumnCount()-1)) ) {
		right += columnWidths_[topLeftCell_.column];
		topLeftCell_.column ++;
	}

	topLeftCell_.row = tm->getFixedRowsCount();

	int top = 0;
	while ( (top < vscrollPos) && (topLeftCell_.row < (tm->getRowCount()-1)) ) {
		top += rowHeights_[topLeftCell_.row];
		topLeftCell_.row ++;
	}

	return topLeftCell_;
}


CellRange TableControl::getVisibleNonFixedCellRange( Rect* rect, bool forceRecalculation )
{
	TableModel* tm = (TableModel*)getViewModel();

	Rect clientBounds = getClientBounds();

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		//clientBounds.offset( -scrollable->getHorizontalPosition(), -scrollable->getVerticalPosition() );
	}


	CellID topLeft = getTopLeftNonFixedCell( forceRecalculation );

	// calc bottom
	int bottom = getFixedRowHeight();
	int i = 0;
	for (i = topLeft.row; i < tm->getRowCount(); i++) {
		bottom += rowHeights_[i];
		if (bottom >= clientBounds.bottom_) {
			bottom = clientBounds.bottom_;
			break;
		}
	}


	int maxVisibleRow = minVal<uint32>(i, tm->getRowCount() - 1);


	// calc right
	int right = getFixedColumnWidth();

	for (i = topLeft.column; i < tm->getColumnCount(); i++) {
		right += columnWidths_[i];
		if (right >= clientBounds.right_)  {
			right = clientBounds.right_;
			break;
		}
	}


    int maxVisibleCol = minVal<int>(i, tm->getColumnCount() - 1);


	if (NULL != rect) {
		rect->left_ = rect->top_ = 0;
		rect->right_ = right;
		rect->bottom_ = bottom;
	}

	return CellRange(topLeft.row, topLeft.column, maxVisibleRow, maxVisibleCol);
}

Point TableControl::getClickedPoint( const CellID& cell, const Point& pt )
{
	Point result;

	Point cellOrigin;
    if( getCellOrigin( cell, cellOrigin )  ) {
		result = pt;

		result -= cellOrigin;
	}

	return result;
}

void TableControl::clearSelectionRange()
{
	previouslySelectedCellMap_.clear();

	TableModel* tm = (TableModel*)getViewModel();
	tm->clearSelection();
}

void TableControl::doSelection( const CellID& cell )
{
	if ( !enableSelection_ ) {
		return;
	}

	switch ( mouseState_ ) {
		case TableControl::msSelectAll : {
			selectAllCells();
		}
		break;

		case TableControl::msSelectColumn : {
			selectColumns( cell );
		}
		break;

		case TableControl::msSelectRow : {
			selectRows( cell );
		}
		break;

		case TableControl::msSelectCells : {
			selectCells( cell );
		}
		break;
	}
}

void TableControl::selectAllCells()
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = (TableModel*)getViewModel();
	tm->setSelectedRange( true, tm->getFixedRowsCount(),
							tm->getFixedColumnsCount(),
							tm->getRowCount()-1,
							tm->getColumnCount()-1 );

}

void TableControl::selectColumns( CellID currentCell, bool forceRedraw, bool selectCells )
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = (TableModel*)getViewModel();

    //if (currentCell.col == m_idCurrentCell.col) return;
    if ( currentCell.column < tm->getFixedColumnsCount() ) {
        return;
	}
    if ( !currentCell.isValid() ) {
        return;
	}



    if ( allowSingleColumnSelection_ ) {
		tm->setSelectedRange( selectCells,
								tm->getFixedRowsCount(),
								currentCell.column,
								tm->getRowCount()-1,
								currentCell.column );

	}
    else {
		tm->setSelectedRange( selectCells,
								tm->getFixedRowsCount(),
								minVal<>(selectionStartCell_.column,currentCell.column),
								tm->getRowCount()-1,
								maxVal<>(selectionStartCell_.column, currentCell.column ) );
	}
}

void TableControl::selectRows( CellID currentCell, bool forceRedraw, bool selectCells )
{

	if (!enableSelection_) {
        return;
	}

	TableModel* tm = (TableModel*)getViewModel();

    if ( currentCell.row < tm->getFixedRowsCount() ) {
        return;
	}
    if ( !currentCell.isValid() ) {
        return;
	}

    if ( allowSingleColumnSelection_ ) {
		tm->setSelectedRange( selectCells,
								currentCell.row,
								tm->getFixedColumnsCount(),
								currentCell.row,
								tm->getColumnCount()-1 );

	}
    else {
		tm->setSelectedRange( selectCells,
								minVal<>(selectionStartCell_.row,currentCell.row),
								tm->getFixedColumnsCount(),
								maxVal<>(selectionStartCell_.row,currentCell.row),
								tm->getColumnCount()-1 );
	}
}

void TableControl::selectCells( CellID currentCell, bool forceRedraw, bool selectCells )
{
	if (!enableSelection_) {
        return;
	}

	TableModel* tm = (TableModel*)getViewModel();


    int row = currentCell.row;
    int col = currentCell.column;
    if (row < tm->getFixedRowsCount() || col < tm->getFixedColumnsCount() ) {
        return;
	}

    if ( !currentCell.isValid() ) {
        return;
	}

    // Prevent unnecessary redraws
    //if (currentCell == m_LeftClickDownCell)  return;
    //else if (currentCell == m_idCurrentCell) return;

	tm->setSelectedRange( selectCells,
							minVal<>(selectionStartCell_.row, row),
							minVal<>(selectionStartCell_.column, col),
							maxVal<>(selectionStartCell_.row, row),
							maxVal<>(selectionStartCell_.column, col) );

}

void TableControl::fixedRowClicked( CellID cell )
{
	if ( !cell.isValid() ) {
        return;
	}

	/*
    if (GetHeaderSort())
    {
        CWaitCursor waiter;
        if (cell.col == GetSortColumn())
            SortItems(cell.col, !GetSortAscending());
        else
            SortItems(cell.col, TRUE);
        Invalidate();
    }
	*/

	TableModel* tm = (TableModel*)getViewModel();

	// Did the user click on a fixed column cell (so the cell was within the overlap of
	// fixed row and column cells) - (fix by David Pritchard)
    if ( allowFixedColumnSelection_ )  {
        if ( cell.column < tm->getFixedColumnsCount() ) {
            mouseState_ = TableControl::msSelectAll;
            doSelection( cell );
        }
        else {
            mouseState_ = TableControl::msSelectColumn;
            doSelection( cell );
        }
    }
}

void TableControl::fixedColumnClicked( CellID cell )
{
	if ( !cell.isValid() ) {
        return;
	}

	TableModel* tm = (TableModel*)getViewModel();

	// Did the user click on a fixed column cell (so the cell was within the overlap of
	// fixed row and column cells) - (fix by David Pritchard)
    if ( allowFixedRowSelection_ )  {
        if ( cell.row < tm->getFixedRowsCount() ) {
            mouseState_ = TableControl::msSelectAll;
            doSelection( cell );
        }
        else {
            mouseState_ = TableControl::msSelectRow;
            doSelection( cell );
        }
    }
}

void TableControl::recalcScrollBars()
{

	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		double totalHeight = getTotalRowHeight();

		double totalWidth = getTotalColumnWidth();

		Rect bounds = getBounds();
		/*
		if ( (getHeight() > totalRowHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}
		else if ( oldTotalHeight > totalRowHeight_ ) {
			double newPos = minVal<double>( abs(totalRowHeight_ - getHeight())+1.0, scrollable->getVerticalPosition() );

			scrollable->setVerticalPosition( newPos );

		}
		*/

		if ( totalWidth > bounds.getWidth() ) {

		}

		scrollable->setVirtualViewWidth(totalWidth);

		scrollable->setVirtualViewHeight( totalHeight );
	}

}

double TableControl::getTotalRowHeight()
{
	double result= 0.0;
	std::vector<uint32>::iterator it = rowHeights_.begin();
	while ( it != rowHeights_.end() ) {
		result += *it;
		it ++;
	}
	return result;
}

double TableControl::getTotalColumnWidth()
{
	double result= 0.0;

	std::vector<uint32>::iterator it = columnWidths_.begin();
	while ( it != columnWidths_.end() ) {
		result += *it;
		it ++;
	}

	return result;
}

void TableControl::onVerticalScrolling( Event* e )
{
	topLeftCell_.row = -1;
	getTopLeftNonFixedCell();
}

void TableControl::onHorizontalScrolling( Event* e )
{
	topLeftCell_.column = -1;
	getTopLeftNonFixedCell();
}

bool TableControl::autoSizeColumn( int column, AutoSizeOption autoSizeStyle/*=asoDefault*/,
									bool resetScroll/*=true*/ )
{
	TableModel* tm = (TableModel*)getViewModel();

	VCF_ASSERT( column >= 0 && column < tm->getColumnCount() );

    if ( column < 0 || column >= tm->getColumnCount()) {
        return false;
	}



    //  Skip hidden columns when autosizing
    if( columnWidths_[column] <=0 ) {
        return false;
	}


	int columnWidth = 0;


    if (TableControl::asoDefault == autoSizeStyle ) {
        autoSizeStyle = autoSizeStyle_;
	}

    int startRow = (autoSizeStyle & TableControl::asoHeader)? 0 : tm->getFixedRowsCount();
    int endRow   = (autoSizeStyle & TableControl::asoData)? tm->getRowCount()-1 : tm->getFixedRowsCount()-1;

	GraphicsContext* ctx = this->getContext();
	double width = 0;

	for (int row = startRow; row <= endRow; row++)  {
        TableCellItem* cell = tm->getItem( row, column );
        width = ctx->getTextWidth( cell->getCaption() );

        if ( width > columnWidth ) {
            columnWidth = width;
		}
    }


    columnWidths_[column] = columnWidth;


    if ( resetScroll) {
		recalcScrollBars();
	}

    return true;
}

bool TableControl::autoSizeRow( int row, bool resetScroll /*=true*/)
{
	TableModel* tm = (TableModel*)getViewModel();

    VCF_ASSERT(row >= 0 && row < tm->getRowCount() );
    if (row < 0 || row >= tm->getRowCount()) {
        return false;
	}

    //  Skip hidden rows when autosizing
    if( rowHeights_[row] <=0 ) {
        return false;
	}


    int rowHeight = 0;
    int columnCount = tm->getColumnCount();

	GraphicsContext* ctx = this->getContext();
	double height = 0;

    for (int col = 0; col < columnCount; col++) {
		TableCellItem* cell = tm->getItem( row, col );

        height = ctx->getTextHeight( cell->getCaption() ) + 10;

        if ( height > rowHeight) {
            rowHeight = height;
		}
    }

    rowHeights_[row] = rowHeight;

    if ( resetScroll ) {
		this->recalcScrollBars();
	}

    return true;
}

void TableControl::keyDown( KeyboardEvent* e )
{
	CustomControl::keyDown( e );

	TableModel* tm = (TableModel*)getViewModel();

	switch( e->getVirtualCode() ) {
		case vkReturn : {

			editCell( clickCell_, Point() );

		}
		break;

		case vkDownArrow : {
			clickCell_.row ++;
			if ( clickCell_.row >= tm->getRowCount() ) {
				clickCell_.row  = 0;
			}

			tm->clearSelection();

			if ( clickCell_.isValid() && (clickCell_.row < tm->getRowCount()) ) {
				selectionStartCell_ = clickCell_;
				clickCell_ = clickCell_;

				setFocusedCell(clickCell_);
				selectCells( clickCell_, true );

				editCell( clickCell_, Point() );
			}
		}
		break;

		case vkUpArrow : {
			clickCell_.row --;
			if ( clickCell_.row < 0 ) {
				clickCell_.row  = tm->getRowCount()-1;
			}

			tm->clearSelection();

			if ( clickCell_.isValid() ) {
				selectionStartCell_ = clickCell_;
				clickCell_ = clickCell_;

				setFocusedCell(clickCell_);
				selectCells( clickCell_, true );

				editCell( clickCell_, Point() );
			}
		}
		break;
	}
}


/**
*CVS Log info
*$Log$
*Revision 1.2  2004/08/07 02:49:09  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.5  2004/07/30 17:27:13  kiklop74
*Added first release of Borland midifications for VCF
*
*Revision 1.1.2.4  2004/07/17 17:56:24  ddiego
*minor mods to the TableControl and the TabbedPages control
*so that drawing updates get drawn better, and we don't have weird missing
*artifacts.
*
*Revision 1.1.2.3  2004/07/08 15:08:05  ddiego
*made the change to the StandardContainer name - the
*old StandardContainer is now called DesignTimeContainer and
*the old FixedStandardContainer is now renamed to StandardContainer.
*
*Revision 1.1.2.2  2004/04/29 03:43:14  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:19  ddiego
*migration towards new directory structure
*
*Revision 1.25  2004/04/03 15:48:44  ddiego
*Merged over code from the 0-6-3 branch.
*
*Revision 1.24.2.23  2004/03/26 18:17:30  marcelloptr
*minor fix VCF_ASSERT2 --> VCF_ASSERT
*
*Revision 1.24.2.22  2004/03/26 01:38:11  ddiego
*added Marcello's suggestion for the additional VCF_ASSERT
*macro. So we now have one which takes a single parameter, and another
*which takes 2 parameters, the assert condition, and a message.
*
*Revision 1.24.2.21  2004/03/19 21:25:57  ddiego
*just some minor noodlin
*
*Revision 1.24.2.20  2004/03/19 04:18:43  ddiego
*added more code to condition example, fixed some
*minor stuff in the table control
*
*Revision 1.24.2.19  2004/03/18 04:19:26  ddiego
*some minor stuff for tables
*
*Revision 1.24.2.18  2004/03/17 03:22:28  ddiego
*fixed a glitch in setting focus
*
*Revision 1.24.2.17  2004/03/15 04:54:49  ddiego
*minor niggles
*
*Revision 1.24.2.16  2004/03/12 22:15:44  ddiego
*stuff
*
*Revision 1.24.2.15  2004/03/11 04:37:13  ddiego
*minor changes to table control.
*
*Revision 1.24.2.14  2004/03/10 04:27:45  ddiego
*blah
*
*Revision 1.24.2.13  2004/03/08 04:41:07  ddiego
*minor changes to DocumentManager - allow the use of
*Actions so that other UI elements can be added besides menu
*items (like Toolbar items)
*
*Revision 1.24.2.12  2004/03/03 05:02:53  ddiego
*Table editing is working again. The only major missing piece
*as compared to the CGridCtrl, is drag/drop support.
*
*Revision 1.24.2.11  2004/03/02 03:46:15  ddiego
*some minor fixes for GCC. Still having a problem with GCC on linux, linking, and wide strings. I don't know which I hate more, GCC or MSVC6. Sigh... :(
*
*Revision 1.24.2.10  2004/03/01 05:59:19  ddiego
*and even MORE updates to the TableControl. Most of the core functionality
from Chris Maunder's CGridCtrl has been migrated over, and is functional. Item
editing and item dragging is still not done. Had to make a minor change to the
AbstractScroallable class to allow it have vertical and/or horizontal delegate's
set in order to notify them of position changes. This was needed by the TableControl
to properly update the top left non fixed cell calculation. The performance is
kind of slow ( :) ) in debug mode, but quite snappy in release.
*
*Revision 1.24.2.9  2004/02/27 04:42:35  ddiego
*more table control coding - some minor optimizations in the painting code
*
*Revision 1.24.2.8  2004/02/26 05:10:38  ddiego
*more table control work
*
*Revision 1.24.2.7  2004/02/19 04:52:35  ddiego
*more progress made with TableControl
*
*Revision 1.24.2.6  2004/02/15 20:24:02  ddiego
*intial Locales implementation is now checked in. This adds several new classes, namely:
*The LocalePeer, which is the OS generic peer for interfacing with teh OS for lcoale support
*The Locale class which provides locale support for the vcf
*The Win32LocalePeer which provides a basic Win32 implementation for locale support
*The UnicodeString class, which is a near identical class to the std::string class and provides a wrapper around a std::basic_string<wchar_t>. This also adds support for translating to and from ansi strings, and supporting text encoding via a TextEncoder class.
*The TextCodec class which allows for custom text codec for encoding or decoding text.
*The MessageLoader class which is used to provide localized string translation
*The StringsMessageLoader which provides a basic implementation of string loading and translation that is compatible with Apples .strings resource files.
*
*Revision 1.24.2.5  2004/02/12 22:00:30  marcelloptr
*minor fixes related to TabModel
*
*Revision 1.24.2.4  2004/02/02 04:38:45  ddiego
*more table codin'
*
*Revision 1.24.2.3  2004/01/30 22:08:08  ddiego
*more fixes to the table model and table control
*
*Revision 1.24.2.2  2004/01/30 05:08:14  ddiego
*added more rearrangements for the table control
*
*Revision 1.24.2.1  2004/01/29 22:26:48  ddiego
*table fixes, this still needs some more work
*
*Revision 1.24  2003/12/18 05:16:00  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.23.2.2  2003/09/05 21:03:21  ddiego
*moved the various control destructor's to protected scope
*migrated code into destroy() overridden methods
*----------------------------------------------------------------------
*
*Revision 1.23.2.1  2003/08/18 19:52:37  ddiego
*changed the Container from being a class you derive from to a separate
*intance that is created and assigned dynamically to any Control.
*
*Revision 1.23  2003/08/09 02:56:45  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.22.2.1  2003/07/24 04:10:44  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.22  2003/05/17 20:37:49  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.21.2.3  2003/04/17 04:29:53  ddiego
*updated scintilla, added gtk support for the application kit, with stubs
*for the basic peers.
*
*Revision 1.21.2.2  2003/03/23 03:24:01  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.21.2.1  2003/03/12 03:13:23  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.21  2003/02/26 04:30:57  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.20.2.5  2003/02/24 05:42:19  ddiego
*moved the code for the VariantData calss into it's own header
*migrated to the new event style using Delegates instead of relying on
*the ugly macros that we were using before - same functionality though
*made sure everything still works and compiles, including neccessary
*changes in the VCF Builder so that it creates code in the new style
*This changes to teh new style of using Delegates completes task 58837
*
*Revision 1.20.2.4  2003/01/08 00:20:01  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.20.2.3  2002/12/28 01:56:22  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.20.2.2  2002/12/27 23:05:09  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.20.2.1  2002/12/25 22:06:36  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.20  2002/11/18 00:46:10  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.19.4.2  2002/11/16 20:31:35  ddiego
*this fixes the following bugs:
*632802 TextControl's setViewModel not called
*639416 ListViewControl's setViewModel not called
*639417 TreeControl's setViewModel not called
*639418 ListBoxControl's setViewModel not called
*639419 ComboBoxControl's setViewModel not called
*639420 TreeListControl's setViewModel not called
*basically just required that setViewModel() get called. Also made changes to
*the TableControl and teh TabbedPages control
*
*Revision 1.19.4.1  2002/11/09 05:17:10  ddiego
*changes are for fixing bug [ 634798 ] Property pane not scrolling.
*ignore the inclusion of TreeListControl.cpp in this checkin.
*
*Revision 1.19  2002/09/12 03:26:06  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.18.6.5  2002/09/10 17:08:45  ddiego
*fixe to TableControl for finishEditing method
*
*Revision 1.18.6.4  2002/09/10 04:07:51  ddiego
*misc fixes plus now posting the TableControl::finishEditing as a event
*
*Revision 1.18.6.3  2002/09/06 14:12:02  ddiego
*fixed a bug in the table control where an internal pointer was not being
*properly set to null when the table model underneath it was changed.
*
*Revision 1.18.6.2  2002/09/06 05:24:52  ddiego
*fixed bug in TableControl where it does not proeprly finished the ItemEditor
*correctly on loss of focus for the editor's control
*
*Revision 1.18.6.1  2002/09/05 21:49:44  ddiego
*added support for kevboard events in deleting a component and
*setting a property value
*some miscellaneous fixes
*some merges in the xmake makefiles for FK and GK
*
*Revision 1.18  2002/05/09 03:10:46  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.17.4.2  2002/04/27 15:52:52  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.17.4.1  2002/04/08 20:55:31  zzack
*changed include style
*
*Revision 1.17  2002/01/24 01:46:50  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


