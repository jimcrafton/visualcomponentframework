//COMUtils.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ApplicationKitPrivate.h"
#include "vcf/ApplicationKit/COMUtils.h"
#include "vcf/ApplicationKit/Win32Clipboard.h"
#include <shellapi.h>

#if !defined(__GNUWIN32__) && !defined(VCF_CW_W32)
#include <comdef.h>
#endif


using namespace VCFCOM;
using namespace VCF;


std::map<VCF::String,UINT> COMUtils::standardWin32DataTypes;

HRESULT COMUtils::createCOMObject( const String& progID, IID interfaceID,
		                             void** object )
{
	HRESULT comResult = E_FAIL;

	CLSID clsid;

#if defined(__GNUWIN32__) || defined(VCF_CW_W32)
	wchar_t* tmp = new wchar_t[progID.size()+1];
	memset( tmp, 0 , (progID.size()+1)*sizeof(wchar_t) );
	AnsiString id = progID;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, id.c_str(), id.size(), tmp, progID.size() ) ) {
		return comResult;
	}


 	BSTR tmpProgID = SysAllocString( tmp );
	if ( NULL == tmpProgID ) {
		delete [] tmp;
		return comResult;
	}

	comResult = CLSIDFromProgID( tmpProgID, &clsid );

	if ( SUCCEEDED(comResult) ){
		comResult = createCOMObject( clsid, interfaceID, object );
	}

	SysFreeString( tmpProgID );
	delete [] tmp;
#else
	_bstr_t tmpProgID;
	tmpProgID = progID.c_str();

	comResult = CLSIDFromProgID( tmpProgID, &clsid );

	if ( SUCCEEDED(comResult) ){
		comResult = createCOMObject( clsid, interfaceID, object );
	}
#endif


	return comResult;
}

HRESULT COMUtils::createCOMObject( CLSID clsid, IID interfaceID,
		                             void** object )
{
	HRESULT result = E_FAIL;

	IUnknown* pIUnknown = NULL;

	result = CoCreateInstance( clsid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown,
		                          (void**) &pIUnknown );

	if ( (SUCCEEDED(result)) && (NULL != pIUnknown) ){
		result = pIUnknown->QueryInterface( interfaceID, object );
		if ( (SUCCEEDED(result)) && (NULL != object) ){

		}

		pIUnknown->Release();

	}
	return result;

}

HRESULT COMUtils::BSTRtoString( const BSTR src, String& dest )
{
	HRESULT result = E_FAIL;
#if defined(__GNUWIN32__) || defined(VCF_CW_W32)
	String tmpString;
	SAFEARRAY* safeArray = NULL;
	result = VectorFromBstr(src, &safeArray );
	if ( SUCCEEDED(result) ){
		wchar_t *buf = NULL;
		ulong32 bstrSize = SysStringLen( src );
		result = SafeArrayAccessData(safeArray, (void**)&buf );
		if ( SUCCEEDED(result) ) {
			char* tmp = new char[bstrSize+1];
			memset( tmp, 0, (bstrSize+1)*sizeof(char) );
			WideCharToMultiByte( CP_ACP, 0, buf, bstrSize, tmp, bstrSize, NULL, NULL );
			tmpString = tmp;
			delete [] tmp;
			result = S_OK;
		}
		SafeArrayUnaccessData( safeArray );
		SafeArrayDestroy( safeArray );
	}
#else
	_bstr_t tmp( src );
	String tmpString( (VCFChar*)tmp );
#endif
	dest = tmpString;
	result = S_OK;
	return result;
}

HRESULT COMUtils::UUIDtoString( const UUID id, String& dest )
{
	HRESULT result = E_FAIL;
#if defined(VCF_CW) && defined(UNICODE)
	unsigned short *tmpid = NULL;
#else
	unsigned char *tmpid = NULL;
#endif
	RPC_STATUS rpcresult = UuidToString( const_cast<UUID*>( &id ), &tmpid );

	if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
		result = E_FAIL;
	}
	else {
		dest = "";
		dest = String( (char *)tmpid );

		RpcStringFree( &tmpid );

		result = S_OK;
	}

	return result;
}

HRESULT COMUtils::StringtoUUID( const String& src, UUID& destID )
{
	HRESULT result = E_FAIL;
#if defined(VCF_CW) && defined(UNICODE)
	//this is derived from the #else statement so if that's a bad idea, so is this! - ACH
	unsigned short *tmpid = (unsigned short*) ( src.c_str() );
#else
	//the (unsigned char*) cast below might be a bad idea ????
	unsigned char *tmpid = (unsigned char*) const_cast<char*>( src.ansi_c_str() );
#endif
	UUID tmpUUID;

	RPC_STATUS rpcresult = UuidFromString ( tmpid, &tmpUUID );

	if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
		result = E_FAIL;
	}
	else {
		destID = tmpUUID;

		//RpcStringFree( &tmpid );

		result = S_OK;
	}

	return result;
}

HRESULT COMUtils::makeDefaultFormatETC( const CLIPFORMAT& clipboardFormat, FORMATETC* formatETC )
{
	HRESULT result = E_FAIL;

	if ( NULL != formatETC ){
		formatETC->cfFormat = clipboardFormat;
		formatETC->dwAspect = DVASPECT_CONTENT;
		formatETC->lindex = -1;
		formatETC->ptd = NULL;
		formatETC->tymed = TYMED_HGLOBAL;
		result = S_OK;
	}

	return result;
}

HRESULT COMUtils::getPidlsFromHGlobal(const HGLOBAL HGlob, std::vector<String>& fileNames  )
{
	LPIDA pCIDA = NULL;
	HRESULT result = E_FAIL;

	pCIDA = LPIDA(GlobalLock(HGlob));

	fileNames.clear();

	int count = pCIDA->cidl;
	for (int i=0;i < count; i++){
		 // [0]: folder IDList, [1] to [cidl]: item IDList
		LPCITEMIDLIST pidlf = NULL;
		pidlf = (LPCITEMIDLIST)( ((UINT)pCIDA) + pCIDA->aoffset[0]);

#if defined(VCF_CW) && defined(UNICODE)
		wchar_t pathf[MAX_PATH] = L"";
#else
		char pathf[MAX_PATH] = "";
#endif
		SHGetPathFromIDList(pidlf, pathf);

		String fixedPath( pathf );

		LPCITEMIDLIST pidl = NULL;
		pidl = (LPCITEMIDLIST)( ((UINT)pCIDA) + pCIDA->aoffset[i+1]);

#if defined(VCF_CW) && defined(UNICODE)
		wchar_t path[MAX_PATH] = L"";
#else
		char path[MAX_PATH] = "";
#endif
		SHGetPathFromIDList(pidl, path);
		String pidlPath( path );
		int pos = pidlPath.find_last_of( "\\");
		if ( pos != 0 ){
			int strLength = pidlPath.length();
			strLength -= pos;
			String subStr = pidlPath.substr( pos, strLength );
			if ( (subStr != "") && (subStr.length() > 0) ){
				fixedPath += subStr;
				fileNames.push_back( fixedPath );
				result = S_OK;
			}
		}
	}
	GlobalUnlock(HGlob);

	return result;
}

HRESULT COMUtils::StringtoBSTR( const String& src, BSTR& dest )
{
	HRESULT result = E_FAIL;

/*#if defined(__GNUWIN32__) || defined(VCF_CW_W32)
    wchar_t* tmp = new wchar_t[src.size()+1];
	memset( tmp, 0 , src.size()+1 );
	AnsiString asrc = src;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, asrc.c_str(), asrc.size(), tmp, src.size() ) ) {
	    return result;*/
#if defined(__GNUWIN32__) || defined(VCF_CW_W32)
	wchar_t* tmp = new wchar_t[src.size()+1];
	memset( tmp, 0 , (src.size()+1)*sizeof(wchar_t) );
	AnsiString asrc = src;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, asrc.c_str(), asrc.size(), tmp, src.size() ) ) {
		return result;
	}

	result = SysReAllocString( &dest, tmp );

	delete [] tmp;
#else
	_bstr_t tmp( src.c_str() );
	dest = tmp.copy();
#endif


	result = S_OK;
	return result;
}

DWORD COMUtils::translateActionType( const VCF::DragActionType& action )
{
	DWORD result = 0;
	switch ( action ){
		case daNone:{
			result = DROPEFFECT_NONE;
		}
		break;

		case daCopy:{
			result = DROPEFFECT_COPY;
		}
		break;

		case daMove:{
			result = DROPEFFECT_MOVE;
		}
		break;

		case daLink:{
			result = DROPEFFECT_LINK;
		}
		break;
	};

	return result;
}

FORMATETC COMUtils::translateDataTypeToWin32( const String& dataType )
{
	FORMATETC result;
	memset( &result, 0, sizeof(result) );
	COMUtils::makeDefaultFormatETC( 0, &result );

	std::map<VCF::String,UINT>::iterator found =  COMUtils::standardWin32DataTypes.find( dataType );

	if ( found != COMUtils::standardWin32DataTypes.end() ) {
		result.cfFormat = found->second;

		switch ( result.cfFormat ) {
			case CF_METAFILEPICT : {
				result.tymed = TYMED_MFPICT;
			}
			break;

			case CF_ENHMETAFILE : {
				result.tymed = TYMED_ENHMF;
			}
			break;

			case CF_BITMAP : {
				result.tymed = TYMED_GDI;
			}
			break;
		}
	}
	else {
		if ( System::isUnicodeEnabled() ) {
			result.cfFormat = ::RegisterClipboardFormatW( dataType.c_str() );
		}
		else {
			result.cfFormat = ::RegisterClipboardFormatA( dataType.ansi_c_str() );
		}

		COMUtils::standardWin32DataTypes[dataType] = result.cfFormat;
	}

	return result;
}

String COMUtils::translateWin32ClipboardFormat( const FORMATETC& formatETC )
{
	String result;


	std::map<VCF::String,UINT>::iterator it =  COMUtils::standardWin32DataTypes.begin();
	while ( it != COMUtils::standardWin32DataTypes.end() ) {

		if ( it->second == formatETC.cfFormat ) {
			result = it->first;
			break;
		}
		it ++;
	}

	if ( !result.empty() ) {
		return result;
	}

	//otherwise do it the hard way....




	switch ( formatETC.cfFormat ){

		//apparently this is RTF format
		case 49239:{
			result =  RTF_DATA_TYPE;
		}
		break;

		case CF_TEXT:{
			result =  STRING_DATA_TYPE;
		}
		break;

		case CF_HDROP:{
			result = FILE_DATA_TYPE;
		}
		break;

		case CF_BITMAP:{
			result = "image/bmp";
		}
		break;

		case CF_DIB:{

		}
		break;
/*
		case CF_DIBV5:{

		}
		break;
*/
		case CF_DIF:{

		}
		break;

		case CF_DSPBITMAP:{

		}
		break;

		case CF_DSPENHMETAFILE:{

		}
		break;

		case CF_DSPMETAFILEPICT:{

		}
		break;

		case CF_DSPTEXT:{

		}
		break;

		case CF_ENHMETAFILE:{
			result = "image/application-x-emf";
		}
		break;

		case CF_LOCALE:{

		}
		break;

		case CF_METAFILEPICT:{
			result = "image/application-x-wmf";
		}
		break;

		case CF_OEMTEXT:{

		}
		break;

		case CF_OWNERDISPLAY:{

		}
		break;

		case CF_PALETTE:{

		}
		break;

		case CF_PENDATA:{

		}
		break;

		case CF_RIFF:{

		}
		break;

		case CF_SYLK:{

		}
		break;

		case CF_WAVE:{

		}
		break;

		case CF_TIFF:{
			result = "image/tiff";
		}
		break;

		case CF_UNICODETEXT:{

		}
		break;
	}
	return result;
}

VCF::DataObject* COMUtils_createFromHGlobal( STGMEDIUM& stg, const VCF::String& dataType )
{
	VCF::DataObject* result = NULL;

	char* rawGlobalMem = (char*)::GlobalLock( stg.hGlobal );
	ulong32 memSize = GlobalSize( stg.hGlobal );

	if ( dataType == STRING_DATA_TYPE ) {
		AnsiString tmp;
		tmp.append( rawGlobalMem, memSize );

		result = new TextDataObject(String(tmp));
	}
	else if ( dataType == COMPONENT_DATA_TYPE ) {
		String text;
		text.append( (VCF::WideChar*)rawGlobalMem, memSize );

		result = new TextDataObject(text);
	}
	else if ( (dataType == "image/bmp") || (dataType == IMAGE_DATA_TYPE) ) {
		BasicInputStream bis( rawGlobalMem, memSize );
		Image* image = GraphicsToolkit::createImage(1,1);

		bis >> dynamic_cast<VCF::Persistable*>(image);

		result = new ImageDataObject(image);
	}
	else if ( dataType == FILE_DATA_TYPE ) {


		ulong32 count = DragQueryFile((HDROP)stg.hGlobal, (UINT)-1, NULL, 0);
		if ( count > 0 ) {
			String data;
			FilePath fp;
			result = new VCF::DataObject();

			bool unicodeEnabled = System::isUnicodeEnabled();


			for ( int i=0;i<count;i++ ) {


				if ( unicodeEnabled ) {
					VCFChar tmp[MAX_PATH];
					DragQueryFileW((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}
				else {
					char tmp[MAX_PATH];
					DragQueryFileA((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}

				if ( i > 0 ) {
					data += "\n";
				}

				data += fp;
			}
			result->addSupportedDataType( dataType, new BinaryPersistable( (const unsigned char*)data.c_str(), data.size_in_bytes() ) );
		}
	}
	else {
		result = new VCF::DataObject();
		result->addSupportedDataType( dataType, new BinaryPersistable( (unsigned char*)rawGlobalMem, memSize ) );
	}

	::GlobalUnlock( stg.hGlobal );
	return result;
}

VCF::Persistable* COMUtils_createPersistableFromHGlobal( STGMEDIUM& stg, const VCF::String& dataType )
{
	VCF::Persistable* result = NULL;

	char* rawGlobalMem = (char*)::GlobalLock( stg.hGlobal );
	ulong32 memSize = GlobalSize( stg.hGlobal );

	if ( (dataType == L"image/bmp" ) || (dataType == IMAGE_DATA_TYPE) ) {
		BasicInputStream bis( rawGlobalMem, memSize );

		Image* image = GraphicsToolkit::createImage(1,1);

		result = dynamic_cast<VCF::Persistable*>(image);

		bis >> result;
	}
	else if ( dataType == FILE_DATA_TYPE ) {

		ulong32 count = DragQueryFile((HDROP)stg.hGlobal, (UINT)-1, NULL, 0);
		if ( count > 0 ) {
			String data;
			FilePath fp;
			bool unicodeEnabled = System::isUnicodeEnabled();


			for ( int i=0;i<count;i++ ) {

				if ( unicodeEnabled ) {
					VCFChar tmp[MAX_PATH];
					DragQueryFileW((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}
				else {
					char tmp[MAX_PATH];
					DragQueryFileA((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}

				if ( i > 0 ) {
					data += "\n";
				}

				data += fp;
			}

			result = new BinaryPersistable( (const unsigned char*)data.c_str(), data.size_in_bytes() );
		}
	}
	else {
		result = new BinaryPersistable( (unsigned char*)rawGlobalMem, memSize );
	}

	::GlobalUnlock( stg.hGlobal );
	return result;
}

//#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
//#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

void COMUtils_HiMetricToPixel( const SIZE& sizeInHiMetric, SIZE& sizeInPix )
{
	const int HIMETRIC_PER_INCH = 2540;

	HDC hDCScreen = GetDC(::GetDesktopWindow());


	// Pixels per logical inch along width
	int pixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	// Pixels per logical inch along height
	int pixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);

	ReleaseDC(::GetDesktopWindow(), hDCScreen);

	sizeInPix.cx = (pixelsPerInchX * sizeInHiMetric.cx + (HIMETRIC_PER_INCH/2)) / HIMETRIC_PER_INCH;
	sizeInPix.cy = (pixelsPerInchY * sizeInHiMetric.cy + (HIMETRIC_PER_INCH/2)) / HIMETRIC_PER_INCH;
}

VCF::Persistable* COMUtils::getPersistableFromOLEDataObject( const VCF::String dataType, IDataObject* oleDataObject, FORMATETC* fmtETC )
{
	VCF::Persistable* result = NULL;
	HRESULT hr = oleDataObject->QueryGetData( fmtETC );
	if ( SUCCEEDED(hr) ) {
		STGMEDIUM stg;
		memset( &stg, 0, sizeof(STGMEDIUM) );

		hr = oleDataObject->GetData( fmtETC, &stg );
		if ( SUCCEEDED(hr) ) {
			switch( stg.tymed ) {
				case TYMED_HGLOBAL : {
					result = COMUtils_createPersistableFromHGlobal( stg, dataType );
				}
				break;

				case TYMED_GDI : {
					BITMAP bmp;
					memset( &bmp, 0, sizeof(BITMAP) );
					int err = ::GetObject( stg.hBitmap, sizeof(BITMAP), &bmp );

					if ( 0 == err ) {
						//throw an exception - failed top get bitmap info
					}

					Image* image = GraphicsToolkit::createImage( bmp.bmWidth, bmp.bmHeight );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC dc = win32Image->getDC();

					HDC tmpDC = ::CreateCompatibleDC( NULL );

					HBITMAP oldBMP = (HBITMAP)::SelectObject( tmpDC, stg.hBitmap );

					err = ::BitBlt( dc, 0, 0, bmp.bmWidth, bmp.bmHeight, tmpDC, 0, 0, SRCCOPY );

					::SelectObject( tmpDC, oldBMP );
					::DeleteDC( tmpDC );

					result = dynamic_cast<Persistable*>( image );
				}
				break;

				case TYMED_MFPICT : {

					METAFILEPICT* metaFilePict = (METAFILEPICT*) GlobalLock( stg.hGlobal );
					SIZE sz = { metaFilePict->xExt, metaFilePict->yExt };
					SIZE sz2;

					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, metaFilePict->mm );

					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );


					int err = PlayMetaFile( bmpDC, metaFilePict->hMF );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( err ) {
						result = dynamic_cast<Persistable*>( image );
					}
					else {
						err = ::GetLastError();
					}


					::GlobalUnlock( stg.hGlobal );

				}
				break;

				case TYMED_ENHMF : {

					ENHMETAHEADER metaHdr;
					memset( &metaHdr, 0, sizeof(ENHMETAHEADER) );

					int err = GetEnhMetaFileHeader( stg.hEnhMetaFile, sizeof(ENHMETAHEADER), &metaHdr );

					SIZE sz = {metaHdr.rclFrame.right-metaHdr.rclFrame.left,
								metaHdr.rclFrame.bottom - metaHdr.rclFrame.top};
					SIZE sz2;
					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, MM_TEXT );
					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );

					err = PlayEnhMetaFile( bmpDC, stg.hEnhMetaFile, (RECT *)&metaHdr.rclBounds );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( FALSE != err ) {
						result = dynamic_cast<Persistable*>( image );
					}

				}
				break;

				case TYMED_ISTREAM : {

				}
				break;

				case TYMED_ISTORAGE : {

				}
				break;
			}

			ReleaseStgMedium( &stg );
		}
	}

	return result;
}

VCF::DataObject* COMUtils::getDataObjectFromOLEDataObject( const VCF::String dataType, IDataObject* oleDataObject, FORMATETC* fmtETC )
{

	VCF::DataObject* result = NULL;

	HRESULT hr = oleDataObject->QueryGetData( fmtETC );
	if ( SUCCEEDED(hr) ) {
		STGMEDIUM stg;
		memset( &stg, 0, sizeof(STGMEDIUM) );

		hr = oleDataObject->GetData( fmtETC, &stg );
		if ( SUCCEEDED(hr) ) {
			switch( stg.tymed ) {
				case TYMED_HGLOBAL : {
					result = COMUtils_createFromHGlobal( stg, dataType );
				}
				break;

				case TYMED_GDI : {
					BITMAP bmp;
					memset( &bmp, 0, sizeof(BITMAP) );
					int err = ::GetObject( stg.hBitmap, sizeof(BITMAP), &bmp );

					if ( 0 == err ) {
						//throw an exception - failed top get bitmap info
					}

					Image* image = GraphicsToolkit::createImage( bmp.bmWidth, bmp.bmHeight );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC dc = win32Image->getDC();

					HDC tmpDC = ::CreateCompatibleDC( NULL );

					HBITMAP oldBMP = (HBITMAP)::SelectObject( tmpDC, stg.hBitmap );

					err = ::BitBlt( dc, 0, 0, bmp.bmWidth, bmp.bmHeight, tmpDC, 0, 0, SRCCOPY );

					::SelectObject( tmpDC, oldBMP );
					::DeleteDC( tmpDC );

					result = new ImageDataObject( image );

					delete image;
				}
				break;

				case TYMED_MFPICT : {

					METAFILEPICT* metaFilePict = (METAFILEPICT*) GlobalLock( stg.hGlobal );
					SIZE sz = { metaFilePict->xExt, metaFilePict->yExt };
					SIZE sz2;

					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, metaFilePict->mm );

					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );


					int err = PlayMetaFile( bmpDC, metaFilePict->hMF );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( err ) {

						result = new ImageDataObject( image );
					}
					else {
						delete image;
						err = ::GetLastError();
					}



					::GlobalUnlock( stg.hGlobal );

				}
				break;

				case TYMED_ENHMF : {

					ENHMETAHEADER metaHdr;
					memset( &metaHdr, 0, sizeof(ENHMETAHEADER) );

					int err = GetEnhMetaFileHeader( stg.hEnhMetaFile, sizeof(ENHMETAHEADER), &metaHdr );

					SIZE sz = {metaHdr.rclFrame.right-metaHdr.rclFrame.left,
								metaHdr.rclFrame.bottom - metaHdr.rclFrame.top};
					SIZE sz2;
					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, MM_TEXT );
					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );

					err = PlayEnhMetaFile( bmpDC, stg.hEnhMetaFile, (RECT *)&metaHdr.rclBounds );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( FALSE != err ) {
						result = new ImageDataObject( image );
					}
					delete image;

				}
				break;

				case TYMED_ISTREAM : {

				}
				break;

				case TYMED_ISTORAGE : {

				}
				break;
			}

			ReleaseStgMedium( &stg );
		}
	}

	return result;
}


void COMUtils::registerDataTypes()
{
#if defined(VCF_CW) && defined(UNICODE)
	VCFCOM::COMUtils::standardWin32DataTypes[STRING_DATA_TYPE] = CF_TEXT;
	VCFCOM::COMUtils::standardWin32DataTypes[INTEGER_DATA_TYPE] = ::RegisterClipboardFormat( L"text/x-vcf-integer" );
	VCFCOM::COMUtils::standardWin32DataTypes[OBJECT_DATA_TYPE] = ::RegisterClipboardFormat( L"application/x-vcf-object" );
	VCFCOM::COMUtils::standardWin32DataTypes[FILE_DATA_TYPE] = CF_HDROP;
	VCFCOM::COMUtils::standardWin32DataTypes[BYTE_STREAM_DATA_TYPE] = ::RegisterClipboardFormat( L"application/octet-stream" );
	VCFCOM::COMUtils::standardWin32DataTypes[IMAGE_DATA_TYPE] = ::RegisterClipboardFormat( L"image/x-vcf-image" );
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-wmf"] = CF_METAFILEPICT;
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-emf"] = CF_ENHMETAFILE;
	VCFCOM::COMUtils::standardWin32DataTypes["image/bmp"] = CF_BITMAP;
	VCFCOM::COMUtils::standardWin32DataTypes[COMPONENT_DATA_TYPE] = ::RegisterClipboardFormat( L"text/x-vcf-vff" );
#else
	VCFCOM::COMUtils::standardWin32DataTypes[STRING_DATA_TYPE] = CF_TEXT;
	VCFCOM::COMUtils::standardWin32DataTypes[INTEGER_DATA_TYPE] = ::RegisterClipboardFormat( "text/x-vcf-integer" );
	VCFCOM::COMUtils::standardWin32DataTypes[OBJECT_DATA_TYPE] = ::RegisterClipboardFormat( "application/x-vcf-object" );
	VCFCOM::COMUtils::standardWin32DataTypes[FILE_DATA_TYPE] = CF_HDROP;
	VCFCOM::COMUtils::standardWin32DataTypes[BYTE_STREAM_DATA_TYPE] = ::RegisterClipboardFormat( "application/octet-stream" );
	VCFCOM::COMUtils::standardWin32DataTypes[IMAGE_DATA_TYPE] = ::RegisterClipboardFormat( "image/x-vcf-image" );
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-wmf"] = CF_METAFILEPICT;
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-emf"] = CF_ENHMETAFILE;
	VCFCOM::COMUtils::standardWin32DataTypes["image/bmp"] = CF_BITMAP;
	VCFCOM::COMUtils::standardWin32DataTypes[COMPONENT_DATA_TYPE] = ::RegisterClipboardFormat( "text/x-vcf-vff" );
#endif
}


/**
*CVS Log info
*$Log$
*Revision 1.3  2005/07/09 23:14:51  ddiego
*merging in changes from devmain-0-6-7 branch.
*
*Revision 1.2.4.4  2005/04/13 00:57:01  iamfraggle
*Enable Unicode in CodeWarrior
*
*Revision 1.2.4.3  2005/04/11 17:04:50  iamfraggle
*Changes allowing compilation of Win32 port under CodeWarrior
*
*Revision 1.2.4.2  2005/04/09 17:20:35  marcelloptr
*bugfix [ 1179853 ] memory fixes around memset. Documentation. DocumentManager::saveAs and DocumentManager::reload
*
*Revision 1.2.4.1  2005/02/23 03:53:31  ddiego
*fixed a bug in the com translation of file names.
*
*Revision 1.2  2004/08/07 02:49:05  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.2  2004/04/29 03:43:12  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:14  ddiego
*migration towards new directory structure
*
*Revision 1.3.4.1  2004/04/21 02:17:25  ddiego
*checking in change to FoundationKit, GraphicsKit and Application
*Kit to support unicode in Win32
*
*Revision 1.3  2003/12/18 05:16:01  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.2.2.4  2003/10/28 20:23:26  ddiego
*minor header changes
*
*Revision 1.2.2.3  2003/10/04 20:14:59  ddiego
*aaddec changes to support compiling on GCC 3.3.1, which is much more
*picky than some of the previous versions.
*
*Revision 1.2.2.2  2003/09/02 02:11:14  ddiego
*fixed some glitches in drag drop. also cleaned up the drag drop event
*classes. Began some fixes to the html browser implementation on Win32
*
*Revision 1.2.2.1  2003/08/27 20:11:49  ddiego
*adjustments to how hte DataObject class work and copy/paste
*
*Revision 1.2  2003/08/09 02:56:46  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.1.2.3  2003/06/27 03:10:59  ddiego
*got rid of some redundant junk in the Clipboard and DataObject
*classes. Instead of a rather dippy use of the DataType calss, we now simply
*use pure mime-types to identify the various "flavours" of data.
*
*Revision 1.1.2.2  2003/05/25 20:01:08  ddiego
*oops - missed some #include changes from moving the files from one directory to
*the other! This fixes that (related to the drag-drop bug fixing and clean up)
*
*Revision 1.1.2.1  2003/05/25 19:07:13  ddiego
*fixed bug [ 524878 ] onDropped not called for MLTcontrol. This
*was due to errors in the drag-drop implementation for WIn32 and is
*now fixed.
*Also cleaned up the drag-drop implementation and moved/deleted a number of
*irrelevant files for COM support. The vcf/include/com and vcf/src/COM
*directories are now gotten rid of.
*
*Revision 1.10  2003/05/17 20:37:17  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.9.2.1  2003/03/23 03:23:53  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.9  2003/02/26 04:30:45  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.8.8.3  2003/01/08 00:19:49  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.8.8.2  2002/12/27 23:04:45  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.8.8.1  2002/12/02 00:38:35  ddiego
*more fixes to get the ApplicationKit to compile under mingw. Everything now
*compiles OK at this point.
*
*Revision 1.8  2002/09/12 03:26:05  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.7.6.1  2002/06/28 17:45:30  ddiego
*migrated over lucki's changes (from his branch) for drag drop
*compiles OK, made chages to control and UIToolkit as neccessary
*still testing though.
*
*Revision 1.7  2002/05/09 03:10:44  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.6.4.2  2002/04/27 15:52:21  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.6.4.1  2002/04/08 20:55:29  zzack
*changed include style
*
*Revision 1.6  2002/01/24 01:46:49  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


