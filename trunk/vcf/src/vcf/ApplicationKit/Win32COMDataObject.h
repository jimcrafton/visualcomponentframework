#ifndef _VCF_COMDATAOBJECT_H__
#define _VCF_COMDATAOBJECT_H__
//COMDataObject.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */



#ifndef _VCF_ENUMOBJECT_H__
#include "vcf/ApplicationKit/EnumObject.h"
#endif // _VCF_ENUMOBJECT_H__




namespace VCFCOM{
/**
 * base implementation of IDataObject
 */

class DataRendering : public VCF::Object{
public:
	DataRendering();

	DataRendering( FORMATETC * formatETC, STGMEDIUM * stgMedium, IUnknown* newStorageOwner );
	virtual ~DataRendering();

	DataRendering( const DataRendering& rhs ) {
		*this = rhs;
	}

	FORMATETC       formatETC_;
    STGMEDIUM       storage_;
    IUnknown*       owner_;

	bool isEmpty() {
		return formatETC_.cfFormat == 0 &&
				formatETC_.dwAspect == 0 &&
				formatETC_.tymed == 0 &&
				storage_.tymed == 0 &&
				storage_.hGlobal == 0 &&
				owner_ == NULL;


	}
	virtual VCF::String toString();

	DataRendering& operator= (const DataRendering& rhs ) {
		memcpy( &formatETC_, &rhs.formatETC_, sizeof(formatETC_) );
		memcpy( &storage_, &rhs.storage_, sizeof(storage_) );
		owner_ = rhs.owner_;

		return *this;
	}

	bool operator == ( const DataRendering& dataRenderToCompare )const
	{
		bool result = false;

		result = ( (formatETC_.cfFormat == dataRenderToCompare.formatETC_.cfFormat) &&
		           (formatETC_.dwAspect == dataRenderToCompare.formatETC_.dwAspect) &&
				   (formatETC_.tymed == dataRenderToCompare.formatETC_.tymed) );

		return result;
	};

	bool operator == ( const FORMATETC& formatETCToCompare )const
	{
		bool result = false;

		result = ( (formatETC_.cfFormat == formatETCToCompare.cfFormat) &&
		           (formatETC_.dwAspect == formatETCToCompare.dwAspect) &&
				   (formatETC_.tymed == formatETCToCompare.tymed) );

		return result;
	};
};


/**
*This class implements IDataObject directly but also uses a member variable
*taht can point to a reference to some already existing IDataObject instance
*/
class COMDataObject : public IDataObject {
public:

   	COMDataObject( IDataObject* outerDataObject=NULL );

	virtual ~COMDataObject();

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void** ppvObj) {
		if ( iid == IID_IUnknown ) {
			*ppvObj = (IUnknown*)(this);
			((IUnknown*)(*ppvObj))->AddRef();
			return S_OK;
		}
		else if ( iid == IID_IDataObject ) {
			*ppvObj = (IDataObject*)(this);
			((IUnknown*)(*ppvObj))->AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void) {
		ref_ ++;
		return ref_;
	}

    virtual ULONG STDMETHODCALLTYPE Release(void) {
		if ( ref_ > 0 ) {
			ref_ --;
		}
		if ( 0 == ref_ ) {
			delete this;
			return 0;
		}

		return ref_;
	}


	STDMETHOD(GetData)( FORMATETC * formatETC, STGMEDIUM * stgMedium );

	STDMETHOD(GetDataHere)( FORMATETC * formatETC, STGMEDIUM * stgMedium );

	STDMETHOD(QueryGetData)( FORMATETC * formatETC );

	STDMETHOD(GetCanonicalFormatEtc)( FORMATETC * formatETCIn, FORMATETC * formatETCOut );

	STDMETHOD(SetData)( FORMATETC * formatETC, STGMEDIUM * stgMedium, BOOL releaseData );

	STDMETHOD(EnumFormatEtc)( DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc );

	STDMETHOD(DAdvise)( FORMATETC * formatETC, DWORD advf, IAdviseSink * pAdvSink,  DWORD * pdwConnection );

	STDMETHOD(DUnadvise)( DWORD dwConnection );

	STDMETHOD(EnumDAdvise)( IEnumSTATDATA ** ppenumAdvise );



	/**
     * Adds a new data type that the dataobject supports.
     */
	void setDataObject( VCF::DataObject* data );

	VCF::DataObject* getDataObject() {
		return dataObj_;
	}

    /**
     * is the data type passed in supported by the data object ?
     */
    virtual bool isTypeSupported(const VCF::String& dataType );

private:
	DataRendering findDataRenderingForType( FORMATETC* formatETC );

	UINT translateFrameworkFormat( const VCF::String& dataType );
	FORMATETC translateFrameworkFormatToFormatETC( const VCF::String& dataType );
	VCF::String translateClipboardFmt( const UINT& fmtType );

	std::vector<DataRendering> renderings_;
	VCF::DataObject* dataObj_;

	IDataObject* outerDataObject_;
	ULONG ref_;
};




class EnumFormatETC : public IEnumFORMATETC, public EnumObject<FORMATETC> {
public:

	EnumFormatETC():
		EnumObject<FORMATETC>(){};

	EnumFormatETC( const EnumFormatETC& enumObj ):
		EnumObject<FORMATETC>( enumObj ){};

	virtual ~EnumFormatETC(){};


	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void** ppvObj) {
		if ( iid == IID_IUnknown ) {
			*ppvObj = (IUnknown*)(this);
			((IUnknown*)(*ppvObj))->AddRef();
			return S_OK;
		}
		else if ( iid == IID_IEnumFORMATETC ) {
			*ppvObj = (IEnumFORMATETC*)(this);
			((IUnknown*)(*ppvObj))->AddRef();
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void) {
		ref_ ++;
		return ref_;
	}

    virtual ULONG STDMETHODCALLTYPE Release(void) {
		if ( ref_ > 0 ) {
			ref_ --;
		}
		if ( 0 == ref_ ) {
			delete this;
			return 0;
		}

		return ref_;
	}


	STDMETHOD(Next)( ULONG elementsRequested, FORMATETC *elementList, ULONG *elementsFetched ){
		return EnumObject<FORMATETC>::_Next( elementsRequested, elementList, elementsFetched );
	};

	STDMETHOD(Skip)( ULONG elementsToSkip ){
		return EnumObject<FORMATETC>::_Skip( elementsToSkip );
	};

	STDMETHOD(Reset)(void){
		return EnumObject<FORMATETC>::_Reset();
	};

	/**
	Creates another enumerator that contains the same enumeration state as the
	current one. Using this function, a client can record a particular point in
	the enumeration sequence, and then return to that point at a later time.
	The new enumerator supports the same interface as the original one.
	*/
	STDMETHOD(Clone)( IEnumFORMATETC** enumFmtEtc ){
		EnumObject<FORMATETC>* enumFmt = NULL;

		enumFmt = new EnumFormatETC( *this );
		*enumFmtEtc = (IEnumFORMATETC*)enumFmt;

		return NOERROR;//result;//E_NOTIMPL;
	};

protected:
	ULONG ref_;

};


};


#endif // _VCF_COMDATAOBJECT_H__

/**
$Id$
*/
