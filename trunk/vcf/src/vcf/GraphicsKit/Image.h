#ifndef _VCF_IMAGE_H__
#define _VCF_IMAGE_H__
//Image.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */



namespace VCF{


class ImageBits;

class GraphicsContext;


/**
*interface Image
*/
class GRAPHICSKIT_API Image {
public:

	/**
	This indicates the type of image. An image may be either
	Color (this is the default) or Grayscale. Color images
	have four channels, grayscale images have 1. The precise
	value of the enum is the number of channels the image
	has. Thus itGrayscale is 1 for one channel, and itColor
	is 4 for 4 channels.
	*/
	enum ImageType{
		/**
		Indicates a Color image with four channels
		*/
		itColor = 0x4,

		/**
		Indicates a Grayscale image with one channel
		*/
		itGrayscale = 1
	};

	/**
	This indicates the size of each channel
	*/
	enum ImageChannelSize {
		ics8Bit = 0x08,
		ics16Bit = 0x10,
		ics32Bit = 0x20
	};

	enum ImageChannelType {
		ictInteger = 0,
		ictFloatingPoint = 1
	};

	enum PixelLayoutOrder {
		ploRGBA,
		ploBGRA,
		ploARGB,
		ploABGR
	};


	typedef unsigned long ImageDescriptor;

	virtual ~Image(){};

	/**
	returns the type of image that this Image instance represents.
	The integer value also indicates the number of color channels
	the Image has. Currently there are only 2 types, full color
	4 channel RGBA images, and 1 channel grayscale images.
	@return ImageType the value that represent the images type. The
	values have the follwing meanings:
	<ul>
		<li>Image::itColor - indicate a full color image with red, green, blue, and alpha
		channels present. The integer value of this is 4 and can be used in operations
		to determine the total data size of the image, for example.</li>
		<li>Image::itGrayscale - indicates a grayscale image with a single channel. The
		numerical value of this is 1.</li>
	</ul>

	*/
	virtual ImageType getType() const = 0;

	/**
	returns the number of bits each channel value represents. For example, by default, on
	Win32 systems, an Image is a full color RGBA image, with each value of a channel
	taking 8 bits, thus a single of pixel of this type of image takes up 32 bits - 4 channels
	with each channel component 8 bits in size.
	@return the channel's component size. Can be one of the following values:
	<ul>
		<li>Image::ics8Bit - each channel component is 8 bits in sizem, thus the numerical
		value of this enum is 8.

		<li>Image::ics16Bit - each channel component is 8 bits in sizem, thus the numerical
		value of this enum is 16.

		<li>Image::ics32Bit - each channel component is 8 bits in sizem, thus the numerical
		value of this enum is 32.
	</ul>
	The last two types (Image::ics16Bit and Image::ics32Bit) are typically used for high end imaging.
	*/
	virtual ImageChannelSize getChannelSize() const = 0;

	/**
	returns whether the values for a channel are integer based or floating point based.
	@return ImageChannelType the image channel's value type. Can be one of
	<ul>
		<li> Image::ictInteger - the value of a channel is integer based. It's min and max values
		can be expressed by ImageBits::Traits::minVal() and ImageBits::Traits::maxVal() respectively.
		Typically this is a value between 0 and 2<sup>getChannelSize()</sup> (inclusive).
		<li> Image::ictFloatingPoint - the value of a channel is integer based. It's min and max values
		can be expressed by ImageBits::Traits::minVal() and ImageBits::Traits::maxVal() respectively.
		Typically this is a value in the range of 0.0 and 1.0 inclusive.
	</ul>
	*/
	virtual ImageChannelType getChannelType() const = 0;

	/**
	returns the pixel layout order. This explains how the individual color components
	of each of the color channels are laid out.
	@return PixelLayoutOrder the binary layout order of a single pixel value. Can be one of
	<ul>
		<li> Image::ploRGBA - indicates the Red value is in the MSB position, followed
		by Green, Blue and finally Alpha values. In code it might
		look like this for an Image with integer based 8 bit color channels
		<pre>
			ulong32 pixelColor = (redVal &lt;&lt; 24) | (greenVal &lt;&lt; 16) | (blueVal &lt;&lt; 8) | (alphaVal);
		</pre>
		Extracting the values from a single pixel color would be:
		<pre>
			redVal	= (pixelColor &amp; 0xFF000000) &gt;&gt; 24;
			greenVal = (pixelColor &amp; 0x00FF0000) &gt;&gt; 16;
			blueVal = (pixelColor &amp; 0x0000FF00) &gt;&gt; 8;
			alphaVal = (pixelColor &amp; 0x000000FF);
		</pre>
		</li>

		<li> Image::ploBGRA - indicates the Blue value is in the MSB position, followed
		by Green, Red and finally Alpha values. In code it might look like this for an
		Image with integer based 8 bit color channels
		<pre>
			ulong32 pixelColor = (blueVal &lt;&lt; 24) | (greenVal &lt;&lt; 16) | (redVal &lt;&lt; 8) | (alphaVal);
		</pre>
		Extracting the values from a single pixel color would be:
		<pre>
			blueVal	= (pixelColor &amp; 0xFF000000) &gt;&gt; 24;
			greenVal = (pixelColor &amp; 0x00FF0000) &gt;&gt; 16;
			redVal = (pixelColor &amp; 0x0000FF00) &gt;&gt; 8;
			alphaVal = (pixelColor &amp; 0x000000FF);
		</pre>
		</li>

		<li> Image::ploARGB - indicates the Alpha value is in the MSB position, followed
		by Red, Green and finally Blue values. In code it might look like this for an
		Image with integer based 8 bit color channels
		<pre>
			ulong32 pixelColor = (alphaVal &lt;&lt; 24) | (redVal &lt;&lt; 16) | (greenVal &lt;&lt; 8) | (blueVal);
		</pre>
		Extracting the values from a single pixel color would be:
		<pre>
			alphaVal	= (pixelColor &amp; 0xFF000000) &gt;&gt; 24;
			redVal = (pixelColor &amp; 0x00FF0000) &gt;&gt; 16;
			greenVal = (pixelColor &amp; 0x0000FF00) &gt;&gt; 8;
			blueVal = (pixelColor &amp; 0x000000FF);
		</pre>
		This is typically the way it would be stored on a linux based port of VCF.
		</li>


		<li> Image::ploABGR - indicates the Alpha value is in the MSB position, followed
		by Blue, Green and finally Red values. In code it might look like this for an
		Image with integer based 8 bit color channels
		<pre>
			ulong32 pixelColor = (alphaVal &lt;&lt; 24) | (blueVal &lt;&lt; 16) | (greenVal &lt;&lt; 8) | (redVal);
		</pre>
		Extracting the values from a single pixel color would be:
		<pre>
			alphaVal	= (pixelColor &amp; 0xFF000000) &gt;&gt; 24;
			blueVal = (pixelColor &amp; 0x00FF0000) &gt;&gt; 16;
			greenVal = (pixelColor &amp; 0x0000FF00) &gt;&gt; 8;
			redVal = (pixelColor &amp; 0x000000FF);
		</pre>
		This is typically the way it would be stored on a Win32 based port of VCF.
		</li>

		</ul>
	*/
	virtual PixelLayoutOrder getPixelLayoutOrder() const = 0;

    virtual void setSize( const unsigned long & width, const unsigned long & height )=0;

    virtual unsigned long getWidth()=0;

    virtual unsigned long getHeight()=0;

    virtual void addImageSizeChangedHandler( EventHandler* handler ) = 0;

    virtual void removeImageSizeChangedHandler( EventHandler* handler ) = 0;

	virtual ImageBits* getImageBits() = 0;

	/**
	Call this method before calling getImageContext() to "lock" the
	images pixels and ensure that the GraphicsContext returns is properly
	sycnhed with the image's data.
	*/
	virtual void beginDrawing() = 0;

	virtual void finishedDrawing() = 0;

	/**
	<p>
	This retreives a graphics context for drawing on. Any drawing performed
	on the graphics context will be reflected in the internal pixel data of the
	image. On some platforms this may be "instantaneous" because the pixel
	data of the image is directly linked to the GraphicsContext (i.e. Win32),
	while on other platforms the drawing on the GraphicsContext needs to
	be "flushed" back to the images pixels. Because of this, you <b>must</b>
	call beginDrawing() <i>before</i> calling getImageContext(), and call
	finishedDrawing() when you're done with the GraphicsContext. Concrete
	implemententations of this class will transfer the image's contents to
	the GraphicsContext for beginDrawing(), finishedDrawing() will update
	the image's data due to any changes in the GraphicsContext. An example:
	<pre>
	Image* image = getImage(); //get an image from somewhere
	image->beginDrawing();

	GraphicsContext* gc = image->getImageContext();
	gc->rectangle( 20, 20, 400, 60 );
	gc->strokePath();

	image->finishedDrawing();

	</pre>

	*/
	virtual GraphicsContext* getImageContext() = 0;

	/**
	*returns the color that is used to blend with the contents of
	*a GraphicsContext when the Image is drawn. Only used when the
	*Image is set to Transparent
	*/
	virtual Color* getTransparencyColor() = 0;

	virtual void setTransparencyColor( Color* transparencyColor ) = 0;

	/**
	*Indicates whether or not the Image is using a transparent
	*color.
	*@return bool if this is true then the Image is transparent
	*and the contents of the underlying GraphicsContext will show through
	*wherever a pixel in the image is found that is the transparency color
	*/
	virtual bool isTransparent() = 0;

	virtual void setIsTransparent( const bool& transparent ) = 0;
};

};


/**
*CVS Log info
*$Log$
*Revision 1.2  2004/08/07 02:49:17  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.2  2004/04/29 04:10:27  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 03:40:31  ddiego
*migration towards new directory structure
*
*Revision 1.12.4.1  2004/04/26 21:58:39  marcelloptr
*changes for dir reorganization: _VCF_MACRO_H__
*
*Revision 1.12  2003/12/18 05:15:58  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.11.2.1  2003/10/28 04:06:11  ddiego
*updated the GraphicsContext and ContextPeer classes to support
*slider control drawing. adjusted the Slider control accordingly.
*Also changed some of the GraphicsKit headers to conform to the
*current header style.
*
*Revision 1.11  2003/08/09 02:56:43  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.10.2.2  2003/06/16 03:09:39  ddiego
*beginning to add support for AGG into the VCF GraphicsKit
*added some missing files
*added some changes to the new version of xmake
*
*Revision 1.10.2.1  2003/05/25 19:07:10  ddiego
*fixed bug [ 524878 ] onDropped not called for MLTcontrol. This
*was due to errors in the drag-drop implementation for WIn32 and is
*now fixed.
*Also cleaned up the drag-drop implementation and moved/deleted a number of
*irrelevant files for COM support. The vcf/include/com and vcf/src/COM
*directories are now gotten rid of.
*
*Revision 1.10  2003/05/18 23:09:37  ddiego
*fixes some mistakes in the docs/Makefile and adds some extra documentation.
*
*Revision 1.9  2003/05/17 20:37:10  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.8.10.2  2003/04/07 03:39:30  ddiego
*did some documentation work, and got everything to compile cleanly with some
*of the new additions, particularly the chnages inteh Image/ImageBits classes.
*
*Revision 1.8.10.1  2003/03/23 03:23:48  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.8  2002/09/12 03:26:04  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.7.12.1  2002/08/06 02:57:35  ddiego
*added base X11 files for GraphicsKit and made sure that the GraphicsKit compiles
*under linux (GCC). There is now a new dir under build/xmake called GraphicsKit
*where the xmake build script lives. This checkin also includes the base X11
*include (as part of GraphicsKitPrivate.h), as well as linking to the X11 libs
*
*Revision 1.7  2002/01/24 01:46:48  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


#endif // _VCF_IMAGE_H__


