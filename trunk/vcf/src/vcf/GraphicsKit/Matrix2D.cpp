//Matrix2D.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/GraphicsKit/GraphicsKit.h"

using namespace VCF;

Matrix2D::Matrix2D()
{
	identity();
}

Matrix2D::Matrix2D( const Matrix2D& matrix ):
    Object(matrix)
{
	memcpy( matrix_, matrix.matrix_, 9 * sizeof(double) );
}

Matrix2D::~Matrix2D()
{

}

void Matrix2D::transpose( Matrix2D* dest )
{
	for (int i=0;i<3;i++){
		for (int j=0;j<3;j++){
			dest->matrix_[i][j] = matrix_[j][i];
		}
	}
}

void Matrix2D::reflect( const bool& reflectX, const bool& reflectY )
{
	identity();
	if ( true == reflectX ){
		matrix_[1][1] = -1;
	}
	if ( true == reflectY ){
		matrix_[0][0] = -1;
	}
}

void Matrix2D::rotate( const double& theta )
{
	identity();
	matrix_[0][0] = cos( Math::degreesToRadians(theta) );
	matrix_[0][1] = sin( Math::degreesToRadians(theta) );
	matrix_[1][0] = -matrix_[0][1];
	matrix_[1][1] = matrix_[0][0];
}

void Matrix2D::shear( const double& shearX, const double& shearY )
{
	/**
	*the shear values come into us as degrees - we need to converto
	*radians
	*/
	identity();
	matrix_[1][0] = Math::degreesToRadians( shearX );
	matrix_[0][1] = Math::degreesToRadians( shearY );
}

void Matrix2D::scale( const double& scaleX, const double& scaleY )
{
	identity();
	matrix_[0][0] = scaleX;
	matrix_[1][1] = scaleY;
}

void Matrix2D::identity()
{
	for (int i=0;i<3;i++){
		for (int j=0;j<3;j++){
			if ( i == j ){
				matrix_[i][j] = 1.0;
			}
			else {
				matrix_[i][j] = 0.0;
			}
		}
	}
}

Matrix2D* Matrix2D::multiply( Matrix2D* m1, Matrix2D* m2 )
{
	if ( (NULL != m1) && (NULL != m2) ) {
		matrix_[0][0] = m1->matrix_[0][0] * m2->matrix_[0][0] + m1->matrix_[0][1] * m2->matrix_[1][0];
		matrix_[0][1] = m1->matrix_[0][0] * m2->matrix_[0][1] + m1->matrix_[0][1] * m2->matrix_[1][1];
		matrix_[0][2] = 0.0;

		matrix_[1][0] = m1->matrix_[1][0] * m2->matrix_[0][0] + m1->matrix_[1][1] * m2->matrix_[1][0];
		matrix_[1][1] = m1->matrix_[1][0] * m2->matrix_[0][1] + m1->matrix_[1][1] * m2->matrix_[1][1];
		matrix_[1][2] = 0.0;

		matrix_[2][0] = (m1->matrix_[2][0] * m2->matrix_[0][0]) + (m1->matrix_[2][1] * m2->matrix_[1][0]) + m2->matrix_[2][0];
		matrix_[2][1] = (m1->matrix_[2][0] * m2->matrix_[0][1]) + (m1->matrix_[2][1] * m2->matrix_[1][1]) + m2->matrix_[2][1];
		matrix_[2][2] = 1.0;
		return this;
	}
	else {
		return NULL;
	}
}

void Matrix2D::translate( const double& transX, const double& transY )
{
	identity();
	matrix_[2][0] = transX;
	matrix_[2][1] = transY;
}

void Matrix2D::invert()
{
	//based on Maxim Shemanarev AGG matrix code ! Thanks !
	double determinant  = 1.0 / (matrix_[0][0] * matrix_[1][1] - matrix_[0][1] * matrix_[1][0]);

	double t0 =  matrix_[1][1] * determinant;
	matrix_[1][1] =  matrix_[0][0] * determinant;
	matrix_[0][1] = -matrix_[0][1] * determinant;
	matrix_[1][0] = -matrix_[1][0] * determinant;

	double t4 = -matrix_[2][0] * t0 - matrix_[2][1] * matrix_[1][0];
	matrix_[2][1] = -matrix_[2][0] * matrix_[0][1] - matrix_[2][1] * matrix_[1][1];

	matrix_[0][0] = t0;
	matrix_[2][0] = t4;
}

Point* Matrix2D::apply( Point* point )
{
	return NULL;
}

bool Matrix2D::isEqual( Object* object )const
{
	Matrix2D* m = dynamic_cast<Matrix2D*>(object);
	if ( NULL != m ){
		for ( int i=0;i<3;i++){
			for (int j=0;j<3;j++){
				if ( matrix_[i][j] != m->matrix_[i][j] ){
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

void Matrix2D::copy( Object* source )
{
	Matrix2D* m = dynamic_cast<Matrix2D*>( source );
	memcpy( matrix_, m->matrix_, 9 * sizeof(double) );
	/**
	slow way
	if ( NULL != m ){
		for ( int i=0;i<3;i++){
			for (int j=0;j<3;j++){
				matrix_[i][j] = m->matrix_[i][j];
			}
		}
	}
	*/
}

Matrix2D& Matrix2D::operator=( const Matrix2D& matrix )
{
	copy( (Object*)&matrix );
	return *this;
}

bool Matrix2D::operator == ( const Matrix2D& matrix )const
{
	return isEqual( (Object*)&matrix );
}

double Matrix2D::operator[]( MatrixElementIndex index ) const
{
	double result = 0.0;
	switch ( index ){
		case Matrix2D::mei00 : {
			result = matrix_[0][0];
		}
		break;

		case Matrix2D::mei01 : {
			result = matrix_[0][1];
		}
		break;

		case Matrix2D::mei02 : {
			result = matrix_[0][2];
		}
		break;

		case Matrix2D::mei10 : {
			result = matrix_[1][0];
		}
		break;

		case Matrix2D::mei11 : {
			result = matrix_[1][1];
		}
		break;

		case Matrix2D::mei12 : {
			result = matrix_[1][2];
		}
		break;

		case Matrix2D::mei20 : {
			result = matrix_[2][0];
		}
		break;

		case Matrix2D::mei21 : {
			result = matrix_[2][1];
		}
		break;

		case Matrix2D::mei22 : {
			result = matrix_[2][2];
		}
		break;
	}

	return result;
}

double& Matrix2D::operator[]( MatrixElementIndex index )
{
	if ( index > Matrix2D::mei22 ) {
		throw OutOfBoundsException( MAKE_ERROR_MSG_2("Index specified is out of bound for Matrix array") );
	}
	return matrix_[index/3][index%3];
}


/**
$Id$
*/
