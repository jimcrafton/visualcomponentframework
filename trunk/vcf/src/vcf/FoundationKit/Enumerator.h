#ifndef _VCF_ENUMERATOR_H__
#define _VCF_ENUMERATOR_H__
//Enumerator.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */


namespace VCF{
/**
\class Enumerator Enumerator.h "vcf/FoundationKit/Dictionary.h"
 This is a template class that provides an interface for
 iterating through a collection, and provides a standard set of methods.
 Either multiply inherited by classes that want to public expose a single set of children,
 or as  a returned object for safe enumeration of data collections.
 */

template <class COLLECTION_TYPE> class Enumerator{
protected:
	bool supportsEditing_;  /* moved to begin for MINGW */
public:
	Enumerator(){
		supportsEditing_ = false;
	};

	virtual ~Enumerator(){};

	/**
	indicates whether there are any more children to enumerate
	through
	@param bool specifies whether the enumeration should be forwards
	or backwards. The default value is true for enumerating forwards.
	@return bool true if there are any elements left to enumerate,
	otherwise returns false.
	*/
	virtual bool hasMoreElements(const bool& backward=false)=0;

	/**
	returns the next element in the enumeration. Moves the internal
	iterator forward
	@return COLLECTION_TYPE returns a COLLECTION_TYPE value of whatever type
	was specified in the template argument to the Enumerator
	*/
	virtual COLLECTION_TYPE nextElement()=0;

	/**
	returns the previous element in the enumeration. Moves the internal
	iterator backward
	@return COLLECTION_TYPE returns a COLLECTION_TYPE value of whatever type
	was specified in the template argument to the Enumerator
	*/
	virtual COLLECTION_TYPE prevElement()=0;

	/**
	Resets the Enumerator's internal iterator back to the beginning (or end,
	if backward is true).
	@param bool specifies which direction to reset to
	*/
	virtual void reset(const bool& backward=false)=0;

	/**
	Currently not used. Will allow editing of the Enumerator in the
	future, in which case this will return whether or not this instance
	of the enumerator allows adding or removing of elements
	@return bool true if the enumerator allows editing, otherwise false.
	*/
	bool supportsEditing(){
		return supportsEditing_;
	};
};



/**
\class EnumeratorContainer Enumerator.h "vcf/FoundationKit/Enumerator.h"

EnumeratorContainer is based on some COLLECTION class that represents a collection
class of some sort, i.e. std::vector<>, std::list, et al.

The internal implementation counts on the collection having a common interface to
STL's collection classes.

The collection must support forward and reverse iterators

The COLLECTION type specifies the full collection associated with
the enumerator. 

For example, an enumerator container of Object* using
a std::vector as it's collection type would look like this:
\code
*	EnumeratorContainer<std::vector<Object*>,Object*> objectVecEnumerator;
\endcode
The COLLECTION_TYPE represents the type of an individual element in the enumerator.
Passing in a reference to the collection variable in the contstructor will automatically
set up the internal iterator, nothing further need be done. Alternatively, you may
call the initContainer() method with a reference to the collection
*/
template <class COLLECTION, class COLLECTION_TYPE> class EnumeratorContainer : public Enumerator<COLLECTION_TYPE>{
public:

	#if defined(VCF_MINGW) || defined(VCF_GCC)
	using Enumerator<COLLECTION_TYPE>::supportsEditing_; /* mingw follows the standart */
	#endif

	EnumeratorContainer( COLLECTION &container ): container_(&container) {
		reset();
		supportsEditing_ = true;
	};

	EnumeratorContainer(): /*backwards_(false),*/ container_(NULL){
		supportsEditing_ = true;
	};

	virtual ~EnumeratorContainer(){};

	/**
	Initializes the container with a reference to an
	existing collection
	*/
	virtual void initContainer( COLLECTION &container ){
		container_ = &container;
		reset();
	};

	virtual bool hasMoreElements(const bool& backward=false){
		bool result = false;
		if ( true == backward ){
			result = containerIterator_ != container_->begin();
		}
		else{
			result = containerIterator_ != container_->end();
		}
		return result;
	};

	virtual COLLECTION_TYPE nextElement(){
		if ( containerIterator_ != container_->end() ){
			return *containerIterator_++;
		}
		else {
			return *container_->end();
		}
	};

	virtual COLLECTION_TYPE prevElement(){
		if (containerIterator_ != container_->begin() ){
				return *--containerIterator_;
		}
		else {
			return *container_->begin();
		}
	};

	virtual void reset(const bool& backward=false){
		if ( backward ) {
			containerIterator_ = container_->end();
		}
		else {
			containerIterator_ = container_->begin();
		}
	};

	/**
	returns a pointer to the Enumerator interface of this
	container. Automatically resets the collection before
	returning the pointer.
	@return Enumerator<COLLECTION_TYPE> a pointer to the
	collection as an Enumerator interface.
	*/
	virtual Enumerator<COLLECTION_TYPE>* getEnumerator(){
		reset();
		return (Enumerator<COLLECTION_TYPE>*)this;
	};
private:
	typename COLLECTION::iterator containerIterator_;
	//typename COLLECTION::reverse_iterator reverseContainerIterator_;
	COLLECTION* container_;
	//bool backwards_;
};

/**
\class EnumeratorMapContainer Enumerator.h "vcf/FoundationKit/Enumerator.h"
EnumeratorMapContainer is based on some COLLECTION class that represents
an  associative collection of some sort, i.e. std::map<>

The internal implementation counts on the collection having a common interface to
STL's collection classes.

The collection must support forward and reverse iterators

The COLLECTION type specifies the full collection associated with
the enumerator. 

For example, an enumerator container of Object* using
a std::map as it's collection type would look like this:
\code
	EnumeratorMapContainer<std::map<String,Object*>,Object*> objectMapEnumerator;
\endcode
The COLLECTION_TYPE represents the type of an individual element in the enumerator.
In EnumeratorMapContainer the enumeration will only return the value of the maps
pair, not the key.
*/
template <class COLLECTION, class COLLECTION_TYPE> class EnumeratorMapContainer : public Enumerator<COLLECTION_TYPE>{
public:
	EnumeratorMapContainer( COLLECTION &container ): container_(&container){
		reset();
	};

	EnumeratorMapContainer(): container_(NULL){};

	virtual ~EnumeratorMapContainer(){};

	virtual void initContainer( COLLECTION &container ){
		container_ = &container;
		reset();
	};

	virtual Enumerator<COLLECTION_TYPE>* getEnumerator(){
		reset();
		return (Enumerator<COLLECTION_TYPE>*)this;
	};

	virtual bool hasMoreElements(const bool& backward=false){
		bool result = false;

		if ( true == backward ){
			result = containerIterator_ != container_->begin();
		}
		else{
			result = containerIterator_ != container_->end();
		}

		return result;
	};

	virtual COLLECTION_TYPE nextElement(){
		if (containerIterator_ != container_->end() ){
			COLLECTION_TYPE result = containerIterator_->second;
			containerIterator_ ++;
			return result;
		}
		else {
			return COLLECTION_TYPE();
		}
	};

	virtual COLLECTION_TYPE prevElement(){
		if (containerIterator_ != container_->begin() ){
			containerIterator_ --;
			return containerIterator_->second;
		}
		else {
			return container_->begin()->second;
		}
	};

	virtual void reset(const bool& backward=false){

		if ( backward ){
			containerIterator_ = container_->end();
		}
		else {
			containerIterator_ = container_->begin();
		}
	};

private:
	typename COLLECTION::iterator containerIterator_;
	COLLECTION* container_;
};


};


#endif // _VCF_ENUMERATOR_H__

/**
$Id$
*/
