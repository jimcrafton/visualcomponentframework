<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:color("21","333333","Custom #3","0") -->
  <!-- $MVD$:color("22","ee4444","Custom #4","0") -->
  <!-- $MVD$:color("23","ffcc99","Custom #5","0") -->
  <!-- $MVD$:color("24","ff6600","Custom #6","0") -->
  <!-- $MVD$:color("25","eeeeee","Custom #7","0") -->
  <!-- $MVD$:color("26","204060","Custom #8","0") -->
  <!-- $MVD$:color("27","80e0","Custom #9","0") -->
  <!-- $MVD$:color("28","206080","Custom #10","0") -->
  <!-- $MVD$:color("29","802000","Custom #11","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>VCF::Object - the base class</TITLE>
  <META NAME="generator" CONTENT="Microsoft FrontPage 4.0">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK
  REL="StyleSheet" HREF="default.css"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <P>
   <IMG SRC="vcflogo.gif" WIDTH="230" HEIGHT="172" VSPACE="0" HSPACE="0" BORDER="0"></P>
  <H1>
   VCF::Object - The base class</H1>
  <P>
   The VCF is, by and large, a single rooted object hierarchy, the base 
   class of which is <code>VCF::Object</code>. This class provides several common 
   functions for us, as well as providing several method that can be 
   overridden by derived classes.</P>
  <P>
   The core methods are the following:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="21%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="79%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClassName()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a String that identifies the class name of the object.</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClass()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a pointer to a Class object that identifies the Object's 
       runtime class information.</TD>
    </TR>
   </TABLE>
  <P>
   The core methods that can be overridden are:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="17%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="83%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       hash()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns an unsigned long that represents the object's hash value. Can 
       be overridden to provide any number of hashing algorithms that return 
       some valid hash number</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       toString()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns a String that represents the object. The default behavior 
       simply returns the pointer for the object's instance. Other 
       implementations may return state information, such as <code>VCF::Rect</code>, 
       which returns the bounds of the rectangle. Used primarily as a 
       debugging tool.</TD>
    </TR>
   </TABLE>
  <P>
   In addition, Object also supports reference counting for those who need 
   this kind of support. There are several places in the ApplicationKit 
   that will need to make use of this fairly soon.&nbsp;</P>
  <P>
   Destroying the memory can now happen in two ways:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    The first is the equivalent of the operator <code> delete()</code> call. This 
    involves calling the objects <code> free()</code> method, which will call the 
    virtual <code> destroy()</code> method before calling operator delete() on itself.</P>
   <LI CLASS="mvd-P">
   <P>
    The second way an object can be destroyed is if it's refcount drops 
    to 0, at which point the object's <code> free()</code> method will be invoked. 
    Calling the object's <code> release()</code> method decrements the reference count 
    on the object. <code> destroy() </code> is a virtual method, where 
    common shared cleanup may take place, again due to the restrictions 
    of C++, virtual methods are not allowed in destructors, but we get 
    around this with the free()/destroy() pattern.</P>
   </UL>
  <P>
   Semantics for the usage of the <CODE>addRef()/release()</CODE> method 
   usage are as follows:</P>
  <P>
   An object's reference count indicates "ownership " of the object. In other words, the "owner" of the
   object is responsible for releasing it's hold on the object, thus decrementing the objects
   reference count, which, when reduced to 0, causes the object to be deleted. This is also known as
   a <b><i> strong</i></b> reference to an object, as opposed to a <b><i> weak</i></b> reference where the "owner" doesn't
   claim any responsibility over the object.&nbsp;</P>
  <P>
   An example might look like this:</P>
  <pre>class Bar : public Object {
public:
    ...//declarations    
};


class FooBar : public Object {
public:
    ...//rest of class declaration

    void setBarObj( Bar* bar ) {
        m_barObj = bar;
    }
    
    Bar* getBarObj() {
        return m_barObj;
    }
protected:
    Bar* m_barObj;  
};</pre>
  <P>In our <code> FooBar</code> class we have a member <code> m_barObj</code> which is a pointer to some
  instance of class <code>Bar</code>.&nbsp; In this class we have a strong reference to the
  Bar instance, and want to make sure that whatever else happens to the
  instance, it stays valid until we no longer care about it. So lets modify our <code>setBarObj()</code>
  method to reflect this:</P>
  <pre><b>void</b> setBarObj( Bar* bar ) {
    if ( <b>NULL</b> != m_barObj ) {
        m_barObj-&gt;release(); <i>//release() our hold on the object - we don't care about it anymore</i>
    }
    m_barObj = bar;
    if ( <b>NULL</b> != m_barObj ) {
        m_barObj-&gt;addRef();  <i>//addref() to prevent the object from being deleted should someone else release() it</i>
    }
}</pre>
  <p>So in the <code> setBarObj()</code> method we <code> release()</code> our old instance that we no
  longer care about, assign the new value to our member variable, and if it is a
  valid instance (non null), then we take &quot;ownership&quot; of it by calling
  <code>
  addRef()</code> on the instance.</p>
  <P>
   <SPAN STYLE="font-style : italic;font-weight : bold;font-size : 12.0pt;">Note</SPAN><SPAN STYLE="font-size : 12.0pt;">:</SPAN> 
   that this whole scheme is aimed at heap based objects. Many objects 
   that are created on the stack do not need this.</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;
 </BODY>
</HTML>