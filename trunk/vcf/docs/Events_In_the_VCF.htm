<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:color("21","333333","Custom #3","0") -->
  <!-- $MVD$:color("22","ee4444","Custom #4","0") -->
  <!-- $MVD$:color("23","ffcc99","Custom #5","0") -->
  <!-- $MVD$:color("24","ff6600","Custom #6","0") -->
  <!-- $MVD$:color("25","eeeeee","Custom #7","0") -->
  <!-- $MVD$:color("26","204060","Custom #8","0") -->
  <!-- $MVD$:color("27","80e0","Custom #9","0") -->
  <!-- $MVD$:color("28","206080","Custom #10","0") -->
  <!-- $MVD$:color("29","802000","Custom #11","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>Events In the VCF</TITLE>
  <META NAME="generator" CONTENT="Microsoft FrontPage 4.0">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK
  REL="StyleSheet" HREF="default.css">
 <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <P>
   <IMG SRC="vcflogo.gif" WIDTH="230" HEIGHT="172" VSPACE="0" HSPACE="0" BORDER="0"></P>
  <H1>
   Events In the VCF</H1>
  <P>
   Events happen to us every day. When we open a door, when we go to 
   work, when we fall asleep. Objects in a framework, particularly 
   objects that represent a user interface, are no different. Events are 
   triggered when a user closes a window, or clicks on a button. Events 
   happen when the state of an object changes, such as reading data from 
   a stream, or upon the object's creation. Not only do events happen, 
   but quite often one object wants to be notified when a particular 
   event happens to another object, and frequently the two objects may 
   have no direct knowledge of each other. Not only that, but it is 
   entirely possible that more than one object wants to notified of the 
   event happening !</P>
  <P>
   In most frameworks this is done through callbacks, and their are many 
   different ways to approach this. In C++ this gets a bit tricky due to 
   the nature of C++ member functions, so we need a way to wrap the 
   callback function, which itself needs to be a member function. In 
   addition, we need a consistent way to let objects know that we are 
   interested in being notified when a particular event happens, as well 
   as telling the same object that we no longer want to be notified.</P>
  <P>
   To accomplish this in the VCF we have three main players: the source, 
   or object that fires the event, the event, which itself represented 
   by an object, and the observer, or object that wishes to receive 
   notification when the event occurs. Each of these objects has to have 
   certain responsibilities as described in the table below.</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="0" CELLSPACING="0" BORDER="1">
    <TR>
     <TD WIDTH="24%" BGCOLOR="GRAY" VALIGN=CENTER>
      <P>
       Object</TD>
     <TD WIDTH="76%" BGCOLOR="GRAY" VALIGN=CENTER>
      <P>
       Responsibilities&nbsp;</TD>
    </TR>
    <TR>
     <TD WIDTH="24%" VALIGN=CENTER>
      <P>
       Source object</TD>
     <TD WIDTH="76%" VALIGN=CENTER>
      <P>
       The source must have methods for registering, and un-registering the 
       observer object(s)</TD>
    </TR>
    <TR>
     <TD WIDTH="24%" VALIGN=CENTER>
      <P>
       Event object</TD>
     <TD WIDTH="76%" VALIGN=CENTER>
      <P>
       The Event object must provide data to be used by the observer 
       objects. For example, mouse event object would contain data about the 
       position of the mouse, the buttons that were held down, etc. In 
       addition, the event must be able to expose who actually fired the 
       event, in other words provide a pointer back to the source of the event.</TD>
    </TR>
    <TR>
     <TD WIDTH="24%" VALIGN=CENTER>
      <P>
       Observer object</TD>
     <TD WIDTH="76%" VALIGN=CENTER>
      <P>
       The observer must define one or more callback methods that will be 
       invoked by the source object during the firing of specific event.</TD>
    </TR>
   </TABLE></P>
  <P>
   A source object that fires events may be any valid VCF object, in 
   other words any class that derives, directly or indirectly, from <CODE>VCF::Object</CODE>.
    This source object usually declares a method for registration and 
   un-registration using the following naming pattern:</P><PRE>void add [Name of the event] Handler(<BR><BR>void remove [Name of the event] Handler(</PRE><P>
   A concrete example of this would be the following:</P><PRE>void Control::addMouseClickedHandler(<BR><BR>void Control::removeMouseClickedHandler(</PRE><P>
   For the events themselves, all event objects must derive, directly, 
   or indirectly, from the common <CODE>VCF::Event</CODE> class, which 
   provides basic functionality, such as when the event occurred (the <CODE>getTime()</CODE> 
   method), and the source of the event (the <CODE>getSource()</CODE> method).</P>
  <P>
   The observer object may be any valid VCF object, in other words any 
   class that derives, directly or indirectly, from <CODE>VCF::Object</CODE>.
    The callback methods are always member methods and may be <CODE><B>public</B></CODE>,
    <CODE><B>protected</B></CODE>, or <CODE><B>private</B></CODE> in 
   scope. They are typically defined as follows:</P><PRE>void [Name of the callback method]([type of the event class]* event )</PRE><P>
   So a real world example might look like this:</P><PRE>void onMyMouseClick( VCF::MouseEvent* event )</PRE><P>
   So far we have discussed the three main players that are involved 
   when events are fired, but we have not yet actually defined <I>how</I> 
   the observer of the event connects to the source object that is 
   firing the event. To facilitate this the VCF uses something called an 
   event handler, which acts as the glue between the source of the 
   events being fired, and the observer of the events. In Java this 
   would have been referred to as some sort of Listener interface, in 
   .NET this is known as <I><B>delegate</B></I> object.&nbsp;Event 
   handlers are described by the <CODE>VCF::EventHandler</CODE> class, 
   and implemented by derived classes of <CODE>VCF::EventHandler</CODE>. 
   The <CODE>VCF::EventHandler</CODE> is an abstract class that 
   encapsulates a member method on the observer object that will be 
   called when the event happens, in other words a callback function. 
   The <CODE>VCF::EventHandler</CODE> serves as a base class for other 
   classes to derive from. But wait - what are these other classes ? In 
   order to make the method pointer work cleanly, the VCF uses a special 
   template class called <CODE>VCF::EventHandlerInstance</CODE> which 
   requires template types that specialize the Observer class type, and 
   the Event class type. It is declared like this:</P><PRE>template &lt;class OBSERVER, class EVENT&gt; class EventHandlerInstance : public EventHandler {<BR>     public:<BR>     EventHandlerInstance( SOURCE* source, <BR>                           OnEventHandlerMethod handlerMethod, <BR>                           const String&amp; handlerName=&quot;&quot; )<BR>     .<BR>     .<BR>     .<BR>}</PRE><P>
   The OBSERVER type is used to create a <CODE>typedef</CODE> for the 
   member function pointer, of the form:</P><PRE>void (OBSERVER::*MethodPtr)( EVENT* event );</PRE><P>
   Because we specify the exact OBSERVER type and EVENT type as template 
   arguments, we can make a type safe method <CODE>typedef</CODE>, and 
   do not have to rely on typecasts to force the function pointer to be 
   correctly assigned.</P>
  <P>
   To construct an <CODE>VCF::EventHandlerInstance</CODE> we must pass 
   in the source object that will receive the event callbacks, a method 
   pointer of the source object, and an optional name for the event 
   handler. If we specify a name for the event handler, and the source 
   object derives from <CODE>VCF::ObjectWithEvents</CODE>, then the 
   event handler will automatically be added to the source object's list 
   of event handlers. This will allow you to retrieve it later, as well 
   as reclaim the memory for the event handlers when the source object 
   is destroyed. Because of this instances of class <CODE>VCF::EventHandlerInstance
    </CODE>must <SPAN STYLE="font-style : italic;font-weight : bold;">always</SPAN> 
   be created on the heap.&nbsp;A concrete example of this would be an 
   object being notified when a mouse click happens on a control:</P><PRE>.<BR>.<BR>.<BR>Control* someControl = ....<BR>someControl-&gt;addMouseClickedHandler( <BR>new EventHandlerInstance&lt;Foo,MouseEvent&gt;( this, Foo::onMyMouseClick, &quot;FooMouseHandler&quot; ) );<BR>.<BR>.<BR>.<BR>}<BR><BR>void Foo::onMyMouseClick( MouseEvent* event )<BR>{<BR>.<BR>.<BR>.<BR>}</PRE><P>
   &nbsp;</P>
  <H4>
   Why do it this way ?</H4>
  <P>
   Typically in most frameworks, a single method is registered as the 
   callback for a single event notification. This is OK in the case 
   where your window object wants to be notified when some one clicks on 
   it, but what about when other objects, besides the window want to be 
   notified of this event as well ? In other words there is usually a 
   one to one relationship between the event that is fired and the 
   object that handles the event notification. This is diagrammed 
   visually in Figure 1 below:</P>
  <P>
   Figure 1<BR>
   <IMG SRC="old_style_event_handling.gif" WIDTH="436" HEIGHT="325" VSPACE="0" HSPACE="0" BORDER="0"></P>
  <P>
   In our example above, typically the window has to manually pass the 
   event along to the objects, calling some predetermined method on the 
   object. This is difficult to keep in synch and doesn't scale well. In 
   addition, it requires the same kind of code to written over and over 
   again, which in itself is error prone. In the VCF, the object that 
   fires the event may have an unlimited number of event handlers that 
   get notified when a particular event happens that the event 
   handler(s) have been registered for. Again, this is diagrammed 
   visually in Figure 2, below:</P>
  <P>
   Figure 2<BR>
   <IMG SRC="vcf_event_handling.gif" WIDTH="492" HEIGHT="434" VSPACE="0" HSPACE="0" BORDER="0"></P>
  <P>
   This allows us to scale up much easier and with very little code on 
   the part of the developer. Let's take things a bit further and see 
   exactly how much code is necessary to hook these pieces together.</P><PRE>Window* wind = ...<BR>.<BR>.<BR>.<BR>wind-&gt;addClickedHandler( new EventHandlerInstance&lt;Window,ClickEvent&gt;( wind, Window::onClick, &quot;windClickHandler&quot; ) );<BR></PRE><P>
   As you can see it doesn't take much - just call the appropriate <CODE>add<B><I>XXX</I></B>Handler</CODE> 
   method on the object that fires the events you're interested in (in 
   this case the instance referred to by the <CODE>wind</CODE> 
   variable), and create a new EventHandlerInstance, passing in the 
   source object that will receive the notification, the callback 
   method, and the name of the event handler. In our example above we 
   are assuming our imaginary Window object has an <CODE>addClickedHandler()</CODE> 
   method, and that it fires off events of type <CODE>ClickEvent</CODE>. 
   If we repeat this we can add our other two objects as well, like so:</P><PRE>Window* wind = ...<BR>Obj1* obj1 = ...<BR>Obj2* obj2 = ...<BR>.<BR>.<BR>.<BR>wind-&gt;addClickedHandler( new EventHandlerInstance&lt;Window,ClickEvent&gt;( wind, Window::onClick, &quot;windClickHandler&quot; ) );<BR>wind-&gt;addClickedHandler( new EventHandlerInstance&lt;Obj1,ClickEvent&gt;( obj1, Obj1::onClick, &quot;obj1ClickHandler&quot; ) );<BR>wind-&gt;addClickedHandler( new EventHandlerInstance&lt;Obj2,ClickEvent&gt;( obj2, Obj2::onClick, &quot;obj2ClickHandler&quot; ) );<BR></PRE><P>
   Now, whenever the clicked event occurs, all three objects will be notified.</P>
  <P>
   To simplify things a bit further, in the core framework, particularly 
   the ApplicationKit, there are event handler classes defined for most 
   of the corresponding event classes. For example, all mouse events, 
   such as mouseClick, mouseDown, etc, use the <CODE>VCF::MouseEvent</CODE> 
   class when the event is fired off. So a special event handler class 
   is also defined, called, predictably, <CODE>VCF::MouseEventHandler</CODE>,
    which derives from the <CODE>VCF::EventHandlerInstance</CODE> as follows:</P><PRE>template &lt;class SOURCE&gt; class MouseEventHandler: public EventHandlerInstance&lt;SOURCE,MouseEvent&gt;{<BR>     public:<BR>     MouseEventHandler( SOURCE* source, <BR>                           OnEventHandlerMethod handlerMethod, <BR>                           const String&amp; handlerName=&quot;&quot; )<BR>     .<BR>     .<BR>     .<BR>}</PRE><P>
   Note the difference from the <CODE>VCF::EventHandlerInstance</CODE> 
   class: when using <CODE>VCF::MouseEventHandler</CODE> class you only 
   need to specify the SOURCE template type, then EVENT type is supplied 
   for you. Of course you don't have to use the class, but it makes 
   things a bit simpler. Let's look at a real world example, where an 
   application wants to get notified when a menu item is clicked on</P><PRE>//class declaration<BR>class MyApplication : public VCF::Application {<BR>public:<BR>virtual bool initRunningApplication();<BR><BR>protected:<BR>void onFileOpen( MenuItemEvent* event );<BR><BR>//rest of class declaration<BR>.<BR>.<BR>.<BR>};<BR><BR><BR>//class implementation<BR><BR>bool MyApplication::initRunningApplication()<BR>{<BR>//rest of initialization, main window and menu items have already been created<BR>MenuItem* fileOpenItem = ....<BR>fileOpenItem-&gt;addMenuItemClickedHandler( new VCF::MenuItemEventHandler&lt;MyApplication&gt;( this, <BR>MyApplication::onFileOpen, <BR>&quot;fileOpenHandler&quot; ) );<BR>.<BR>.<BR>}<BR><BR>void MyApplication::onFileOpen( MenuItemEvent* event )<BR>{<BR>//do stuff here<BR>}</PRE><P>
   Here we have declared a class called <CODE>MyApplication</CODE> that 
   derives from <CODE>VCF::Application</CODE>. We override the <CODE>initRunningApplication()</CODE> 
   method for our own initialization and add a callback method,&nbsp; <CODE>onFileOpen()</CODE>,
    to be invoked whenever the user clicks on the &quot;File &gt; 
   Open&quot; menu item of our application. In our implementation of the <CODE>initRunningApplication()</CODE> 
   method we simply add an event handler for menu item clicks to the 
   menu item in question ( stored here in the <CODE>fileOpenItem</CODE>&nbsp;
    variable) via the <CODE>addMenuItemClickedHandler()</CODE> method. 
   Notice the difference from the previous example where we passed in 
   new VCF::EventHandlerInstance, whereas here we are simply passing in 
   a new&nbsp; <CODE>VCF::MenuItemEventHandler</CODE> object. Like the <CODE>VCF::MouseEventHandler</CODE> 
   class, the <CODE>VCF::MenuItemEventHandler</CODE> derives from <CODE>VCF::EventHandlerInstance</CODE>,
    and passes in the correct event type to <CODE>VCF::EventHandlerInstance</CODE>,
    in this case a <CODE>VCF::MenuItemEvent</CODE>. We could have just 
   as easily used the code below as well,</P><PRE><!-- $MVD$:spaceretainer() --> <BR>fileOpenItem-&gt;addMenuItemClickedHandler( new VCF::EventHandlerInstance&lt;MyApplication,VCF::MenuItemEvent&gt;( this, <BR>MyApplication::onFileOpen, <BR>&quot;fileOpenHandler&quot; ) );</PRE><P>
   but using the <CODE>VCF::MenuItemEventHandler</CODE> class is a 
   little more convenient.</P>
  <P>
   Not only is it possible for a single object to have more than one 
   event handler connected to it, allowing the object to 
   &quot;publish&quot; its event to multiple sources, it is also 
   possible for a single event handler to be registered with multiple 
   objects. Figure 3, below, diagrams this relationship.</P>
  <P>
   Figure 3<BR>
   <IMG SRC="shared_event_handlers.gif" WIDTH="381" HEIGHT="386" VSPACE="0" HSPACE="0" BORDER="0"></P>
  <P>
   This means that the functionality of a particular event handler 
   method can be shared and reused for multiple events. One example 
   might be a series of menu items that when clicked on, activate a 
   specific type of tool. These menu items could share the functionality 
   of their handler code, as the only difference would be the tool being 
   selected. Since all the menu items have an index, we could compare 
   the index on the menu item and do something like the following:</P><PRE>MenuItem* item1 = ...<BR>MenuItem* item2 = ...<BR>MenuItem* item3 = ...<BR><BR>EventHandler* menuItemHandler = new VCF::EventHandlerInstance&lt;MyApplication,VCF::MenuItemEvent&gt;( this, <BR>MyApplication::onToolSelection, <BR>&quot;ToolSelectionHandler&quot; ) );<BR>item1-&gt;addMenuItemClickedHandler( menuItemHandler );<BR>item2-&gt;addMenuItemClickedHandler( menuItemHandler );<BR>item3-&gt;addMenuItemClickedHandler( menuItemHandler );<BR>.<BR>.<BR>.<BR>}<BR><BR>void MyApplication::onToolSelection( VCF::MenuItemEvent* event )<BR>{<BR>MenuItem* item = (MenuItem*)event-&gt;getSource();<BR>switch( item-&gt;getIndex() ) {<BR>case 0: {<BR>selectTool1();<BR>}<BR>break;<BR><BR>case 1: {<BR>selectTool2();<BR>}<BR>break;<BR><BR>case 2: {<BR>selectTool3();<BR>}<BR>break;<BR>}<BR>}</PRE><P>
   We now have all three menu items connected to one method !
 </BODY>
</HTML>