<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:color("21","333333","Custom #3","0") -->
  <!-- $MVD$:color("22","ee4444","Custom #4","0") -->
  <!-- $MVD$:color("23","ffcc99","Custom #5","0") -->
  <!-- $MVD$:color("24","ff6600","Custom #6","0") -->
  <!-- $MVD$:color("25","eeeeee","Custom #7","0") -->
  <!-- $MVD$:color("26","204060","Custom #8","0") -->
  <!-- $MVD$:color("27","80e0","Custom #9","0") -->
  <!-- $MVD$:color("28","206080","Custom #10","0") -->
  <!-- $MVD$:color("29","802000","Custom #11","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>Introduction</TITLE>
  <META NAME="generator" CONTENT="Microsoft FrontPage 4.0">
  <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition">
  <SCRIPT LANGUAGE="JavaScript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js"></SCRIPT><LINK
  REL="StyleSheet" HREF="default.css"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <H1>
   <!-- $MVD$:spaceretainer() -->&nbsp;</H1>
  <H1>
   Introduction</H1>
  <P>
   Welcome to the Visual Component Framework !</P>
  <P>
   The Visual Component Framework was inspired by the ease of use of 
   environments like NeXTStep's Interface Builder, Java IDE's like 
   JBuilder, Visual J++, and Borland's Delphi and C++ Builder. I wanted 
   a generic C++ class framework I could use to build app's quickly and 
   visually (when designing UIs), as well as having the core of the 
   framework be as cross platform as possible. The Visual Component 
   Framework is an Open Source project, so feel free to grab and use it 
   if you think it might be useful. If you're really adventuresome you 
   can volunteer to help develop it, making it even better, especially 
   in tying it into the VC++ environment as an add-in.&nbsp;</P>
  <P>
   The Visual Component Framework (VCF) is currently divided into three 
   DLL's, the FoundationKit, the GraphicsKit, and the ApplicationKit 
   (these are DLL's for the Win32 version only, obviously under Linux 
   these would be Shared Objects).</P>
  <H3>
   <SPAN STYLE="font-weight : bold;">System Requirements:</SPAN></H3>
  <P>
   Currently the framework is being developed under Windows 2000. It was 
   working under Windows 98/WinNT 4.0 but this has not been tested in a while.</P>
  <H6>
   <!-- $MVD$:spaceretainer() -->&nbsp;</H6>
  <H3>
   <SPAN STYLE="font-weight : bold;">Development Requirements:</SPAN></H3>
  <P>
   The current build works under Visual C++ 6.0, but should be workable 
   under other Windows compilers as well, especially the Borland C++ 5.x compiler.</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <H1>
   <A NAME="Why_VCF"></A>Why use the Visual Component Framework, and 
   just what's the point of a Yet Another Framework ?</H1>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <H3>
   Introduction</H3>
  <P>
   The Visual Component Framework (VCF) was designed to make application 
   programming in general, particularly applications with User 
   Interfaces, much easier than it currently is with typical development 
   tools. In addition it was created to be cross platform in design, so 
   a program relying only on features within the VCF should simply 
   recompile on another platform supported by the VCF.</P>
  <P>
   Designing an application is a complex task, especially when User 
   Interfaces are factored in, and typically are difficult to change, 
   especially as more and more features are added to the project as time 
   goes on. While some tools simplify this through a RAD (Rapid 
   Application Development) methodology, they are usually unsuited for 
   final use due to constraints of the language. An example is 
   Microsoft&#146;s Visual Basic, which allows rapid prototyping of a 
   UI, but lacks many critical features of a framework (such as a 
   consistent Event model across <B>all</B> components, or some form of 
   a Model-View-Controller architecture), in addition it is also slow, 
   which is a draw back for high performance applications, in other 
   words, Adobe isn&#146;t going to drop C/C++ in favor of VB for 
   writing any of their products. Even for corporate applications, while 
   VB is suited for many tasks where performance is not critical, there 
   are many cases where C++ is preferred, and is ultimately used. Thus, 
   in my experience, it is a reasonable assumption that most 
   &#147;real&#148; applications end up being written in either C or 
   C++, with more and more applications being written exclusively in C++.</P>
  <P>
   Not only is designing the application complex, but mastering the 
   various common tasks the application must typically perform are also 
   complex, such as displaying one or more windows to the user, the 
   creation of forms for entering information, laying out the various 
   controls in a consistent manner relative to one another, trapping 
   various events, either generated by the OS, or in the application 
   itself. Working with the OS, in this case MS Windows, API is often a 
   frustrating experience, and is time consuming and error prone, and 
   full of all sorts of &#147;gotchas&#148; which the developer(s) must 
   learn to work around, which takes even more time away from actually 
   designing and implementing their application, which is, after all, 
   their actual job. As if that is not bad enough, we then have 
   &#147;frameworks&#148; built on this, which, while perhaps making the 
   transition from C to C++ a bit simpler, are full of buggy kludges, 
   and add their own eccentric &#147;solutions&#148;, which causes even 
   more time to be spent learning their work-arounds, and once again, 
   not spending time on what the developer was originally hired to do: <I>write
    applications, not write work-arounds</I>.</P>
  <P>
   One of the things that helps simplify application development, and 
   one of the strengths of environments like a VB or Borland&#146;s 
   Delphi, is being able to develop with components. In other words, if 
   my application requires forms with entries made by users, and the 
   ability to report on all these entries, why not use a component 
   written by someone else who has done nothing but specialize in doing 
   this. I, as a developer, then spend more time worrying about 
   polishing my key features of my application, and can easily integrate 
   the third part solution without having to worry about every little 
   piece of how it works. This is demonstrated by the thousands, upon 
   thousands, of components available for Delphi and VB, ranging from 
   pretty dressed up label controls, to 3D charting controls, to 
   non-visual components for connecting to a serial port or detecting 
   the CPU information on your computer.</P>
  <P>
   Obviously this is not a new idea. In fact, Microsoft believes in it 
   so strongly they came up with COM (the <B><I>Component</I></B> Object 
   Model), but despite the massive amounts of money and man power thrown 
   behind it, it is not easy to use, is often frustrating to work with, 
   and has a steep learning curve. So, recognizing this, they are now 
   introducing their newest foray into the world of componentized 
   architectures with the introduction of .NET, which, not surprisingly, 
   has as one of it&#146;s primary designers the former lead engineer 
   for Delphi&#146;s VCL component architecture, Anders Hjelsberg.</P>
  <P>
   Therefore it would be nice if we as developers had some framework 
   that provided a solid foundation of common services, as well as 
   support for easily implementing an application, either entirely from 
   code, or through the use of a visual tool that facilitated easily 
   designing UI features, and allowed the extension of that environment 
   through new components as time went on. In addition a framework like 
   this would wrap the common pitfalls usually associated with the 
   particular platform, and free the developer from having to worry 
   about them, with more time to work on their application.</P>
  <H3>
   The Visual Component Framework</H3>
  <P>
   This now brings us to the VCF, which is my attempt to address all of 
   these issues, because I got sick and tired of wasting my time 
   fighting with existing poorly designed and poorly implemented C++ 
   frameworks. In short, why use the VCF? <I>Because it makes your life easier</I>.
    Period.</P>
  <H4>
   Component Architecture</H4>
  <P>
   The VCF is built with an architecture that supports components. In 
   order to do this successfully there are several features that need to 
   be in place, one of which is a rich run time type system, or a 
   reflection API. This is found in almost any framework like this, from 
   Delphi&#146;s VCL, COM&#146;s type information interfaces (most 
   notably <I>ITypeLib</I>, and <I>ITypeInfo</I> interfaces), Java&#146;s
    Reflection API, and .NET&#146;s System.Reflection interfaces/API. 
   The VCF is the only C++ framework (that I am aware of) that can 
   expose the level of detail that is required without breaking the C++ 
   language. Other solutions to this problem involve either proprietary 
   extensions to the language that can only be compiled using the 
   proprietary compiler (i.e. Borland&#146;s C++ Builder), or an 
   additional required pre-processor step necessitating a proprietary pre-processor
    to create the real C++ that is used (some examples are Intrinsic 
   Graphics horrid Object Definition Language that pollutes up C++ class 
   headers, making them largely unreadable, or TrollTech's QT C++ 
   &#147;extensions&#148; that require their MetaObject Compiler ). 
   Through the use of templates, and optional macros, a developer can 
   determine <B><I>exactly</I></B> the amount of runtime information he 
   or she wishes to expose for any class that is written. This 
   information includes the class name and class UUID, the super class, 
   the interfaces the class implements, the methods of the class, the 
   properties the class has, and the events the class supports. This is 
   vital for creating a component system that can be edited visually at 
   design-time, since the system will not have direct knowledge of the 
   specific component.</P>
  <H4>
   Uniform Event System</H4>
  <P>
   The VCF has a uniform event system, that allows any object to listen 
   to events fired by any other object in the system. In addition, more 
   than one object can listen and respond to event(s) fired off by 
   another object, you&#146;re not locked into a one to one 
   correspondence like you are with WM_XXX message handlers or MFC 
   message maps. The event system is based on the Observer pattern, and 
   will be very familiar to developer&#146;s who have worked with Java 
   or Delphi/C++ Builder before.</P>
  <H4>
   Standard Application Services</H4>
  <P>
   The VCF supports common application development services such as 
   providing common dialogs (like print, file open, file save, file 
   browse, etc), undo/redo, persistence through a variety of different 
   stream types (memory based, file based, text based, binary based, 
   RTTI property based, etc), easy access to a registry, error logging, 
   threads, timers, tool tips, images, layout management, and a rich set 
   of controls that are also easy to extend. In addition, on Win32 
   platforms, there will be support for COM, making it easy to embed 
   existing ActiveX control/components in VCF based applications.</P>
  <H4>
   Peaceful Coexistence with existing code</H4>
  <P>
   The VCF can co-exist with existing frameworks/API&#146;s as well. If 
   you already use MFC a lot, you can easily incorporate VCF 
   object&#146;s within the context of your MFC App. Perhaps you find 
   the graphics capabilities in the VCF preferable to those provided by 
   MFC. No problem, just create an instance of a VCF::GraphicsContext 
   and you're off and running. Likewise, perhaps you have a Win32 app, 
   and you&#146;d like to use some of the controls in the VCF, or 
   perhaps you&#146;d like to add multi-threading to your app and use 
   the VCF::Thread class to make your life simpler. All of these things 
   are very easy to do, and can be done with either static or dynamic 
   linkage to the VCF libraries. This is in stark contrast to the MFC 
   approach. Using practically any UI class (i.e. CWnd, CDC, CPen, etc) 
   outside of a full blown MFC app is simply not possible &#150; MFC is 
   an all or nothing proposition.</P>
  <H4>
   Small binary re-distributable size</H4>
  <P>
   Developers are often concerned about the size of either the 
   executable that is produced and/or the size of the required libraries 
   if dynamic linking is used. Since the VCF is a framework you 
   obviously cannot get all of the many features in it for free, but is 
   still smaller than to MFC or QT (total size is a bit under 2 
   megabytes). It can, however, be compressed, with <B><I>no</I></B> 
   discernable performance hits, to less than 700Kb, making it much 
   smaller than it&#146;s competition. Since the VCF is broken up into 
   several core libraries, you can get the basic set of classes (those 
   encapsulated in the FoundationKit) in a DLL weighing in at around 118 Kb.</P>
  <H3>
   What does the VCF really do for you?</H3>
  <P>
   The VCF saves you both time and money. How?</P>
  <P>
   The VCF saves you time by:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    API is consistent. A consistent API is much easier to learn, since a 
    pattern learned in one place is often reused over and over in others 
    places in the API.<BR>
    <LI CLASS="mvd-P">Wraps tricky OS work arounds so you don&#146;t have 
    to remember them. Often these are bugs in the system and any time an 
    Application developer has to spend working around them or fixing them 
    is time wasted, thus at least one of the reasons for using frameworks 
    in the first place.<BR>
    <LI CLASS="mvd-P">Events that fired by various state changes or user 
    actions are consistent so you don&#146;t have to wonder what is going 
    on. In other words, write some code for a keyboard event, and you can 
    rest assured that your call back method will <B><I>always</I></B> get 
    called, whether used in a modal dialog, toolbar, child window, main 
    window, or whatever, the event will get fired, the same way, each and 
    every time. This is in stark contrast to some frameworks that work 
    one in certain cases and another way in other cases, and the only way 
    to find out is often through trial and error, <I>which is a waste of 
    your time !</I><BR>
    <LI CLASS="mvd-P">The VCF framework is broken into lots of small 
    pieces. This makes it easy to add or enhance some specific piece of 
    functionality that your application may need, without writing a whole 
    bunch of extra code. For example, let&#146;s say you needed a tree 
    control whose data model needed to have extra pieces data in it. In 
    the VCF you can just make your own Tree model, and then assign to the 
    already existing TreeControl. In a framework like MFC it would almost 
    never be this easy, and it is almost impossible to effectively reuse 
    your model (or CDocument derived) classes over and over again, across 
    multiple applications, or even within a single application.<BR>
    <LI CLASS="mvd-P">The framework is simple to use. Methods are given 
    logical names that actually resemble what they will do in plain 
    English. Most developers from other frameworks, particularly Java, 
    will recognize the functions at a glance. Almost all of the core 
    classes have been documented at the function level as well, with 
    documentation continuing to evolve as time goes on.<BR>
    <LI CLASS="mvd-P">Most common development tasks have some sort analog 
    in the framework, whether this includes event handling, threads, 
    error logging, exception handling, MVC, undo/redo, streaming and many 
    others, the VCF has you covered. And many of these are entirely 
    independent of the UI portions, making it excellent for use in 
    console-based apps as well.</P>
   </UL>
  <P>
   The VCF saves you money by:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    Reducing development time. Time is, and should be, spent on the 
    application at hand, <B><I>NOT</I> </B>working through kludges. This 
    save money, since time <B>is</B> money.<BR>
    <LI CLASS="mvd-P">Provides a framework for cross-platform 
    development. Applications that require this can greatly benefit, 
    since much, if not all, of the code can be reused, greatly reducing 
    the price of cross-platform development. Once again, this is not 
    limited to simply UI applications. VCF has many features that are 
    perfectly suited for console-based apps. Write it once, and assuming 
    that you only use the VCF API, then you should be able to simply 
    recompile for another platform.<BR>
    <LI CLASS="mvd-P">Makes heavy use of STL, which for shops that use it 
    will be able to seamlessly use their collection code in the VCF, as 
    opposed to yet another collection API that developers have to learn, 
    which costs money.<BR>
    <LI CLASS="mvd-P">Full source with the freedom to use it however is 
    most appropriate for your company. Easy to rebuild using the tools of 
    your choice.</P>
   </UL>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;
  <MAP NAME="introTop">
   <AREA SHAPE=RECT COORDS="19,240,83,267" HREF="VCF_Tools_Introduction.htm">
   <AREA SHAPE=RECT COORDS="218,208,284,238" HREF="Introduction.htm">
   <AREA SHAPE=RECT COORDS="393,238,487,269" HREF="Tutorial_Introduction.htm">
   <AREA SHAPE=RECT COORDS="221,249,280,272" HREF="index.chm::/index.html">
  </MAP>
 </BODY>
</HTML>