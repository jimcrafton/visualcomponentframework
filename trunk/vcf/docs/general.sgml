<!--
Copyright (c) 2000-2003, Jim Crafton
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
	Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in 
	the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

NB: This software will not save the world.
CVS Log info
$Log$
Revision 1.2  2003/05/17 20:36:52  ddiego
this is the checkin for the 0.6.1 release - represents the merge over from
the devmain-0-6-0 branch plus a few minor bug fixes

Revision 1.1.2.3  2003/03/13 02:34:40  ddiego
added some more docs and broke apart the various "books" so they can be all
put together or in separate books. Made to changes to Makefile

Revision 1.1.2.2  2003/03/12 02:51:39  ddiego
more documentation updates

Revision 1.1.2.1  2003/03/03 03:39:49  ddiego
initial check-in of docbook vcf documentation, plus neccesary stylsheets
and images

-->
<chapter><title>General</title>
	<section><title>Features</title>
		<para>
		The VCF features an easy to use programming API and class hierarchy. Below is a list briefly describing the key 
		features in the framework.
		</para>
		<itemizedlist>
				<listitem><para>
				A rich class hierarchy for easily accomplishing your application's programming needs .
				</para></listitem>
				
				<listitem><para>
				Classes that cover the basic needs such as threading, files, streaming, error logging, traces, and common string utils.
				</para></listitem>
				
				<listitem><para>
				Advanced RTTI features that allow for such things as dynamic object creation given a registered 
				class name or a registered UUID string that represents the class, dynamic introspection of a given 
				object's class and listing such data as the class name, super class, the properties of the class, member 
				methods, and implemented interfaces.
				</para></listitem>
				
				<listitem><para>
				Memory leak detection in debug mode for catching VCF::Object derived classes that have not been 
				freed. This can be turned completely off in debug by recompiling the libraries 
				</para></listitem>
				
				<listitem><para>
				Standard event architecture that can be used in console applications as well as GUI based applications. 
				Allows for connecting class member functions to events that another object (or objects) may fire off.
				</para></listitem>
				
				<listitem><para>
				Graphics classes for easily drawing on a graphics context, as well as working with images. This 
				includes easily manipulating things like the current color, pen and brush attributes, and 
				current transformation matrix.
				</para></listitem>
				
				<listitem><para>
				A simple image loading architecture that allows multiple formats to be registered for loading up a 
				variety of different graphics formats. On Win32 systems the default image loading support is limited 
				to >BMP files, but by using the ImageFormats library (also a part of the VCF) a wide variety of 
				additional image types are also supported. Currently the ImageFormats library uses FreeImage to 
				support a image types such as .TIFF, .TGA, .PSD, .PNG, .PCX, .SGI, .MNG, .RAS, .PBM, .PPM. 
				and many others. 
				</para></listitem>
				
				<listitem><para>
				More advanced classes for customizing the drawing process with application defined behaviors.
				</para></listitem>
				
				<listitem><para>
				A complete set of GUI classes, including a common set of base classes enabling advanced custom 
				control creation. Some of the control classes include tree controls, list controls, check box and radio 
				controls, push buttons, single line and multi line text controls, and many others.
				</para></listitem>
				
				<listitem><para>
				A standard set of application classes for things like resources, loading windows or forms dynamically 
				at application startup, saving of application state, a registry class for common storage of system and 
				application information.
				</para></listitem>
				
				<listitem><para>
				Other application classes include a simple Undo/Redo architecture based on commands that allows 
				for undoing and redoing commands as well as notifying other objects of the events.
				</para></listitem>
				
				<listitem><para>
				GUI controls that support both alignment and anchoring. Any control may be aligned to the top, 
				bottom, left or right of it's parent container control.  Alternately controls may use their anchoring 
				properties to anchor themselves to the left, right, top and/or bottom sides of their parent container 
				control. 
				</para></listitem>
				
				<listitem><para>
				The GUI provides a set of Model and View classes for using in MVC patterns. A series of models 
				like the ListModel, TreeModel, and  TextModel are used in controls to provide separation of the data 
				from the UI presentation code. Because a View can be dynamically attached to a Control at runtime, 
				it will be possible to develop "themes" in the future. 
				</para></listitem>
				
				<listitem><para>
				Because of the RTTI features and the event handlers, the VCF easily supports component programming. 
				Objects can easily register event handlers with other object in the system at runtime, without knowing the 
				specifics of each other.
				</para></listitem>
				
				<listitem><para>
				As much as possible, VCF tries to be as flexible as possible, allowing you to use the parts you want, 
				and allowing for interoperability with other frameworks. Thus VCF controls can be used inside of an 
				MFC app if you like. 
				</para></listitem>
				
				<listitem><para>
				No need of special preprocessor tools - if you have a reasonably complete C++ compiler then you're 
				all set to go.
				</para></listitem>
				
				<listitem><para>
				Heavy use of the Standard Template Library throughout the VCF, as well as templates, that make 
				up the RTTI extensions the VCF implements.
				</para></listitem>
				
				<listitem><para>
				Ability to access the low level handles for most native objects. For example, by accessing the 
				Thread's peer class, you can get a handle to the native thread handle itself. For a control, you can 
				access the control's peer and get a handle id that represents the windowing systems native handle for 
				a window/widget. This allows you to use platform specific calls when neccessary.
				</para></listitem>					
		</itemizedlist>			
	</section>

	<section><title>Downloading the VCF</title>
		<para>To be done </para>
	</section>

	<section><title>Required Tools</title>
		<para>
		These are the required tools if you want to build the VCF.
		</para>
		<para>
		The tools you need depend on the platform you plan to work on, in the following list.
		</para>
		<itemizedlist>
			<listitem>
				<para>Win32</para>
				<para>
					For this platform the preferred compiler is currently the Microsoft Visual C++ 6 compiler with 
					Service Pack 5 applied. Microft Visual C++ 7 also works but some setting may be slightly different
					or found in different places than described in the documentation.
				</para>
			</listitem>					
			<listitem>
				<para>Linux</para>
				<para>
					Please use GCC 2.95. As of this writing this is the only compiler working on this platform.
				</para>
			</listitem>
			<listitem><para>MacOSX</para></listitem>
			<listitem>???</listitem>
		</itemizedlist>
	</section>

	<section><title>Installing the VCF</title>
		<section><title>For Win32 systems</title>
		<formalpara><title>Using the VCF Installer</title>
		You can install the VCF in a number of ways. The simplest way to install on a "clean" system, is to simply download the 
		VCF Installer from <ulink url="http://sourceforge.net/project/showfiles.php?group_id=6796">Source Forge</ulink>, save the
		appropriate file to your hard drive, run it, and Voila! you are ready to rock and roll! 
		</formalpara>
		<note><title>Installer currently broken</title>
			<para>
			The VCF Installer is currently broken and is not being offered at the moment
			</para>
		</note>
		<formalpara><title>Install from a soruce archive</title>
		The more complex way is to pull down the latest cvs tar.gz file (again, you can get that from 
		<ulink url="http://sourceforge.net/project/showfiles.php?group_id=6796">Source Forge</ulink>) and uncompress 
		it somewhere on you hardrive. Once you have done this you'll need to set up some environment variables, which are as 
		follows: 
		</formalpara>
		<itemizedlist>
			<listitem><para>
				VCF_BIN : this should point to the bin under the root where you installed the VCF. For example, on my 
				machine it resolves to "d:\code\vcf\bin". 
			</para></listitem>
			<listitem><para>
				VCF_INCLUDE : this should point to the include directory under the same VCF root mentioned earlier. 
				Once again (as an example), on my machine this resolves to "d:\code\vcf\include" 
			</para></listitem>
			<listitem><para>
				VCF_LIB : this should point to the lib directory under the same VCF root mentioned earlier. Once again 
				(as an example), on my machine this resolves to "d:\code\vcf\lib". 
			</para></listitem>
		</itemizedlist>
		<para>
		Once you have this done you can open up the projects in Microsoft Visual Studio and build the various 
		workspaces (.dsw files).
		</para>
		
		<formalpara><title>Install via CVS access</title>
		The most "advanced" way is to connect to cvs and pull down either the latest stable version or the latest 
		development version. There are instructions on SourceForge detailing 
		<ulink url="http://sourceforge.net/cvs/?group_id=6796">how to do this</ulink>. 
		<note><title>Anonymous vs. developer cvs access</title>
			<para>
			if you download the VCF via anonymous CVS access, and then, realizing it is the greatest thing since 
			sliced bread and toasted crumpets, you decide to join the project (hint, hint), you will need to either delete 
			the directory where you currently have the VCF, or pull it down with cvs to a different directory.
			</para>
			<para>
			The problem that arises is that you will be unable to check-in anything, despite having joined the project and 
			received write access to the cvs repository. I think this is because cvs thinks you are still "anonymous" and 
			you have no write access for an anonymous user. 
			</para>
		</note>
		</formalpara>
		<para>
		Once you have pulled down the code with cvs repeat the steps above for environment variables.
		</para>
		</section>
		<section><title>For Linux systems</title>
		</section>
	</section>

	<section><title>Building the VCF</title>
		<para>
		Building the VCF is easy. This assumes that you have downloaded it and, if necessary, set up any environment 
		variables. The following sections will discuss building the VCF on specific platforms.
		</para>
		<section><title>VCF Tools</title>
		</section>
		<section><title>Win32</title>
			<para>
			Required tools:				
			</para>
			<para>
			Microsoft Visual C++ 6.x
			</para>
			<para>
			The first thing you'll want to is build the various add-ins for Developer Studio. Open the main workspace 
			found in vcf/build/vc60/add-ins/all.dsw. Build the "Win32 Release" configuration, making sure that the "all" project is 
			the current active project. This should build the VCF New Class add-in, plus project wizards VCFLibraryAppWizard, 
			VPLAppWiz, VCFConsoleWiz, and VCFAppWiz. To verify that these were correctly built go to "File | New..." and 
			click on the "Projects" tab and you should see something like the following:
			</para>
			<screenshot>
				<graphic fileref="gfx/addins_verify.png"></graphic>
			</screenshot>
			<para>
			The red circle indicates the various new Application Wizards that you should see.
			</para>
			<para>
			Once this is done you should build the VCF framework itself. Open the vcf/build/vc60/vcfAll.dsw workspace. 
			This workspace has all the various framework projects, both as static .lib files and DLL projects. To build all the
			DLL projects select the "vcfAll" project and make it the active project. Building this project will automatically 
			build the FoundationKit, GraphicsKit, ApplicationKit, NetworkKit, and RemoteObjectKit. To build all the core 
			static libraries select the "vcfAllStaticLibs" project and make it the active project. 
			</para>
			<para>
			There are several additional projects you can build as well for additional features.
			</para>
			<itemizedlist>
				<listitem><para>
				<para>
				The ImageFormats project, which adds support for a wide variety of image formats by using the 
				<ulink url="http://www.6ixsoft.com/">FreeImage library</ulink>. Build this if you would like to add this support 
				to your project.
				</para>
				</para></listitem>
				<listitem><para>
				<para>
				The Win32HTMLBrowser (and Win32HTMLBrowser_StaticLib) project, for an HTML browser peer 
				(currently implemented using the Internet Explorer IWebBrowser COM interface, though experiments have been done 
				using the Gecko component from mozilla.  
				</para>
				</para></listitem>
			</itemizedlist>
			<para>
			The build will take a bit, so now would be a good time for coffee, tea, or perhaps reading some Dostoevsky...
			</para>
			<para>
			Once the build is finished you are ready to go ! All binaries will be put in the vcf/bin directory when built.
			</para>		
		</section>
		<section><title>Linux</title>
		</section>
		<section><title>MacOSX</title>
		</section>
	</section>		
	
	<section><title>Contributing</title>
		<section><title>Registering at SF</title>
		<para>
		Interested in contributing to the VCF project ? Great ! First you need to become a member of Source Forge. Source 
		Forge membership is free, and only takes a minute to fill out the web form. It is a requirement for participating in any 
		Source Forge sponsored project, like the VCF. You can join at the Source Forge 
			<ulink url="http://sourceforge.net/account/register.php">New User page</ulink>.
		</para>
		<para>
		Next, you need to email me, and let me know to add you to the project. It usually takes a day or so for your Source Forge 
		account to become activated,  so keep that in mind. If your a developer, you'll be added with read/write privileges to the CVS 
		source tree. 
		</para>
		</section>
		<section><title>Setting up CVS</title>
			<para>
			Once all of this is done, all you have to do is setup your machine to use CVS and SSH. CVS and SSH are must have tools, 
			without these you'll not be able to check source code in or out from CVS, which is the standard version control program used 
			by all Source Forge projects. You can get both of these tools from a variety of places, including the VCF Installer, as well as 
			a smaller installer on the project that only installs CVS and SSH, and also configures your system to use them ( you can get 
			this installer here). For documentation on how to use SSH on your Win32 system, Source Forge has some great articles, as 
			well as some specific stuff just for Win32 (here, and here). There are some things you'll need to check for to make sure CVS 
			and SSH will work together correctly so please verify the following: 
			<itemizedlist>
				<listitem><para>
				You'll need a CVSROOT variable that equals 
				<synopsis>
:ext:&lt;your username&gt;@cvs.vcf.sourceforge.net:/cvsroot/vcf
				</synopsis>
				</para></listitem>
				<listitem><para>
				You'll need a CVS_RSH that equals "ssh" 
				</para></listitem>
				<listitem><para>
				A HOME variable that points to wherever you'd like you home directory to be 
				</para></listitem>
				<listitem><para>
				A HOMEPATH variable that should read the same as the HOME variable above 
				</para></listitem>
			</itemizedlist>
			</para>				
		</section>
		
		<section><title>Developing in the main VCF source tree</title>
			<para>
			When developing in the VCF proper you need to be aware that there are at least two branches 
			in CVS at any given time. There will be a dev branch for adding new features etc. Until this new 
			set of features is tested and ready it will stay separate from the main branch, which should 
			contain relatively stable code. When you are working on implementing these new features you 
			should be working in this development branch, NOT the main branch. The main branch is only for 
			checking in bug fixes for reported bugs on it. This allows people to download a stable branch, 
			rather than pulling something down that is in a continuous state of flux.
			</para>
			<para>
			As a developer you need to be aware of this and make sure that you are checking out the 
			correct version. Please see this for instructions on how to access branches in CVS trees. For 
			further help look at the 
			<ulink url="http://www.cvshome.org/docs/manual/cvs.html">cvshome.org</ulink> pages 
			for more detailed information on using cvs.
			</para>
			<para>
			The recommended procedure is the following:
			</para>
			<para>
			Create two directories, perhaps something like this:
			<screen>
&lt;rootdir&gt;
vcfcode/
	dev/
		vcf/
		     include/...
		       src/...
	stable/
		  vcf/
		     include/...
		     src/...
			</screen>
			</para>
			<para>
			This gives you a stable release directory to work on for bug fixing, and another directory to work on for new 
			development code that may be unstable or untested and is not yet ready to go into the main branch.
			</para>
		</section>
		<section><title>Standards</title>
			<para>
			Please read the naming standards documentation before you start changing all sorts of things. These standards must be followed 
			for any code that gets entered into the main VCF development tree. 
			</para>
			<para>
			To get familiar with things build the VCF if you haven't already done so, and then check out some of the tests and example code in 
			the vcf/tests directory.  
			</para>
			<para>
			If you're unsure where to go next, try taking a look at the 
			<ulink url="http://sourceforge.net/tracker/?group_id=6796&amp;atid=106796">bug list</ulink> or 
			<ulink url="http://sourceforge.net/pm/?group_id=6796">tasks list</ulink> at the project page. Also feel free to contact me for 
			more information.  
			</para>
			<section><title>Coding and Naming Standards</title>
				<para>
				The following <indexterm><primary>standards</primary></indexterm> are setup here to attempt to increase the readability of the VCF source code.  
				Developers interested working on the framework proper, must adhere to these guidelines. 
				Any questions regarding this, please email me. 
				<note>
				Much of this is rehashed from naming standards used on other projects, so there is nothing new here, 
				and tries to use as much common sense as possible.  Folks who are familiar with Borland's Delphi, 
				Sun's Java, or (gasp...) Microsoft's .NET naming conventions will probably recognize a great deal 
				here. 
				</note>
				</para>
				
				<para>
				As a general rule, please do <emphasis>not</emphasis> use Hungarian notation at all in any code that is in the main VCF 
				development tree.
				</para>
				<para>
				<title>Capitalization Styles</title>					
				</para>
				<para>
				There are two main capitalization schemes the VCF uses:
				</para>
				<para>
				<title>Camel casing:</title>
				</para>
				<para>
				Capitalizes the first character of each word except the first word. For example:
				<programlisting>
fileStream
				</programlisting>
				</para>
				
				<para>
				<title>Pascal casing:</title>
				</para>
				<para>
				Capitalizes the first character of each word. For example:
				<programlisting>
FileStream
				</programlisting>
				</para>
				<para>
				The following table indicates which styles are used for the various types/identifiers.
				<table frame="none" pgwide="1">
					<tgroup cols="3" align="left" colsep="1" rowsep="1">
						<thead>
							<row>
								<entry>Type</entry>
								<entry>Case</entry>
								<entry>Comments</entry>
							</row>							
						</thead>
						<tbody>
							<row>
								<entry>Class</entry>
								<entry>Pascal casing</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>enumerated values</entry>
								<entry>Camel casing</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>enumerated type</entry>
								<entry>Pascal</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>Member function, regular functions</entry>
								<entry>Camel casing</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>Namespaces</entry>
								<entry>Pascal casing</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>RTTI property name</entry>
								<entry>Camel casing</entry>
								<entry></entry>
							</row>
							
							<row>
								<entry>Function arguments</entry>
								<entry>Camel casing</entry>
								<entry></entry>
							</row>
							<row>
								<entry>Member variables</entry>
								<entry>Camel casing</entry>
								<entry>uses "_" suffix </entry>
							</row>
							
							<row>
								<entry>regular variables</entry>
								<entry>Camel casing</entry>
								<entry></entry>
							</row>				
							
						</tbody>
					</tgroup>
				</table>					
				</para>
				
				<para>
				<title>Class naming</title>
				</para>					
				<para>
				Classes should be named with nouns or noun phrases, with more or less abstraction 
				in the name depending on it's usage. For example, a common base class for describing 
				objects that represent bananas, apples and oranges might be Fruit, with a class called 
				Banana deriving from Fruit. 
				<itemizedlist>
					<listitem><para>
					Pascal casing
					</para></listitem>
					
					<listitem><para>
					No prefixes, like "C", or "vcf" or whatever. If you really need a prefix 
					then you probably need the class inside of a namespace. 
					</para></listitem>
					
					<listitem><para>
					Keep away from abbreviations if at all possible. Common ones like IO, or UI are 
					OK, but please use sparingly.
					</para></listitem>
					
					<listitem><para>
					No underscores.
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Examples:
				<programlisting>
FileStream

ClassRegistry

Control					
				</programlisting>
				</para>
				<para>
				<title>Enumerated values</title>					
				</para>
				<para>
				Enumerated values should have a descriptive name of what the value represents. The 
				value names should use a prefix that is an acronym of the upper case characters of the 
				enumeration type.
				<itemizedlist>
					<listitem><para>
					Camel casing
					</para></listitem>
					
					<listitem><para>
					Prefixes are OK, but must follow the rules above, see example
					</para></listitem>
					
					<listitem><para>
					Keep away from abbreviations if at all possible. Common ones like IO, 
					or UI are OK, but please use sparingly
					</para></listitem>
					
					<listitem><para>
					No underscores 
					</para></listitem>
				</itemizedlist>					
				</para>
				<para>
				Examples:
				<programlisting>
enum FruitBaskets {
fbLittleBasket = 0,
fbMediumBasket,
fbElGrandeBasket  
};

enum MessageStyle {
msDefault = 0,
msError,
msInfo,
msWarning
};
				</programlisting>
				</para>
				
				<para>
					<title>Enumerated types</title>
				</para>
				<para>
				Names should be clearly descriptive of the type and what it represents. When 
				appropriate please nest the enum type inside of the class it is associated with 
				(don't forget to place it at public scope so others may use, assuming that is the 
				intent).
				<itemizedlist>
					<listitem><para>
					Pascal casing
					</para></listitem>
					
					<listitem><para>
					No prefixes
					</para></listitem>
					
					<listitem><para>
					Keep away from abbreviations if at all possible
					</para></listitem>
					
					<listitem><para>
					No underscores 
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example
				<programlisting>
Dialog::MessageStyle

AlignmentType
				</programlisting>
				</para>
				<para>
				<emphasis>Always</emphasis> refer to enum types that are part of a class with the class name. 
				</para>
				<para>
				Example
				<programlisting>
Dialog::MessageStyle, 

//as opposed to
MessageStyle
				</programlisting>
				</para>
				
				<para>
					<title>Class member function naming</title>
				</para>
				<para>
				Use names that have verbs or verb phrases that clearly express what the function will do. Functions 
				that return a true or false value should try and use the "is" or "has" in front of the name, i.e. 
				<function>isEmpty()</function> or <function>hasData()</function>.

				<itemizedlist>
					<listitem><para>
					Camel casing 
					</para></listitem>

					<listitem><para>
					Keep away from abbreviations if at all possible
					</para></listitem>
					
					<listitem><para>
					No underscores, unless the function's scope is forced to be public but is not meant for
					general usage(for whatever reason). In this case a "internal_" should be prefixed to the name 
					of the funtion
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example:
				<programlisting>
class Foo : public VCF::Object {
public:

String getName();

void internal_doSomething( int someValue );
};
				</programlisting>
				</para>
				
				<para>
					<title>Class member variable naming</title>
				</para>
				<para>
				Use adjectives that clearly describe what the member is and how it should be used. 
				All member names must use the "_" suffix convention.
				<itemizedlist>
					<listitem><para>
					camel casing
					</para></listitem>

					<listitem><para>
					Keep away from abbreviations if at all possible
					</para></listitem>
					
					<listitem><para>
					a single underscore suffix only, no underscores in the actual name 
					</para></listitem>
					
					<listitem><para>
					no Hungarian notation
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example:
				<programlisting>
class Foo {
public:
protected:
int countOfBarObjects_;
String name_;
};
				</programlisting>
				</para>
				
				<para>
					<title>Variable naming</title>
				</para>
				<para>
				Use descriptive names that clearly identify what the variable should do or what it means rather than 
				identifying it's type. Please do <emphasis>not</emphasis> use Hungarian notation.
				<itemizedlist>
					<listitem><para>
					Camel casing
					</para></listitem>

					<listitem><para>
					Keep away from abbreviations if at all possible
					</para></listitem>
					
					<listitem><para>
					No underscores
					</para></listitem>
					
					<listitem><para>
					No Hungarian notation
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example:
				<programlisting>
				</programlisting>
				</para>
				
				<para>
					<title>Function naming</title>
				</para>
				<para>
				Use names that have verbs or verb phrases that clearly express what the function will do. 
				<itemizedlist>
					<listitem><para>
					Camel casing 
					</para></listitem>

					<listitem><para>
					Keep away from abbreviations if at all possible. 
					</para></listitem>
					
					<listitem><para>
					No underscores 
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example:
				<programlisting>
				</programlisting>
				</para>
				
				<para>
					<title>Use of Namespaces</title>
				</para>
				<para>
				Use namespaces to group a large collection of classes, typedefs, etc together, to more clearly identify 
				the classes. Use namespaces in place of class prefixes or function prefixes. For example instead of the 
				classes PDQFileDialog,  PDQDumper, and PDQBigStuff, create a namespace called PDQ and 
				rename the classes to FileDialog, Dumper, and BigStuff, and place them inside of the PDQ namespace.
				<itemizedlist>
					<listitem><para>
					Pascal casing
					</para></listitem>

					<listitem><para>
					Abbreviations are OK for namespaces 
					</para></listitem>
					
					<listitem><para>
					No underscores 
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Example:
				<programlisting>
				</programlisting>
				</para>
				
				
				<para>
					<title>Use of static class methods/members</title>
				</para>
				<para>
				see Function naming and Member function naming above with the following restrictions:
				<itemizedlist>
					<listitem><para>
					<emphasis>No</emphasis> underscores at all  
					</para></listitem>
				</itemizedlist>
				All static members must always be referenced with the class name that they are part of, 
				never just by themselves, or by a class instance.
				</para>
				<para>
				Example:
				<programlisting>
//declaration:
class Foo {
public:
static String commonBarRepository;
};

//initialization:
String Foo::commonBarRepository = "some useful initial value";

//usage:

//OK
String s = Foo::commonBarRepository;

//Unacceptable, even with the scope of class Foo
String s = commonBarRepository;

//Also unacceptable
Foo f;
String s = f.commonBarRepository;					
				</programlisting>
				</para>
				
				<para>
					<title>Comments</title>
				</para>
				<para>
				The standard comment style used in the VCF is comparable to what is used in Java, i.e. the 
				<programlisting>
/**
*/
				</programlisting>
				style.
				</para>
				<para>
				Headers with the following should be documented 
				<itemizedlist>
					<listitem><para>
					Namespaces 
					</para></listitem>

					<listitem><para>
					Structs 
					</para></listitem>
					
					<listitem><para>
					Unions 
					</para></listitem>
					
					<listitem><para>
					Classes 
					</para></listitem>
					
					<listitem><para>
					Class/Struct/Union members (semi optional depending on what it is andhow clear the name is) 
					</para></listitem>
					
					<listitem><para>
					Class methods 
					</para></listitem>
					
					<listitem><para>
					Enums 
					</para></listitem>
					
					<listitem><para>
					Functions 
					</para></listitem>
					
					<listitem><para>
					custom #defines 
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				The rationale for this is to allow for automatic source level documentation by processing all headers 
				through doxygen. Document the headers. Document your classes. More documentation is better that 
				no documentation. Be as clear and concise as possible in explaining what something does. You can 
				and should use html markup tags for further clarity, for example the &lt;B&gt; tag to emphasize some point 
				or word. Also where applicable, feel free to put a sample piece of code that illustrates proper usage. 
				Use the &lt;PRE&gt; tags for this. 
				</para>
				<para>
				Do not pollute the code, particularly the headers, with tons of "//" spacers a-la what Microsoft's 
				Visual C++ generated code for classes does. Keep it clean.
				</para>
				<para>
				For single line comments line comments you can use the "//" but it still prefered that you use the
				<programlisting>
/**
comment
*/
				</programlisting>
				style.
				</para>
				<para>
				Use the @param, @return, @author, and @version to further clarify what paramaters/arguments 
				and return values do, as well as the author and version of the item in question.The @version should be 
				the current cvs version that you are working under. If you are not entirely sure what these do, look 
				them up in JavaDoc (which is where they are from). 
				</para>
				<para>
				Example:
				<programlisting>
/**
This is what the method does...
@param void* this parameter is for....
@param bool this parameter indicates....
@param String the name of.....
@return int the return value is...
@author Jim Bob Snake
@version 0.5.9
*/
int myCoolMethod( void* d, bool b, String s );					
				</programlisting>
				</para>
			</section>
			
			<section><title>Documentation Standards</title>
			</section>			
		</section>
	</section>
	
	<section><title>Bugs</title>
	<para>
	Bugs, bugs, bugs - the bane of every developer and project. Naturally the VCF has no bugs so we have nothing to 
	worry about. And if you believe that, I have some real estate in Florida I'd like to show you...
	</para>
	<para>
	Seriously bugs do exist in the VCF and should be reported to the 
	<ulink url="http://sourceforge.net/tracker/?group_id=6796&amp;atid=106796">VCF bug tracker</ulink> on 
	Source Forge.
	</para>
	<para>
	Please submit as much information as possible. If you don't do this, it slows the process down, and the sooner the bug is 
	fixed the happier you'll be ! 
	</para>
	<para>
	As a general rule please submit the following information: 
	<itemizedlist>
		<listitem><para>
		Operating System (and service pack, patch, etc if known). Please indicate if you are using non-english version, 
		as well as if you're language requires special input (for example Arabic, Hebrew, and several other languages are 
		read and input differently than English or Romance/Latin based languages).
		</para></listitem>
		
		<listitem><para>
		System RAM 
		</para></listitem>
		
		<listitem><para>
		System CPU - make ( i.e. Intel, AMD ) &amp; speed ( 550 mhz)
		</para></listitem>
		
		<listitem><para>
		Hard drive size 
		</para></listitem>
		
		<listitem><para>
		General Computer make if applicable ( Dell, Compaq, etc) 
		</para></listitem>
		
		<listitem><para>
		What where you doing (if you remember) when the bug occured? In other words, how do we recreate this ?
		</para></listitem>
		
		<listitem><para>
		Please try and rate the bug (in your opinion). Is it cosmetic, does it affect usability, does it cause your computer to 
		ignite in flames (this one tends to be a serious bug).
		</para></listitem>
		
		<listitem><para>
		Is there an email address we can use to contact you if we need more information? Note this is 
		<emphasis>totally</emphasis> optional, the emails will not be used for spam or anything else.
		</para></listitem>			
	</itemizedlist>
	</para>

	</section>
	
	<section><title>Mailing lists</title>
		<para>
		There is a <ulink url="http://lists.sourceforge.net/lists/listinfo/vcf-development">development 
		mailing list</ulink> that can be subscribed to. There are also forums, which are what we are encouraging people to
		use as well.
		</para>
	</section>
	
	<section><title>Forums</title>
		<para>
			There are <ulink url="">forums</ulink> covering a wide range of topics that everyone is encouraged to 
			visit and participate in. There is also a private developer forum, for VCF registered developers only.
		</para>
	</section>
	
	<section><title>FAQ</title>
		<para>
			To be finished
		</para>
	</section>		
</chapter>
	