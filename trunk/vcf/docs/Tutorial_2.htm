<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:color("21","333333","Custom #3","0") -->
  <!-- $MVD$:color("22","ee4444","Custom #4","0") -->
  <!-- $MVD$:color("23","ffcc99","Custom #5","0") -->
  <!-- $MVD$:color("24","ff6600","Custom #6","0") -->
  <!-- $MVD$:color("25","eeeeee","Custom #7","0") -->
  <!-- $MVD$:color("26","204060","Custom #8","0") -->
  <!-- $MVD$:color("27","80e0","Custom #9","0") -->
  <!-- $MVD$:color("28","206080","Custom #10","0") -->
  <!-- $MVD$:color("29","802000","Custom #11","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>Tutorial 2</TITLE>
  <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK
  REL="StyleSheet" HREF="default.css"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <H1>
   Tutorial 2</H1>
  <P>
   In this tutorial we are going to take our Employee class and add 
   support for dynamic <A HREF="JavaScript:hhctrl.TextPopup('RTTI, or Run Time Type Information allows objects to expose information about themselves at run time to objects that know nothing about the specifc object being queried.','Arial,8',10,10,00000000,0xc0ffff)">RTTI</A>.</P>
  <P>
   There are several ways to add this support, but a set of macros 
   exists that does this for us. Basically all they do is simplify the 
   job of calling the correct registration functions for the various 
   pieces of RTTI. To start with we'll need to declare basic RTTI 
   support, and to do so we'll need a string define that represents <A HREF="JavaScript:hhctrl.TextPopup('A Universally Unique IDentifier that is guaranteed to be unique across computers. In COM this is known as GUID. Commonly used in distributed architectures like CORBA to identify objects or classes.','Arial,8',10,10,00000000,0xc0ffff)">UUID</A> 
   of our class. So, for example, the Employee define would look like this:</P><PRE><SPAN
    STYLE="font-weight : bold;">#define</SPAN> EMPLOYEE_CLASSID <FONT COLOR="RED">&quot;56EAADD3-1BAE-4496-B68A-15A5E450AE8E&quot;</FONT></PRE><P>
   you can get this number by running GUIDGEN.exe (at least on Win32 
   systems ).</P>
  <P>
   Next lets add the first macros:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     BEGIN_CLASSINFO(Employee, <FONT
    COLOR="RED">&quot;Employee&quot;</FONT>, <FONT COLOR="RED">&quot;VCF::Object&quot;</FONT>, EMPLOYEE_CLASSID)<BR>     END_CLASSINFO(Employee)<BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR>     ...rest of code omitted....<BR>};</PRE><P>
   The Employee class now has the basic RTTI which includes a class name 
   (&quot;Employee&quot;), information about the super class (the 
   primary class it derives from, which in this case is VCF::Object), 
   and a class id, as defined by the string EMPLOYEE_CLASSID. So, you 
   may be asking, what does this really give us ? Well lets take a look 
   at some sample code to find out:</P><PRE><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">1</SPAN></FONT> <SPAN STYLE="font-weight : bold;">int</SPAN> main()<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">2</FONT></SPAN> {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN>     initFoundationKit();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">4</FONT></SPAN>     REGISTER_CLASSINFO( Employee );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">5</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">6</FONT></SPAN>     Object* obj = NULL;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">7</FONT></SPAN>     ClassRegistry::getClassRegistry()-&gt;createNewInstance( <FONT COLOR="RED">&quot;Employee&quot;</FONT>, &amp;obj );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">8</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">9</FONT></SPAN>     Class* clazz = obj-&gt;getClass();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">10</FONT></SPAN>    String className = clazz-&gt;getClassName();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">11</FONT></SPAN>    String uuidString = clazz-&gt;getID();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">12</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">13</FONT></SPAN>    Class* superClass = clazz-&gt;getSuperClass();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">14</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">15</FONT></SPAN>    String superClassName = superClass-&gt;getClassName();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">16</FONT></SPAN>    <SPAN STYLE="font-weight : bold;">while</SPAN> ( NULL != superClass ){<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">17</FONT></SPAN>         superClass = superClass-&gt;getSuperClass();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">18</FONT></SPAN>    }<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">19</FONT></SPAN><BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">20</SPAN></FONT>    <SPAN STYLE="font-weight : bold;">return</SPAN> <FONT COLOR="FUCHSIA">0</FONT>;<BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">21</SPAN></FONT> }</PRE><P>
   Line 3 initializes the FoundationKit library. The next registers the 
   Employee class with the ClassRegistry. The ClassRegistry is a single 
   instance that keeps track of all the registered classes. It has a 
   static method that allows you to retrieve it's global instance called 
   getClassRegistry(). Once we have this we can create a new instance of 
   our Employee class on the fly by passing in the name of the class we 
   want to create (&quot;Employee&quot;), and a pointer to an Object* 
   variable (obj). <SPAN STYLE="font-style : italic;font-weight : bold;">Note:
    </SPAN>When defining your class remember that you must have a 
   constructor defined that either take no arguments, or arguments that 
   all have default values specified. Dynamic object creation is useful 
   in all sorts of ways, for example, you might have a file that 
   contains a list of objects, with the class name of the object 
   followed by it's data. Then when you read the file in, you could 
   dynamically create the object's with very simple and generic code by 
   getting the class name of the objects and calling createNewInstance().</P>
  <P>
   Once we have our Employee instance we can retrieve it's Class. A 
   Class is a special object in the VCF that is basic building block of 
   the VCF RTTI. Once you have access to a Class instance, you can query 
   it for a variety of different information, such as the above example 
   does. We can ask for the name of the class using getClassName() (line 
   10 ), get the UUID through the getID() method, and get the super 
   class's Class using getSuperClass(). To walk the list of derived 
   classes we can execute a loop similar to what is found in line 16.</P>
  <P>
   So, as you can see, with just a few lines added to our class we get a 
   significant amount of extra functionality.</P>
  <P>
   The next thing we'll add is support for properties. A Property is a 
   special class that can get or set a value on a specific instance of 
   an Object at run time. It allows us to describe a class's data 
   members and provides access to them in a uniform and generic manner, 
   all of which can be determined dynamically at runtime, with no 
   knowledge of the particular object's class definition. One example of 
   how you might use this is to write a generic persistence mechanism 
   that saves and loads the state of a collection of different objects 
   entirely through the use of properties. Another might be in a 
   database program that dynamically generates SQL code based on the 
   properties of an object.</P>
  <P>
   Again, there are a variety of ways to do this with a class, but the 
   easiest is through the use of macros that the VCF provides, which 
   correctly register the class's methods with the ClassRegistry. Let's 
   add support for the Employee class's IQ attribute.</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     BEGIN_CLASSINFO(Employee, <FONT
    COLOR="RED">&quot;Employee&quot;</FONT>, <FONT COLOR="RED">&quot;VCF::Object&quot;</FONT>, EMPLOYEE_CLASSID)<BR>     PROPERTY( <SPAN
    STYLE="font-weight : bold;">int</SPAN>, <FONT COLOR="RED">&quot;IQ&quot;</FONT>, Employee::getIQ, Employee::setIQ, PROP_INT );<BR>     END_CLASSINFO(Employee)<BR><BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR><SPAN
    STYLE="font-weight : bold;">     int</SPAN> getIQ();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> setIQ( <SPAN STYLE="font-weight : bold;">const</SPAN> <SPAN STYLE="font-weight : bold;">int</SPAN>&amp; IQ );<BR><BR></PRE><PRE>     ...rest of code omitted....<BR><SPAN
    STYLE="font-weight : bold;">protected</SPAN>:<BR>     <SPAN
    STYLE="font-weight : bold;">int</SPAN> m_age;<BR><BR>     ...rest of code omitted....<BR>};</PRE><P>
   So, as you can see, the simple adddition of a property can be 
   accomplished through the PROPERTY macro, and specifying the 
   apropriate parameters. Let's quickly run through what the parameters 
   are and then we'll see what this actually gives you.</P>
  <P>
   The first parameter is the C++ primitive type, i.e. <SPAN STYLE="font-weight : bold;">int</SPAN>,
    <SPAN STYLE="font-weight : bold;">double</SPAN>, <SPAN STYLE="font-weight : bold;">float</SPAN>,
    etc. The next parameter is the string name of the property. The 
   naming convention of the VCF is to use the property name (such as 
   &quot;IQ&quot;) and then specify get and set functions in the form 
   &quot;get&quot; + property name, and &quot;set&quot; + property name 
   (thus the getIQ() and setIQ() functions). The next two parameters we 
   need to specify are the function pointers to the get and set 
   functions of the specific property. Please note how they are 
   specified: Class name, followed by the double colon and then the 
   function itself. The last parameter is the enum type that identifies 
   the C++ type to it's corresponding VCF property type.</P>
  <P>
   So now that we have this let's look at some sample code to see just 
   what we can do with these properties!</P><PRE><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">1</SPAN></FONT> <SPAN STYLE="font-weight : bold;">int</SPAN> main()<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">2</FONT></SPAN> {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN>     initFoundationKit();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">4</FONT></SPAN>     REGISTER_CLASSINFO( Employee );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">5</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">6</FONT></SPAN>     Object* obj = NULL;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">7</FONT></SPAN>     ClassRegistry::getClassRegistry()-&gt;createNewInstance( <FONT COLOR="RED">&quot;Employee&quot;</FONT>, &amp;obj );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">8</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">9</FONT></SPAN>     Class* clazz = obj-&gt;getClass();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">10</FONT></SPAN>    Enumerator&lt;Property*&gt;* properties = clazz-&gt;getProperties();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">11</FONT></SPAN>    if ( NULL != properties ) {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">12</FONT></SPAN>        while ( true == properties-&gt;hasMoreElements() ) {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">13</FONT></SPAN>            Property* property = properties-&gt;nextElement();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">14</FONT></SPAN>            if ( NULL != property ) {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">15</FONT></SPAN>                VariantData* propValue = property-&gt;get();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">16</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">17</FONT></SPAN>                String stringVal = propValue-&gt;toString();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">18</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">19</FONT></SPAN>                std::cout &lt;&lt; stringVal &lt;&lt; std::endl;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">20</FONT></SPAN>                <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">21</FONT></SPAN>                std::cout &lt;&lt; property-&gt;getName() &lt;&lt; std::endl;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">22</FONT></SPAN>            }<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">23</FONT></SPAN>        } <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">24</FONT></SPAN>    }<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">25</FONT></SPAN>    Property* propIQ = clazz-&gt;getProperty( &quot;IQ&quot; );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">26</FONT></SPAN>    if ( NULL != propIQ ) {<BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">27</SPAN></FONT>        propIQ-&gt;set( &quot;200&quot; );<BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">2</SPAN></FONT><SPAN STYLE="font-weight : bold;"><FONT COLOR="GRAY">8</FONT></SPAN><BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">29</SPAN></FONT>        VariantData newVal;<BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">30</SPAN></FONT>        newVal = 50;<BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">31</SPAN></FONT>                <BR><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">32</SPAN></FONT>        propIQ-&gt;set( &amp;newVal );            <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">33</FONT></SPAN>    }   <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">34</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">35</FONT></SPAN>    <SPAN STYLE="font-weight : bold;">return</SPAN> <FONT COLOR="FUCHSIA">0</FONT>;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">36</FONT></SPAN> }</PRE><P>
   Similar to the previous demo, lines 1-9 create a new instance of an 
   Employee and then retrieve a pointer to it's Class. Line 10 may need 
   a bit of explaining though. You'll notice that the properties 
   variable is a pointer to a templated class called an <SPAN STYLE="font-weight : normal;">Enumerator</SPAN>,
    with the class type specified as Property*. The Enumerator class 
   basically provides a &quot;mask&quot; around the various STL 
   collection iterators, allowing the developer to iteratively walk the 
   collection forwards or backwards, and to determine whether or not the 
   end (or begining) has been reached. This hides the actual collection 
   implementation, whether it be a vector, list, or map (or 
   theoretically any collection whose iterator supports ++ and -- 
   operators). Those of you who are familiar with Java will recognive 
   the interface from Iterator. So we loop till our properties 
   enumerator has no more elements, each time calling nextElement() to 
   return the next Property pointer in the enumeration. Once we have the 
   property (line 13) we can retrieve it's value by calling get() on the 
   property (line 15). This returns us a VariantData pointer, which is 
   discussed in more depth in the <A HREF="Variable_Data_Types.htm">RTTI section</A>,
    but simply put, allows us to dynamically assign and retreive a wide 
   variety of different data types through a single object. We can print 
   out the value of the property by calling the VariantData's toString() 
   function. To obtain the name of the property we can call it's 
   getName() method, as seen in line 21.</P>
  <P>
   An alternate way to get a property, if we are looking for a specific 
   one, is to call the Class's getProperty() method, passing in the name 
   of the property we wish to search for, in this case we are looking 
   for a property named &quot;IQ&quot; (line 25). If the search is 
   succesful we are returned a pointer to a property, otherwise we get a 
   NULL pointer back.</P>
  <P>
   To set a value on the property we can call the set() method, either 
   passing in a string value (as in line 27), or a pointer to a 
   VariantData. In our example above we pass in the string 
   &quot;200&quot; which is automatically translated into the correct 
   type if possible (in this case it will be translated into an <SPAN STYLE="font-weight : bold;">int</SPAN>),
    and then a VariantData set to the integer value 50.</P>
  <P>
   So, as you can see, the simple of addition of the PROPERTY macro to 
   your class definition gives you a great deal of additional power and 
   flexibility at runtime. The ability to dynamically query for an 
   objects properties at runtime, and to discover information about 
   their types, names, and setting and retreiving data from the property 
   are all extremely useful features, and allows the VCF to perform many 
   things that it would otherwise be unable to do.</P>
  <P>
   In addition to the PROPERTY macro there are other macros as well. We 
   won't cover their usage here, but briefly, they allow you to specify 
   that a property is a read only property, and to specify that a 
   property's data type is an Object derived type (which need to handled 
   a bit differently internally in the VCF, but otherwise the usage of 
   the dynamic properties are the same), and to support collections of 
   data. For more on this please see the <A HREF="Properties.htm">Properties</A> topic.</P>
  <P>
   So, we've added RTTI, now lets move on to the next exciting tutorial 
   where we'll add the ability for our Employee class to fire events!
 <OBJECT
 CLASSID="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11"
 ID="hhctrl"
    WIDTH="0"
    HEIGHT="0"
    BORDER="0"
    VSPACE="0"
    HSPACE="0" TYPE="application/x-oleobject">
 </OBJECT></BODY>
</HTML>