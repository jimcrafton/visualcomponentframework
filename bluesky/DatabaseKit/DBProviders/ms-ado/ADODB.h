//
// Generated by tlb2h for Comet 1 beta 31 (20040926)
//

#ifndef COMET_TYPELIB_ADODB_INCLUDED
#define COMET_TYPELIB_ADODB_INCLUDED

#pragma pack(push, 8)

#include "thirdparty/win32/comet/config.h"
#if COMET_BUILD != 20040926
#error This header was generated with a different version of tlb2h. Please rebuild
#endif

#include "thirdparty/win32/comet/assert.h"
#include "thirdparty/win32/comet/ptr.h"
#include "thirdparty/win32/comet/util.h"
#include "thirdparty/win32/comet/uuid.h"
#include "thirdparty/win32/comet/common.h"
#include "thirdparty/win32/comet/bstr.h"
#include "thirdparty/win32/comet/cp.h"
#include "thirdparty/win32/comet/cptraits.h"
#include "thirdparty/win32/comet/tstring.h"
#include "thirdparty/win32/comet/variant.h"
#include <list>

#include "thirdparty/win32/comet/server.h"

namespace comet {

namespace ADODB {

// VC workaround. (sigh!)
struct DECLSPEC_UUID("00000200-0000-0010-8000-00AA006D2EA4") ADODB_type_library;
typedef ADODB_type_library type_library;

//
// Forward references and typedefs
//

struct DECLSPEC_UUID("00000517-0000-0010-8000-00AA006D2EA4") ADOCommandConstruction;
struct DECLSPEC_UUID("00000551-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction;
struct DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction15;
struct DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4") ADORecordsetConstruction;
struct DECLSPEC_UUID("00000400-0000-0010-8000-00AA006D2EA4") ConnectionEvents;
struct DECLSPEC_UUID("00000402-0000-0010-8000-00AA006D2EA4") ConnectionEventsVt;
struct DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4") Error;
struct DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4") Errors;
struct DECLSPEC_UUID("0000054C-0000-0010-8000-00AA006D2EA4") Field;
struct DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4") Field15;
struct DECLSPEC_UUID("0000054D-0000-0010-8000-00AA006D2EA4") Fields;
struct DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4") Fields15;
struct DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4") Parameters;
struct DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4") Properties;
struct DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4") Property;
struct DECLSPEC_UUID("00000266-0000-0010-8000-00AA006D2EA4") RecordsetEvents;
struct DECLSPEC_UUID("00000403-0000-0010-8000-00AA006D2EA4") RecordsetEventsVt;
struct DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4") _ADO;
struct DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4") _Collection;
struct DECLSPEC_UUID("0000054E-0000-0010-8000-00AA006D2EA4") _Command;
struct DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4") _Command15;
struct DECLSPEC_UUID("00000550-0000-0010-8000-00AA006D2EA4") _Connection;
struct DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4") _Connection15;
struct DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4") _DynaCollection;
struct DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4") _Parameter;
struct DECLSPEC_UUID("0000054F-0000-0010-8000-00AA006D2EA4") _Recordset;
struct DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4") _Recordset15;

//
// Interface typedefs
//

typedef com_ptr<ADOCommandConstruction> ADOCommandConstructionPtr;
typedef com_ptr<ADOConnectionConstruction> ADOConnectionConstructionPtr;
typedef com_ptr<ADOConnectionConstruction15> ADOConnectionConstruction15Ptr;
typedef com_ptr<ADORecordsetConstruction> ADORecordsetConstructionPtr;
typedef com_ptr<ConnectionEvents> ConnectionEventsPtr;
typedef com_ptr<ConnectionEventsVt> ConnectionEventsVtPtr;
typedef com_ptr<Error> ErrorPtr;
typedef com_ptr<Errors> ErrorsPtr;
typedef com_ptr<Field> FieldPtr;
typedef com_ptr<Field15> Field15Ptr;
typedef com_ptr<Fields> FieldsPtr;
typedef com_ptr<Fields15> Fields15Ptr;
typedef com_ptr<Parameters> ParametersPtr;
typedef com_ptr<Properties> PropertiesPtr;
typedef com_ptr<Property> PropertyPtr;
typedef com_ptr<RecordsetEvents> RecordsetEventsPtr;
typedef com_ptr<RecordsetEventsVt> RecordsetEventsVtPtr;
typedef com_ptr<_ADO> _ADOPtr;
typedef com_ptr<_Collection> _CollectionPtr;
typedef com_ptr<_Command> _CommandPtr;
typedef com_ptr<_Command15> _Command15Ptr;
typedef com_ptr<_Connection> _ConnectionPtr;
typedef com_ptr<_Connection15> _Connection15Ptr;
typedef com_ptr<_DynaCollection> _DynaCollectionPtr;
typedef com_ptr<_Parameter> _ParameterPtr;
typedef com_ptr<_Recordset> _RecordsetPtr;
typedef com_ptr<_Recordset15> _Recordset15Ptr;

//
// Impl Wrappers (forward declaration)
//

template<typename _B, typename _S = ADOCommandConstruction, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000517-0000-0010-8000-00AA006D2EA4") ADOCommandConstructionImpl;

template<typename _B, typename _S = ADOConnectionConstruction, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000551-0000-0010-8000-00AA006D2EA4") ADOConnectionConstructionImpl;

template<typename _B, typename _S = ADOConnectionConstruction15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction15Impl;

template<typename _B, typename _S = ADORecordsetConstruction, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4") ADORecordsetConstructionImpl;

template<typename _B, typename _S = ConnectionEvents, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000400-0000-0010-8000-00AA006D2EA4") ConnectionEventsImpl;

template<typename _B, typename _S = ConnectionEventsVt, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000402-0000-0010-8000-00AA006D2EA4") ConnectionEventsVtImpl;

template<typename _B, typename _S = Error, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4") ErrorImpl;

template<typename _B, typename _S = Errors, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4") ErrorsImpl;

template<typename _B, typename _S = Field, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054C-0000-0010-8000-00AA006D2EA4") FieldImpl;

template<typename _B, typename _S = Field15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4") Field15Impl;

template<typename _B, typename _S = Fields, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054D-0000-0010-8000-00AA006D2EA4") FieldsImpl;

template<typename _B, typename _S = Fields15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4") Fields15Impl;

template<typename _B, typename _S = Parameters, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4") ParametersImpl;

template<typename _B, typename _S = Properties, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4") PropertiesImpl;

template<typename _B, typename _S = Property, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4") PropertyImpl;

template<typename _B, typename _S = RecordsetEvents, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000266-0000-0010-8000-00AA006D2EA4") RecordsetEventsImpl;

template<typename _B, typename _S = RecordsetEventsVt, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000403-0000-0010-8000-00AA006D2EA4") RecordsetEventsVtImpl;

template<typename _B, typename _S = _ADO, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4") _ADOImpl;

template<typename _B, typename _S = _Collection, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4") _CollectionImpl;

template<typename _B, typename _S = _Command, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054E-0000-0010-8000-00AA006D2EA4") _CommandImpl;

template<typename _B, typename _S = _Command15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4") _Command15Impl;

template<typename _B, typename _S = _Connection, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000550-0000-0010-8000-00AA006D2EA4") _ConnectionImpl;

template<typename _B, typename _S = _Connection15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4") _Connection15Impl;

template<typename _B, typename _S = _DynaCollection, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4") _DynaCollectionImpl;

template<typename _B, typename _S = _Parameter, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4") _ParameterImpl;

template<typename _B, typename _S = _Recordset, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054F-0000-0010-8000-00AA006D2EA4") _RecordsetImpl;

template<typename _B, typename _S = _Recordset15, typename _TL = ADODB_type_library >
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4") _Recordset15Impl;

//
// Coclass definitions
//

struct DECLSPEC_UUID("00000514-0000-0010-8000-00AA006D2EA4") Connection {
    typedef  make_list<_Connection>::result  interfaces;
    typedef  make_list<ConnectionEvents>::result  source_interfaces;
    typedef  make_list<_ConnectionImpl< coclass_implementation<Connection> , _Connection, ADODB_type_library > , implement_cpc<  source_interfaces > >::result interface_impls;
    typedef ADODB_type_library type_library;
    static const TCHAR* name() { return _T("Connection"); }
    enum { major_version = 0, minor_version = 0 };
    static com_ptr<_Connection> create() {return com_ptr<_Connection>(uuidof<Connection>()); };
};

struct DECLSPEC_UUID("00000507-0000-0010-8000-00AA006D2EA4") Command {
    typedef  make_list<_Command>::result  interfaces;
    typedef  make_list<>::result  source_interfaces;
    typedef  make_list<_CommandImpl< coclass_implementation<Command> , _Command, ADODB_type_library > >::result interface_impls;
    typedef ADODB_type_library type_library;
    static const TCHAR* name() { return _T("Command"); }
    enum { major_version = 0, minor_version = 0 };
    static com_ptr<_Command> create() {return com_ptr<_Command>(uuidof<Command>()); };
};

struct DECLSPEC_UUID("00000535-0000-0010-8000-00AA006D2EA4") Recordset {
    typedef  make_list<_Recordset>::result  interfaces;
    typedef  make_list<RecordsetEvents>::result  source_interfaces;
    typedef  make_list<_RecordsetImpl< coclass_implementation<Recordset> , _Recordset, ADODB_type_library > , implement_cpc<  source_interfaces > >::result interface_impls;
    typedef ADODB_type_library type_library;
    static const TCHAR* name() { return _T("Recordset"); }
    enum { major_version = 0, minor_version = 0 };
    static com_ptr<_Recordset> create() {return com_ptr<_Recordset>(uuidof<Recordset>()); };
};

struct DECLSPEC_UUID("0000050B-0000-0010-8000-00AA006D2EA4") Parameter {
    typedef  make_list<_Parameter>::result  interfaces;
    typedef  make_list<>::result  source_interfaces;
    typedef  make_list<_ParameterImpl< coclass_implementation<Parameter> , _Parameter, ADODB_type_library > >::result interface_impls;
    typedef ADODB_type_library type_library;
    static const TCHAR* name() { return _T("Parameter"); }
    enum { major_version = 0, minor_version = 0 };
    static com_ptr<_Parameter> create() {return com_ptr<_Parameter>(uuidof<Parameter>()); };
};


struct ADODB_type_library {
    enum { major_version = 2, minor_version = 0 };
    typedef  make_list<Connection, Command, Recordset, Parameter>::result  coclasses;
};

} // namespace

//
// Named GUIDs
//

template<> struct comtype<ADODB::ADODB_type_library> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000200, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<ADODB::Connection> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000514, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<ADODB::Command> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000507, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<ADODB::Recordset> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000535, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<ADODB::Parameter> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000050B, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef nil base;
};

template<> struct comtype<ADODB::ADOCommandConstruction> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000517, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IUnknown base;
    template<typename B> struct implementation {
        typedef ADODB::ADOCommandConstructionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::ADOConnectionConstruction> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000551, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::ADOConnectionConstruction15 base;
    template<typename B> struct implementation {
        typedef ADODB::ADOConnectionConstructionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::ADOConnectionConstruction15> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000516, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IUnknown base;
    template<typename B> struct implementation {
        typedef ADODB::ADOConnectionConstruction15Impl<B> normal;
    };
};

template<> struct comtype<ADODB::ADORecordsetConstruction> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000283, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::ADORecordsetConstructionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::ConnectionEvents> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000400, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::ConnectionEventsImpl<B> normal;
    };
};

template<> struct comtype<ADODB::ConnectionEventsVt> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000402, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IUnknown base;
    template<typename B> struct implementation {
        typedef ADODB::ConnectionEventsVtImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Error> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000500, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::ErrorImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Errors> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000501, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Collection base;
    template<typename B> struct implementation {
        typedef ADODB::ErrorsImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Field> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000054C, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::FieldImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Field15> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000505, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::Field15Impl<B> normal;
    };
};

template<> struct comtype<ADODB::Fields> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000054D, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::Fields15 base;
    template<typename B> struct implementation {
        typedef ADODB::FieldsImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Fields15> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000506, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Collection base;
    template<typename B> struct implementation {
        typedef ADODB::Fields15Impl<B> normal;
    };
};

template<> struct comtype<ADODB::Parameters> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000050D, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_DynaCollection base;
    template<typename B> struct implementation {
        typedef ADODB::ParametersImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Properties> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000504, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Collection base;
    template<typename B> struct implementation {
        typedef ADODB::PropertiesImpl<B> normal;
    };
};

template<> struct comtype<ADODB::Property> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000503, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::PropertyImpl<B> normal;
    };
};

template<> struct comtype<ADODB::RecordsetEvents> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000266, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::RecordsetEventsImpl<B> normal;
    };
};

template<> struct comtype<ADODB::RecordsetEventsVt> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000403, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IUnknown base;
    template<typename B> struct implementation {
        typedef ADODB::RecordsetEventsVtImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_ADO> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000534, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::_ADOImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Collection> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000512, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ::IDispatch base;
    template<typename B> struct implementation {
        typedef ADODB::_CollectionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Command> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000054E, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Command15 base;
    template<typename B> struct implementation {
        typedef ADODB::_CommandImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Command15> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000508, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::_Command15Impl<B> normal;
    };
};

template<> struct comtype<ADODB::_Connection> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000550, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Connection15 base;
    template<typename B> struct implementation {
        typedef ADODB::_ConnectionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Connection15> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000515, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::_Connection15Impl<B> normal;
    };
};

template<> struct comtype<ADODB::_DynaCollection> {
    static const IID& uuid()
    { static const GUID iid = { 0x00000513, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Collection base;
    template<typename B> struct implementation {
        typedef ADODB::_DynaCollectionImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Parameter> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000050C, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::_ParameterImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Recordset> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000054F, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_Recordset15 base;
    template<typename B> struct implementation {
        typedef ADODB::_RecordsetImpl<B> normal;
    };
};

template<> struct comtype<ADODB::_Recordset15> {
    static const IID& uuid()
    { static const GUID iid = { 0x0000050E, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xAA, 0x00, 0x6D, 0x2E, 0xA4 } }; return iid; }
    typedef ADODB::_ADO base;
    template<typename B> struct implementation {
        typedef ADODB::_Recordset15Impl<B> normal;
    };
};



namespace ADODB {

//
// Enum declarations
//

enum CursorTypeEnum {
    adOpenUnspecified = 4294967295,
    adOpenForwardOnly = 0,
    adOpenKeyset = 1,
    adOpenDynamic = 2,
    adOpenStatic = 3
};

enum CursorOptionEnum {
    adHoldRecords = 256,
    adMovePrevious = 512,
    adAddNew = 16778240,
    adDelete = 16779264,
    adUpdate = 16809984,
    adBookmark = 8192,
    adApproxPosition = 16384,
    adUpdateBatch = 65536,
    adResync = 131072,
    adNotify = 262144,
    adFind = 524288
};

enum LockTypeEnum {
    adLockUnspecified = 4294967295,
    adLockReadOnly = 1,
    adLockPessimistic = 2,
    adLockOptimistic = 3,
    adLockBatchOptimistic = 4
};

enum ExecuteOptionEnum {
    adOptionUnspecified = 4294967295,
    adAsyncExecute = 16,
    adAsyncFetch = 32,
    adAsyncFetchNonBlocking = 64,
    adExecuteNoRecords = 128
};

enum ConnectOptionEnum {
    adConnectUnspecified = 4294967295,
    adAsyncConnect = 16
};

enum ObjectStateEnum {
    adStateClosed = 0,
    adStateOpen = 1,
    adStateConnecting = 2,
    adStateExecuting = 4,
    adStateFetching = 8
};

enum CursorLocationEnum {
    adUseNone = 1,
    adUseServer = 2,
    adUseClient = 3,
    adUseClientBatch = 3
};

enum DataTypeEnum {
    adEmpty = 0,
    adTinyInt = 16,
    adSmallInt = 2,
    adInteger = 3,
    adBigInt = 20,
    adUnsignedTinyInt = 17,
    adUnsignedSmallInt = 18,
    adUnsignedInt = 19,
    adUnsignedBigInt = 21,
    adSingle = 4,
    adDouble = 5,
    adCurrency = 6,
    adDecimal = 14,
    adNumeric = 131,
    adBoolean = 11,
    adError = 10,
    adUserDefined = 132,
    adVariant = 12,
    adIDispatch = 9,
    adIUnknown = 13,
    adGUID = 72,
    adDate = 7,
    adDBDate = 133,
    adDBTime = 134,
    adDBTimeStamp = 135,
    adBSTR = 8,
    adChar = 129,
    adVarChar = 200,
    adLongVarChar = 201,
    adWChar = 130,
    adVarWChar = 202,
    adLongVarWChar = 203,
    adBinary = 128,
    adVarBinary = 204,
    adLongVarBinary = 205,
    adChapter = 136,
    adFileTime = 64,
    adDBFileTime = 137,
    adPropVariant = 138,
    adVarNumeric = 139
};

enum FieldAttributeEnum {
    adFldUnspecified = 4294967295,
    adFldMayDefer = 2,
    adFldUpdatable = 4,
    adFldUnknownUpdatable = 8,
    adFldFixed = 16,
    adFldIsNullable = 32,
    adFldMayBeNull = 64,
    adFldLong = 128,
    adFldRowID = 256,
    adFldRowVersion = 512,
    adFldCacheDeferred = 4096,
    adFldNegativeScale = 16384,
    adFldKeyColumn = 32768
};

enum EditModeEnum {
    adEditNone = 0,
    adEditInProgress = 1,
    adEditAdd = 2,
    adEditDelete = 4
};

enum RecordStatusEnum {
    adRecOK = 0,
    adRecNew = 1,
    adRecModified = 2,
    adRecDeleted = 4,
    adRecUnmodified = 8,
    adRecInvalid = 16,
    adRecMultipleChanges = 64,
    adRecPendingChanges = 128,
    adRecCanceled = 256,
    adRecCantRelease = 1024,
    adRecConcurrencyViolation = 2048,
    adRecIntegrityViolation = 4096,
    adRecMaxChangesExceeded = 8192,
    adRecObjectOpen = 16384,
    adRecOutOfMemory = 32768,
    adRecPermissionDenied = 65536,
    adRecSchemaViolation = 131072,
    adRecDBDeleted = 262144
};

enum GetRowsOptionEnum {
    adGetRowsRest = 4294967295
};

enum PositionEnum {
    adPosUnknown = 4294967295,
    adPosBOF = 4294967294,
    adPosEOF = 4294967293
};

enum BookmarkEnum {
    adBookmarkCurrent = 0,
    adBookmarkFirst = 1,
    adBookmarkLast = 2
};

enum MarshalOptionsEnum {
    adMarshalAll = 0,
    adMarshalModifiedOnly = 1
};

enum AffectEnum {
    adAffectCurrent = 1,
    adAffectGroup = 2,
    adAffectAll = 3,
    adAffectAllChapters = 4
};

enum ResyncEnum {
    adResyncUnderlyingValues = 1,
    adResyncAllValues = 2
};

enum CompareEnum {
    adCompareLessThan = 0,
    adCompareEqual = 1,
    adCompareGreaterThan = 2,
    adCompareNotEqual = 3,
    adCompareNotComparable = 4
};

enum FilterGroupEnum {
    adFilterNone = 0,
    adFilterPendingRecords = 1,
    adFilterAffectedRecords = 2,
    adFilterFetchedRecords = 3,
    adFilterPredicate = 4,
    adFilterConflictingRecords = 5
};

enum SearchDirectionEnum {
    adSearchForward = 1,
    adSearchBackward = 4294967295
};

enum PersistFormatEnum {
    adPersistADTG = 0,
    adPersistXML = 1
};

enum StringFormatEnum {
    adClipString = 2
};

enum ADCPROP_UPDATECRITERIA_ENUM {
    adCriteriaKey = 0,
    adCriteriaAllCols = 1,
    adCriteriaUpdCols = 2,
    adCriteriaTimeStamp = 3
};

enum ADCPROP_ASYNCTHREADPRIORITY_ENUM {
    adPriorityLowest = 1,
    adPriorityBelowNormal = 2,
    adPriorityNormal = 3,
    adPriorityAboveNormal = 4,
    adPriorityHighest = 5
};

enum ConnectPromptEnum {
    adPromptAlways = 1,
    adPromptComplete = 2,
    adPromptCompleteRequired = 3,
    adPromptNever = 4
};

enum ConnectModeEnum {
    adModeUnknown = 0,
    adModeRead = 1,
    adModeWrite = 2,
    adModeReadWrite = 3,
    adModeShareDenyRead = 4,
    adModeShareDenyWrite = 8,
    adModeShareExclusive = 12,
    adModeShareDenyNone = 16
};

enum IsolationLevelEnum {
    adXactUnspecified = 4294967295,
    adXactChaos = 16,
    adXactReadUncommitted = 256,
    adXactBrowse = 256,
    adXactCursorStability = 4096,
    adXactReadCommitted = 4096,
    adXactRepeatableRead = 65536,
    adXactSerializable = 1048576,
    adXactIsolated = 1048576
};

enum XactAttributeEnum {
    adXactCommitRetaining = 131072,
    adXactAbortRetaining = 262144,
    adXactAsyncPhaseOne = 524288,
    adXactSyncPhaseOne = 1048576
};

enum PropertyAttributesEnum {
    adPropNotSupported = 0,
    adPropRequired = 1,
    adPropOptional = 2,
    adPropRead = 512,
    adPropWrite = 1024
};

enum ErrorValueEnum {
    adErrInvalidArgument = 3001,
    adErrNoCurrentRecord = 3021,
    adErrIllegalOperation = 3219,
    adErrInTransaction = 3246,
    adErrFeatureNotAvailable = 3251,
    adErrItemNotFound = 3265,
    adErrObjectInCollection = 3367,
    adErrObjectNotSet = 3420,
    adErrDataConversion = 3421,
    adErrObjectClosed = 3704,
    adErrObjectOpen = 3705,
    adErrProviderNotFound = 3706,
    adErrBoundToCommand = 3707,
    adErrInvalidParamInfo = 3708,
    adErrInvalidConnection = 3709,
    adErrNotReentrant = 3710,
    adErrStillExecuting = 3711,
    adErrOperationCancelled = 3712,
    adErrStillConnecting = 3713,
    adErrNotExecuting = 3715,
    adErrUnsafeOperation = 3716
};

enum ParameterAttributesEnum {
    adParamSigned = 16,
    adParamNullable = 64,
    adParamLong = 128
};

enum ParameterDirectionEnum {
    adParamUnknown = 0,
    adParamInput = 1,
    adParamOutput = 2,
    adParamInputOutput = 3,
    adParamReturnValue = 4
};

enum CommandTypeEnum {
    adCmdUnspecified = 4294967295,
    adCmdUnknown = 8,
    adCmdText = 1,
    adCmdTable = 2,
    adCmdStoredProc = 4,
    adCmdFile = 256,
    adCmdTableDirect = 512
};

enum EventStatusEnum {
    adStatusOK = 1,
    adStatusErrorsOccurred = 2,
    adStatusCantDeny = 3,
    adStatusCancel = 4,
    adStatusUnwantedEvent = 5
};

enum EventReasonEnum {
    adRsnAddNew = 1,
    adRsnDelete = 2,
    adRsnUpdate = 3,
    adRsnUndoUpdate = 4,
    adRsnUndoAddNew = 5,
    adRsnUndoDelete = 6,
    adRsnRequery = 7,
    adRsnResynch = 8,
    adRsnClose = 9,
    adRsnMove = 10,
    adRsnFirstChange = 11,
    adRsnMoveFirst = 12,
    adRsnMoveNext = 13,
    adRsnMovePrevious = 14,
    adRsnMoveLast = 15
};

enum SchemaEnum {
    adSchemaProviderSpecific = 4294967295,
    adSchemaAsserts = 0,
    adSchemaCatalogs = 1,
    adSchemaCharacterSets = 2,
    adSchemaCollations = 3,
    adSchemaColumns = 4,
    adSchemaCheckConstraints = 5,
    adSchemaConstraintColumnUsage = 6,
    adSchemaConstraintTableUsage = 7,
    adSchemaKeyColumnUsage = 8,
    adSchemaReferentialContraints = 9,
    adSchemaTableConstraints = 10,
    adSchemaColumnsDomainUsage = 11,
    adSchemaIndexes = 12,
    adSchemaColumnPrivileges = 13,
    adSchemaTablePrivileges = 14,
    adSchemaUsagePrivileges = 15,
    adSchemaProcedures = 16,
    adSchemaSchemata = 17,
    adSchemaSQLLanguages = 18,
    adSchemaStatistics = 19,
    adSchemaTables = 20,
    adSchemaTranslations = 21,
    adSchemaProviderTypes = 22,
    adSchemaViews = 23,
    adSchemaViewColumnUsage = 24,
    adSchemaViewTableUsage = 25,
    adSchemaProcedureParameters = 26,
    adSchemaForeignKeys = 27,
    adSchemaPrimaryKeys = 28,
    adSchemaProcedureColumns = 29,
    adSchemaDBInfoKeywords = 30,
    adSchemaDBInfoLiterals = 31,
    adSchemaCubes = 32,
    adSchemaDimensions = 33,
    adSchemaHierarchies = 34,
    adSchemaLevels = 35,
    adSchemaMeasures = 36,
    adSchemaProperties = 37,
    adSchemaMembers = 38
};

} // namespace

//
// Enum sa_trait declarations
//

namespace impl {
    template<> struct sa_traits<ADODB::CursorTypeEnum> : public basic_sa_traits<ADODB::CursorTypeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::CursorOptionEnum> : public basic_sa_traits<ADODB::CursorOptionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::LockTypeEnum> : public basic_sa_traits<ADODB::LockTypeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ExecuteOptionEnum> : public basic_sa_traits<ADODB::ExecuteOptionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ConnectOptionEnum> : public basic_sa_traits<ADODB::ConnectOptionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ObjectStateEnum> : public basic_sa_traits<ADODB::ObjectStateEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::CursorLocationEnum> : public basic_sa_traits<ADODB::CursorLocationEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::DataTypeEnum> : public basic_sa_traits<ADODB::DataTypeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::FieldAttributeEnum> : public basic_sa_traits<ADODB::FieldAttributeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::EditModeEnum> : public basic_sa_traits<ADODB::EditModeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::RecordStatusEnum> : public basic_sa_traits<ADODB::RecordStatusEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::GetRowsOptionEnum> : public basic_sa_traits<ADODB::GetRowsOptionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::PositionEnum> : public basic_sa_traits<ADODB::PositionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::BookmarkEnum> : public basic_sa_traits<ADODB::BookmarkEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::MarshalOptionsEnum> : public basic_sa_traits<ADODB::MarshalOptionsEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::AffectEnum> : public basic_sa_traits<ADODB::AffectEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ResyncEnum> : public basic_sa_traits<ADODB::ResyncEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::CompareEnum> : public basic_sa_traits<ADODB::CompareEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::FilterGroupEnum> : public basic_sa_traits<ADODB::FilterGroupEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::SearchDirectionEnum> : public basic_sa_traits<ADODB::SearchDirectionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::PersistFormatEnum> : public basic_sa_traits<ADODB::PersistFormatEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::StringFormatEnum> : public basic_sa_traits<ADODB::StringFormatEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ADCPROP_UPDATECRITERIA_ENUM> : public basic_sa_traits<ADODB::ADCPROP_UPDATECRITERIA_ENUM, VT_I4> {};
    template<> struct sa_traits<ADODB::ADCPROP_ASYNCTHREADPRIORITY_ENUM> : public basic_sa_traits<ADODB::ADCPROP_ASYNCTHREADPRIORITY_ENUM, VT_I4> {};
    template<> struct sa_traits<ADODB::ConnectPromptEnum> : public basic_sa_traits<ADODB::ConnectPromptEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ConnectModeEnum> : public basic_sa_traits<ADODB::ConnectModeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::IsolationLevelEnum> : public basic_sa_traits<ADODB::IsolationLevelEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::XactAttributeEnum> : public basic_sa_traits<ADODB::XactAttributeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::PropertyAttributesEnum> : public basic_sa_traits<ADODB::PropertyAttributesEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ErrorValueEnum> : public basic_sa_traits<ADODB::ErrorValueEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ParameterAttributesEnum> : public basic_sa_traits<ADODB::ParameterAttributesEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::ParameterDirectionEnum> : public basic_sa_traits<ADODB::ParameterDirectionEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::CommandTypeEnum> : public basic_sa_traits<ADODB::CommandTypeEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::EventStatusEnum> : public basic_sa_traits<ADODB::EventStatusEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::EventReasonEnum> : public basic_sa_traits<ADODB::EventReasonEnum, VT_I4> {};
    template<> struct sa_traits<ADODB::SchemaEnum> : public basic_sa_traits<ADODB::SchemaEnum, VT_I4> {};
    template<> struct sa_traits< com_ptr<ADODB::ADOCommandConstruction> > : public interface_sa_traits<ADODB::ADOCommandConstruction, VT_UNKNOWN, FADF_UNKNOWN> {};
    template<> struct sa_traits< com_ptr<ADODB::ADOConnectionConstruction> > : public interface_sa_traits<ADODB::ADOConnectionConstruction, VT_UNKNOWN, FADF_UNKNOWN> {};
    template<> struct sa_traits< com_ptr<ADODB::ADOConnectionConstruction15> > : public interface_sa_traits<ADODB::ADOConnectionConstruction15, VT_UNKNOWN, FADF_UNKNOWN> {};
    template<> struct sa_traits< com_ptr<ADODB::ADORecordsetConstruction> > : public interface_sa_traits<ADODB::ADORecordsetConstruction, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::ConnectionEvents> > : public interface_sa_traits<ADODB::ConnectionEvents, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::ConnectionEventsVt> > : public interface_sa_traits<ADODB::ConnectionEventsVt, VT_UNKNOWN, FADF_UNKNOWN> {};
    template<> struct sa_traits< com_ptr<ADODB::Error> > : public interface_sa_traits<ADODB::Error, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Errors> > : public interface_sa_traits<ADODB::Errors, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Field> > : public interface_sa_traits<ADODB::Field, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Field15> > : public interface_sa_traits<ADODB::Field15, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Fields> > : public interface_sa_traits<ADODB::Fields, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Fields15> > : public interface_sa_traits<ADODB::Fields15, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Parameters> > : public interface_sa_traits<ADODB::Parameters, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Properties> > : public interface_sa_traits<ADODB::Properties, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::Property> > : public interface_sa_traits<ADODB::Property, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::RecordsetEvents> > : public interface_sa_traits<ADODB::RecordsetEvents, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::RecordsetEventsVt> > : public interface_sa_traits<ADODB::RecordsetEventsVt, VT_UNKNOWN, FADF_UNKNOWN> {};
    template<> struct sa_traits< com_ptr<ADODB::_ADO> > : public interface_sa_traits<ADODB::_ADO, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Collection> > : public interface_sa_traits<ADODB::_Collection, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Command> > : public interface_sa_traits<ADODB::_Command, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Command15> > : public interface_sa_traits<ADODB::_Command15, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Connection> > : public interface_sa_traits<ADODB::_Connection, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Connection15> > : public interface_sa_traits<ADODB::_Connection15, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_DynaCollection> > : public interface_sa_traits<ADODB::_DynaCollection, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Parameter> > : public interface_sa_traits<ADODB::_Parameter, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Recordset> > : public interface_sa_traits<ADODB::_Recordset, VT_DISPATCH, FADF_DISPATCH> {};
    template<> struct sa_traits< com_ptr<ADODB::_Recordset15> > : public interface_sa_traits<ADODB::_Recordset15, VT_DISPATCH, FADF_DISPATCH> {};
} // namespace

namespace ADODB {

//
// Typedef declarations
//

typedef enum SearchDirectionEnum SearchDirection;


//
// Interface declarations
//

struct DECLSPEC_UUID("00000517-0000-0010-8000-00AA006D2EA4") ADOCommandConstruction : public ::IUnknown {

    // Raw methods
    virtual STDMETHODIMP get_OLEDBCommand(IUnknown ** par_ppOLEDBCommand) = 0;
    virtual STDMETHODIMP put_OLEDBCommand(IUnknown * par_ppOLEDBCommand) = 0;
};

struct DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction15 : public ::IUnknown {

    // Raw methods
    virtual STDMETHODIMP get_DSO(IUnknown ** par_ppDSO) = 0;
    virtual STDMETHODIMP get_Session(IUnknown ** par_ppSession) = 0;
    virtual STDMETHODIMP raw_WrapDSOandSession(IUnknown * par_pDSO, IUnknown * par_pSession) = 0;
};

struct DECLSPEC_UUID("00000551-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction : public ADOConnectionConstruction15 {
};

struct DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4") ADORecordsetConstruction : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Rowset(IUnknown ** par_ppRowset) = 0;
    virtual STDMETHODIMP put_Rowset(IUnknown * par_ppRowset) = 0;
    virtual STDMETHODIMP get_Chapter(long* par_plChapter) = 0;
    virtual STDMETHODIMP put_Chapter(long par_plChapter) = 0;
    virtual STDMETHODIMP get_RowPosition(IUnknown ** par_ppRowPos) = 0;
    virtual STDMETHODIMP put_RowPosition(IUnknown * par_ppRowPos) = 0;
};

struct DECLSPEC_UUID("00000400-0000-0010-8000-00AA006D2EA4") ConnectionEvents : public ::IDispatch {
};

struct DECLSPEC_UUID("00000402-0000-0010-8000-00AA006D2EA4") ConnectionEventsVt : public ::IUnknown {

    // Raw methods
    virtual STDMETHODIMP raw_InfoMessage(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_BeginTransComplete(long par_TransactionLevel, Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_CommitTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_RollbackTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_WillExecute(BSTR* par_Source, enum CursorTypeEnum* par_CursorType, enum LockTypeEnum* par_LockType, long* par_Options, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_ExecuteComplete(long par_RecordsAffected, Error* par_pError, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_WillConnect(BSTR* par_ConnectionString, BSTR* par_UserID, BSTR* par_Password, long* par_Options, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_ConnectComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
    virtual STDMETHODIMP raw_Disconnect(enum EventStatusEnum* par_adStatus, _Connection* par_pConnection) = 0;
};

struct DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4") Error : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Number(long* par_pl) = 0;
    virtual STDMETHODIMP get_Source(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_Description(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_HelpFile(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_HelpContext(long* par_pl) = 0;
    virtual STDMETHODIMP get_SQLState(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_NativeError(long* par_pl) = 0;
};

struct DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4") _Collection : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Count(long* par_c) = 0;
    virtual STDMETHODIMP raw__NewEnum(IUnknown ** par_ppvObject) = 0;
    virtual STDMETHODIMP raw_Refresh() = 0;
};

struct DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4") Errors : public _Collection {

    // Raw methods
    virtual STDMETHODIMP get_Item(VARIANT par_Index, Error** par_ppvObject) = 0;
    virtual STDMETHODIMP raw_Clear() = 0;
};

struct DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4") _ADO : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Properties(Properties** par_ppvObject) = 0;
};

struct DECLSPEC_UUID("0000054C-0000-0010-8000-00AA006D2EA4") Field : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_ActualSize(long* par_pl) = 0;
    virtual STDMETHODIMP get_Attributes(long* par_pl) = 0;
    virtual STDMETHODIMP get_DefinedSize(long* par_pl) = 0;
    virtual STDMETHODIMP get_Name(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_Type(enum DataTypeEnum* par_pDataType) = 0;
    virtual STDMETHODIMP get_Value(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP put_Value(VARIANT par_pvar) = 0;
    virtual STDMETHODIMP get_Precision(unsigned char* par_pbPrecision) = 0;
    virtual STDMETHODIMP get_NumericScale(unsigned char* par_pbNumericScale) = 0;
    virtual STDMETHODIMP raw_AppendChunk(VARIANT par_Data) = 0;
    virtual STDMETHODIMP raw_GetChunk(long par_Length, VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_OriginalValue(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_UnderlyingValue(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_DataFormat(IUnknown ** par_ppiDF) = 0;
    virtual STDMETHODIMP putref_DataFormat(IUnknown * par_ppiDF) = 0;
    virtual STDMETHODIMP put_Precision(unsigned char par_pbPrecision) = 0;
    virtual STDMETHODIMP put_NumericScale(unsigned char par_pbNumericScale) = 0;
    virtual STDMETHODIMP put_Type(enum DataTypeEnum par_pDataType) = 0;
    virtual STDMETHODIMP put_DefinedSize(long par_pl) = 0;
    virtual STDMETHODIMP put_Attributes(long par_pl) = 0;
};

struct DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4") Field15 : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_ActualSize(long* par_pl) = 0;
    virtual STDMETHODIMP get_Attributes(long* par_pl) = 0;
    virtual STDMETHODIMP get_DefinedSize(long* par_pl) = 0;
    virtual STDMETHODIMP get_Name(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_Type(enum DataTypeEnum* par_pDataType) = 0;
    virtual STDMETHODIMP get_Value(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP put_Value(VARIANT par_pvar) = 0;
    virtual STDMETHODIMP get_Precision(unsigned char* par_pbPrecision) = 0;
    virtual STDMETHODIMP get_NumericScale(unsigned char* par_pbNumericScale) = 0;
    virtual STDMETHODIMP raw_AppendChunk(VARIANT par_Data) = 0;
    virtual STDMETHODIMP raw_GetChunk(long par_Length, VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_OriginalValue(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_UnderlyingValue(VARIANT* par_pvar) = 0;
};

struct DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4") Fields15 : public _Collection {

    // Raw methods
    virtual STDMETHODIMP get_Item(VARIANT par_Index, Field** par_ppvObject) = 0;
};

struct DECLSPEC_UUID("0000054D-0000-0010-8000-00AA006D2EA4") Fields : public Fields15 {

    // Raw methods
    virtual STDMETHODIMP raw_Append(BSTR par_Name, enum DataTypeEnum par_Type, long par_DefinedSize, enum FieldAttributeEnum par_Attrib) = 0;
    virtual STDMETHODIMP raw_Delete(VARIANT par_Index) = 0;
};

struct DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4") _DynaCollection : public _Collection {

    // Raw methods
    virtual STDMETHODIMP raw_Append(IDispatch * par_Object) = 0;
    virtual STDMETHODIMP raw_Delete(VARIANT par_Index) = 0;
};

struct DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4") Parameters : public _DynaCollection {

    // Raw methods
    virtual STDMETHODIMP get_Item(VARIANT par_Index, _Parameter** par_ppvObject) = 0;
};

struct DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4") Properties : public _Collection {

    // Raw methods
    virtual STDMETHODIMP get_Item(VARIANT par_Index, Property** par_ppvObject) = 0;
};

struct DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4") Property : public ::IDispatch {

    // Raw methods
    virtual STDMETHODIMP get_Value(VARIANT* par_pval) = 0;
    virtual STDMETHODIMP put_Value(VARIANT par_pval) = 0;
    virtual STDMETHODIMP get_Name(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP get_Type(enum DataTypeEnum* par_ptype) = 0;
    virtual STDMETHODIMP get_Attributes(long* par_plAttributes) = 0;
    virtual STDMETHODIMP put_Attributes(long par_plAttributes) = 0;
};

struct DECLSPEC_UUID("00000266-0000-0010-8000-00AA006D2EA4") RecordsetEvents : public ::IDispatch {
};

struct DECLSPEC_UUID("00000403-0000-0010-8000-00AA006D2EA4") RecordsetEventsVt : public ::IUnknown {

    // Raw methods
    virtual STDMETHODIMP raw_WillChangeField(long par_cFields, VARIANT par_Fields, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_FieldChangeComplete(long par_cFields, VARIANT par_Fields, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_RecordsetChangeComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_MoveComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_EndOfRecordset(VARIANT_BOOL* par_fMoreData, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
    virtual STDMETHODIMP raw_FetchComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset) = 0;
};

struct DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4") _Command15 : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_ActiveConnection(_Connection** par_ppvObject) = 0;
    virtual STDMETHODIMP putref_ActiveConnection(_Connection* par_ppvObject) = 0;
    virtual STDMETHODIMP put_ActiveConnection(VARIANT par_ppvObject) = 0;
    virtual STDMETHODIMP get_CommandText(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP put_CommandText(BSTR par_pbstr) = 0;
    virtual STDMETHODIMP get_CommandTimeout(long* par_pl) = 0;
    virtual STDMETHODIMP put_CommandTimeout(long par_pl) = 0;
    virtual STDMETHODIMP get_Prepared(VARIANT_BOOL* par_pfPrepared) = 0;
    virtual STDMETHODIMP put_Prepared(VARIANT_BOOL par_pfPrepared) = 0;
    virtual STDMETHODIMP raw_Execute(VARIANT* par_RecordsAffected, VARIANT* par_Parameters, long par_Options, _Recordset** par_ppiRs) = 0;
    virtual STDMETHODIMP raw_CreateParameter(BSTR par_Name, enum DataTypeEnum par_Type, enum ParameterDirectionEnum par_Direction, long par_Size, VARIANT par_Value, _Parameter** par_ppiprm) = 0;
    virtual STDMETHODIMP get_Parameters(Parameters** par_ppvObject) = 0;
    virtual STDMETHODIMP put_CommandType(enum CommandTypeEnum par_plCmdType) = 0;
    virtual STDMETHODIMP get_CommandType(enum CommandTypeEnum* par_plCmdType) = 0;
    virtual STDMETHODIMP get_Name(BSTR* par_pbstrName) = 0;
    virtual STDMETHODIMP put_Name(BSTR par_pbstrName) = 0;
};

struct DECLSPEC_UUID("0000054E-0000-0010-8000-00AA006D2EA4") _Command : public _Command15 {

    // Raw methods
    virtual STDMETHODIMP get_State(long* par_plObjState) = 0;
    virtual STDMETHODIMP raw_Cancel() = 0;
};

struct DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4") _Connection15 : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_ConnectionString(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP put_ConnectionString(BSTR par_pbstr) = 0;
    virtual STDMETHODIMP get_CommandTimeout(long* par_plTimeout) = 0;
    virtual STDMETHODIMP put_CommandTimeout(long par_plTimeout) = 0;
    virtual STDMETHODIMP get_ConnectionTimeout(long* par_plTimeout) = 0;
    virtual STDMETHODIMP put_ConnectionTimeout(long par_plTimeout) = 0;
    virtual STDMETHODIMP get_Version(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP raw_Close() = 0;
    virtual STDMETHODIMP raw_Execute(BSTR par_CommandText, VARIANT* par_RecordsAffected, long par_Options, _Recordset** par_ppiRset) = 0;
    virtual STDMETHODIMP raw_BeginTrans(long* par_TransactionLevel) = 0;
    virtual STDMETHODIMP raw_CommitTrans() = 0;
    virtual STDMETHODIMP raw_RollbackTrans() = 0;
    virtual STDMETHODIMP raw_Open(BSTR par_ConnectionString, BSTR par_UserID, BSTR par_Password, long par_Options) = 0;
    virtual STDMETHODIMP get_Errors(Errors** par_ppvObject) = 0;
    virtual STDMETHODIMP get_DefaultDatabase(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP put_DefaultDatabase(BSTR par_pbstr) = 0;
    virtual STDMETHODIMP get_IsolationLevel(enum IsolationLevelEnum* par_Level) = 0;
    virtual STDMETHODIMP put_IsolationLevel(enum IsolationLevelEnum par_Level) = 0;
    virtual STDMETHODIMP get_Attributes(long* par_plAttr) = 0;
    virtual STDMETHODIMP put_Attributes(long par_plAttr) = 0;
    virtual STDMETHODIMP get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc) = 0;
    virtual STDMETHODIMP put_CursorLocation(enum CursorLocationEnum par_plCursorLoc) = 0;
    virtual STDMETHODIMP get_Mode(enum ConnectModeEnum* par_plMode) = 0;
    virtual STDMETHODIMP put_Mode(enum ConnectModeEnum par_plMode) = 0;
    virtual STDMETHODIMP get_Provider(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP put_Provider(BSTR par_pbstr) = 0;
    virtual STDMETHODIMP get_State(long* par_plObjState) = 0;
    virtual STDMETHODIMP raw_OpenSchema(enum SchemaEnum par_Schema, VARIANT par_Restrictions, VARIANT par_SchemaID, _Recordset** par_pprset) = 0;
};

struct DECLSPEC_UUID("00000550-0000-0010-8000-00AA006D2EA4") _Connection : public _Connection15 {

    // Raw methods
    virtual STDMETHODIMP raw_Cancel() = 0;
};

struct DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4") _Parameter : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_Name(BSTR* par_pbstr) = 0;
    virtual STDMETHODIMP put_Name(BSTR par_pbstr) = 0;
    virtual STDMETHODIMP get_Value(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP put_Value(VARIANT par_pvar) = 0;
    virtual STDMETHODIMP get_Type(enum DataTypeEnum* par_psDataType) = 0;
    virtual STDMETHODIMP put_Type(enum DataTypeEnum par_psDataType) = 0;
    virtual STDMETHODIMP put_Direction(enum ParameterDirectionEnum par_plParmDirection) = 0;
    virtual STDMETHODIMP get_Direction(enum ParameterDirectionEnum* par_plParmDirection) = 0;
    virtual STDMETHODIMP put_Precision(unsigned char par_pbPrecision) = 0;
    virtual STDMETHODIMP get_Precision(unsigned char* par_pbPrecision) = 0;
    virtual STDMETHODIMP put_NumericScale(unsigned char par_pbScale) = 0;
    virtual STDMETHODIMP get_NumericScale(unsigned char* par_pbScale) = 0;
    virtual STDMETHODIMP put_Size(long par_pl) = 0;
    virtual STDMETHODIMP get_Size(long* par_pl) = 0;
    virtual STDMETHODIMP raw_AppendChunk(VARIANT par_Val) = 0;
    virtual STDMETHODIMP get_Attributes(long* par_plParmAttribs) = 0;
    virtual STDMETHODIMP put_Attributes(long par_plParmAttribs) = 0;
};

struct DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4") _Recordset15 : public _ADO {

    // Raw methods
    virtual STDMETHODIMP get_AbsolutePosition(enum PositionEnum* par_pl) = 0;
    virtual STDMETHODIMP put_AbsolutePosition(enum PositionEnum par_pl) = 0;
    virtual STDMETHODIMP putref_ActiveConnection(IDispatch * par_pvar) = 0;
    virtual STDMETHODIMP put_ActiveConnection(VARIANT par_pvar) = 0;
    virtual STDMETHODIMP get_ActiveConnection(VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP get_BOF(VARIANT_BOOL* par_pb) = 0;
    virtual STDMETHODIMP get_Bookmark(VARIANT* par_pvBookmark) = 0;
    virtual STDMETHODIMP put_Bookmark(VARIANT par_pvBookmark) = 0;
    virtual STDMETHODIMP get_CacheSize(long* par_pl) = 0;
    virtual STDMETHODIMP put_CacheSize(long par_pl) = 0;
    virtual STDMETHODIMP get_CursorType(enum CursorTypeEnum* par_plCursorType) = 0;
    virtual STDMETHODIMP put_CursorType(enum CursorTypeEnum par_plCursorType) = 0;
    virtual STDMETHODIMP get_EOF(VARIANT_BOOL* par_pb) = 0;
    virtual STDMETHODIMP get_Fields(Fields** par_ppvObject) = 0;
    virtual STDMETHODIMP get_LockType(enum LockTypeEnum* par_plLockType) = 0;
    virtual STDMETHODIMP put_LockType(enum LockTypeEnum par_plLockType) = 0;
    virtual STDMETHODIMP get_MaxRecords(long* par_plMaxRecords) = 0;
    virtual STDMETHODIMP put_MaxRecords(long par_plMaxRecords) = 0;
    virtual STDMETHODIMP get_RecordCount(long* par_pl) = 0;
    virtual STDMETHODIMP putref_Source(IDispatch * par_pvSource) = 0;
    virtual STDMETHODIMP put_Source(BSTR par_pvSource) = 0;
    virtual STDMETHODIMP get_Source(VARIANT* par_pvSource) = 0;
    virtual STDMETHODIMP raw_AddNew(VARIANT par_FieldList, VARIANT par_Values) = 0;
    virtual STDMETHODIMP raw_CancelUpdate() = 0;
    virtual STDMETHODIMP raw_Close() = 0;
    virtual STDMETHODIMP raw_Delete(enum AffectEnum par_AffectRecords) = 0;
    virtual STDMETHODIMP raw_GetRows(long par_Rows, VARIANT par_Start, VARIANT par_Fields, VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP raw_Move(long par_NumRecords, VARIANT par_Start) = 0;
    virtual STDMETHODIMP raw_MoveNext() = 0;
    virtual STDMETHODIMP raw_MovePrevious() = 0;
    virtual STDMETHODIMP raw_MoveFirst() = 0;
    virtual STDMETHODIMP raw_MoveLast() = 0;
    virtual STDMETHODIMP raw_Open(VARIANT par_Source, VARIANT par_ActiveConnection, enum CursorTypeEnum par_CursorType, enum LockTypeEnum par_LockType, long par_Options) = 0;
    virtual STDMETHODIMP raw_Requery(long par_Options) = 0;
    virtual STDMETHODIMP raw__xResync(enum AffectEnum par_AffectRecords) = 0;
    virtual STDMETHODIMP raw_Update(VARIANT par_Fields, VARIANT par_Values) = 0;
    virtual STDMETHODIMP get_AbsolutePage(enum PositionEnum* par_pl) = 0;
    virtual STDMETHODIMP put_AbsolutePage(enum PositionEnum par_pl) = 0;
    virtual STDMETHODIMP get_EditMode(enum EditModeEnum* par_pl) = 0;
    virtual STDMETHODIMP get_Filter(VARIANT* par_Criteria) = 0;
    virtual STDMETHODIMP put_Filter(VARIANT par_Criteria) = 0;
    virtual STDMETHODIMP get_PageCount(long* par_pl) = 0;
    virtual STDMETHODIMP get_PageSize(long* par_pl) = 0;
    virtual STDMETHODIMP put_PageSize(long par_pl) = 0;
    virtual STDMETHODIMP get_Sort(BSTR* par_Criteria) = 0;
    virtual STDMETHODIMP put_Sort(BSTR par_Criteria) = 0;
    virtual STDMETHODIMP get_Status(long* par_pl) = 0;
    virtual STDMETHODIMP get_State(long* par_plObjState) = 0;
    virtual STDMETHODIMP raw__xClone(_Recordset** par_ppvObject) = 0;
    virtual STDMETHODIMP raw_UpdateBatch(enum AffectEnum par_AffectRecords) = 0;
    virtual STDMETHODIMP raw_CancelBatch(enum AffectEnum par_AffectRecords) = 0;
    virtual STDMETHODIMP get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc) = 0;
    virtual STDMETHODIMP put_CursorLocation(enum CursorLocationEnum par_plCursorLoc) = 0;
    virtual STDMETHODIMP raw_NextRecordset(VARIANT* par_RecordsAffected, _Recordset** par_ppiRs) = 0;
    virtual STDMETHODIMP raw_Supports(enum CursorOptionEnum par_CursorOptions, VARIANT_BOOL* par_pb) = 0;
    virtual STDMETHODIMP get_Collect(VARIANT par_Index, VARIANT* par_pvar) = 0;
    virtual STDMETHODIMP put_Collect(VARIANT par_Index, VARIANT par_pvar) = 0;
    virtual STDMETHODIMP get_MarshalOptions(enum MarshalOptionsEnum* par_peMarshal) = 0;
    virtual STDMETHODIMP put_MarshalOptions(enum MarshalOptionsEnum par_peMarshal) = 0;
    virtual STDMETHODIMP raw_Find(BSTR par_Criteria, long par_SkipRecords, enum SearchDirectionEnum par_SearchDirection, VARIANT par_Start) = 0;
};

struct DECLSPEC_UUID("0000054F-0000-0010-8000-00AA006D2EA4") _Recordset : public _Recordset15 {

    // Raw methods
    virtual STDMETHODIMP raw_Cancel() = 0;
    virtual STDMETHODIMP get_DataSource(IUnknown ** par_ppunkDataSource) = 0;
    virtual STDMETHODIMP putref_DataSource(IUnknown * par_ppunkDataSource) = 0;
    virtual STDMETHODIMP raw_Save(BSTR par_FileName, enum PersistFormatEnum par_PersistFormat) = 0;
    virtual STDMETHODIMP get_ActiveCommand(IDispatch ** par_ppCmd) = 0;
    virtual STDMETHODIMP put_StayInSync(VARIANT_BOOL par_pbStayInSync) = 0;
    virtual STDMETHODIMP get_StayInSync(VARIANT_BOOL* par_pbStayInSync) = 0;
    virtual STDMETHODIMP raw_GetString(enum StringFormatEnum par_StringFormat, long par_NumRows, BSTR par_ColumnDelimeter, BSTR par_RowDelimeter, BSTR par_NullExpr, BSTR* par_pRetString) = 0;
    virtual STDMETHODIMP get_DataMember(BSTR* par_pbstrDataMember) = 0;
    virtual STDMETHODIMP put_DataMember(BSTR par_pbstrDataMember) = 0;
    virtual STDMETHODIMP raw_CompareBookmarks(VARIANT par_Bookmark1, VARIANT par_Bookmark2, enum CompareEnum* par_pCompare) = 0;
    virtual STDMETHODIMP raw_Clone(enum LockTypeEnum par_LockType, _Recordset** par_ppvObject) = 0;
    virtual STDMETHODIMP raw_Resync(enum AffectEnum par_AffectRecords, enum ResyncEnum par_ResyncValues) = 0;
};

} // namespace

//
// Interface wrapper declarations
//

template<> struct wrap_t<ADODB::ADOCommandConstruction> {

    // Wrapper declarations
    inline com_ptr<IUnknown> GetOLEDBCommand();
    inline void PutOLEDBCommand(const com_ptr<IUnknown>& par_ppOLEDBCommand);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutOLEDBCommand, get=GetOLEDBCommand))
    com_ptr<IUnknown> OLEDBCommand;
#endif
};

template<> struct wrap_t<ADODB::ADOConnectionConstruction15> {

    // Wrapper declarations
    inline com_ptr<IUnknown> GetDSO();
    inline com_ptr<IUnknown> GetSession();
    inline void WrapDSOandSession(const com_ptr<IUnknown>& par_pDSO, const com_ptr<IUnknown>& par_pSession);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetDSO))
    com_ptr<IUnknown> DSO;
    __declspec(property(get=GetSession))
    com_ptr<IUnknown> Session;
#endif
};

template<> struct wrap_t<ADODB::ADOConnectionConstruction> : public wrap_t<ADODB::ADOConnectionConstruction15> {

    // Wrapper declarations
};

template<> struct wrap_t<ADODB::ADORecordsetConstruction> {

    // Wrapper declarations
    inline com_ptr<IUnknown> GetRowset();
    inline void PutRowset(const com_ptr<IUnknown>& par_ppRowset);
    inline long GetChapter();
    inline void PutChapter(long par_plChapter);
    inline com_ptr<IUnknown> GetRowPosition();
    inline void PutRowPosition(const com_ptr<IUnknown>& par_ppRowPos);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutChapter, get=GetChapter))
    long Chapter;
    __declspec(property(put=PutRowPosition, get=GetRowPosition))
    com_ptr<IUnknown> RowPosition;
    __declspec(property(put=PutRowset, get=GetRowset))
    com_ptr<IUnknown> Rowset;
#endif
};

template<> struct wrap_t<ADODB::ConnectionEvents> {

    // Wrapper declarations
    inline void InfoMessage(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void BeginTransComplete(long par_TransactionLevel, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void CommitTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void RollbackTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void WillExecute(bstr_t& par_Source, enum ADODB::CursorTypeEnum& par_CursorType, enum ADODB::LockTypeEnum& par_LockType, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void ExecuteComplete(long par_RecordsAffected, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void ConnectComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void Disconnect(enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
};

template<> struct wrap_t<ADODB::ConnectionEventsVt> {

    // Wrapper declarations
    inline void InfoMessage(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void BeginTransComplete(long par_TransactionLevel, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void CommitTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void RollbackTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void WillExecute(bstr_t& par_Source, enum ADODB::CursorTypeEnum& par_CursorType, enum ADODB::LockTypeEnum& par_LockType, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void ExecuteComplete(long par_RecordsAffected, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void ConnectComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
    inline void Disconnect(enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection);
};

template<> struct wrap_t<ADODB::Error> {

    // Wrapper declarations
    inline long GetNumber();
    inline bstr_t GetSource();
    inline bstr_t GetDescription();
    inline bstr_t GetHelpFile();
    inline long GetHelpContext();
    inline bstr_t GetSQLState();
    inline long GetNativeError();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetDescription))
    bstr_t Description;
    __declspec(property(get=GetHelpContext))
    long HelpContext;
    __declspec(property(get=GetHelpFile))
    bstr_t HelpFile;
    __declspec(property(get=GetNativeError))
    long NativeError;
    __declspec(property(get=GetNumber))
    long Number;
    __declspec(property(get=GetSQLState))
    bstr_t SQLState;
    __declspec(property(get=GetSource))
    bstr_t Source;
#endif
};

template<> struct wrap_t<ADODB::_Collection> {

    // Wrapper declarations
    inline long GetCount();
    inline com_ptr<IUnknown> _NewEnum();
    inline void Refresh();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetCount))
    long Count;
#endif
};

template<> struct wrap_t<ADODB::Errors> : public wrap_t<ADODB::_Collection> {

    // Wrapper declarations
    inline com_ptr<ADODB::Error> GetItem(const variant_t& par_Index);
    inline void Clear();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetItem))
    com_ptr<ADODB::Error> Item[];
#endif
};

template<> struct wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline com_ptr<ADODB::Properties> GetProperties();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetProperties))
    com_ptr<ADODB::Properties> Properties;
#endif
};

template<> struct wrap_t<ADODB::Field> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline long GetActualSize();
    inline long GetAttributes();
    inline long GetDefinedSize();
    inline bstr_t GetName();
    inline ADODB::DataTypeEnum GetType();
    inline variant_t GetValue();
    inline void PutValue(const variant_t& par_pvar);
    inline unsigned char GetPrecision();
    inline unsigned char GetNumericScale();
    inline void AppendChunk(const variant_t& par_Data);
    inline variant_t GetChunk(long par_Length);
    inline variant_t GetOriginalValue();
    inline variant_t GetUnderlyingValue();
    inline com_ptr<IUnknown> GetDataFormat();
    inline void PutDataFormat(const com_ptr<IUnknown>& par_ppiDF);
    inline void PutPrecision(unsigned char par_pbPrecision);
    inline void PutNumericScale(unsigned char par_pbNumericScale);
    inline void PutType(enum ADODB::DataTypeEnum par_pDataType);
    inline void PutDefinedSize(long par_pl);
    inline void PutAttributes(long par_pl);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetActualSize))
    long ActualSize;
    __declspec(property(put=PutAttributes, get=GetAttributes))
    long Attributes;
    __declspec(property(put=PutDataFormat, get=GetDataFormat))
    com_ptr<IUnknown> DataFormat;
    __declspec(property(put=PutDefinedSize, get=GetDefinedSize))
    long DefinedSize;
    __declspec(property(get=GetName))
    bstr_t Name;
    __declspec(property(put=PutNumericScale, get=GetNumericScale))
    unsigned char NumericScale;
    __declspec(property(get=GetOriginalValue))
    variant_t OriginalValue;
    __declspec(property(put=PutPrecision, get=GetPrecision))
    unsigned char Precision;
    __declspec(property(put=PutType, get=GetType))
    ADODB::DataTypeEnum Type;
    __declspec(property(get=GetUnderlyingValue))
    variant_t UnderlyingValue;
    __declspec(property(put=PutValue, get=GetValue))
    variant_t Value;
#endif
};

template<> struct wrap_t<ADODB::Field15> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline long GetActualSize();
    inline long GetAttributes();
    inline long GetDefinedSize();
    inline bstr_t GetName();
    inline ADODB::DataTypeEnum GetType();
    inline variant_t GetValue();
    inline void PutValue(const variant_t& par_pvar);
    inline unsigned char GetPrecision();
    inline unsigned char GetNumericScale();
    inline void AppendChunk(const variant_t& par_Data);
    inline variant_t GetChunk(long par_Length);
    inline variant_t GetOriginalValue();
    inline variant_t GetUnderlyingValue();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetActualSize))
    long ActualSize;
    __declspec(property(get=GetAttributes))
    long Attributes;
    __declspec(property(get=GetDefinedSize))
    long DefinedSize;
    __declspec(property(get=GetName))
    bstr_t Name;
    __declspec(property(get=GetNumericScale))
    unsigned char NumericScale;
    __declspec(property(get=GetOriginalValue))
    variant_t OriginalValue;
    __declspec(property(get=GetPrecision))
    unsigned char Precision;
    __declspec(property(get=GetType))
    ADODB::DataTypeEnum Type;
    __declspec(property(get=GetUnderlyingValue))
    variant_t UnderlyingValue;
    __declspec(property(put=PutValue, get=GetValue))
    variant_t Value;
#endif
};

template<> struct wrap_t<ADODB::Fields15> : public wrap_t<ADODB::_Collection> {

    // Wrapper declarations
    inline com_ptr<ADODB::Field> GetItem(const variant_t& par_Index);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetItem))
    com_ptr<ADODB::Field> Item[];
#endif
};

template<> struct wrap_t<ADODB::Fields> : public wrap_t<ADODB::Fields15> {

    // Wrapper declarations
    inline void Append(const bstr_t& par_Name, enum ADODB::DataTypeEnum par_Type, long par_DefinedSize = 0, enum ADODB::FieldAttributeEnum par_Attrib = enum ADODB::FieldAttributeEnum(-1));
    inline void Delete(const variant_t& par_Index);
};

template<> struct wrap_t<ADODB::_DynaCollection> : public wrap_t<ADODB::_Collection> {

    // Wrapper declarations
    inline void Append(const com_ptr<IDispatch>& par_Object);
    inline void Delete(const variant_t& par_Index);
};

template<> struct wrap_t<ADODB::Parameters> : public wrap_t<ADODB::_DynaCollection> {

    // Wrapper declarations
    inline com_ptr<ADODB::_Parameter> GetItem(const variant_t& par_Index);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetItem))
    com_ptr<ADODB::_Parameter> Item[];
#endif
};

template<> struct wrap_t<ADODB::Properties> : public wrap_t<ADODB::_Collection> {

    // Wrapper declarations
    inline com_ptr<ADODB::Property> GetItem(const variant_t& par_Index);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetItem))
    com_ptr<ADODB::Property> Item[];
#endif
};

template<> struct wrap_t<ADODB::Property> {

    // Wrapper declarations
    inline variant_t GetValue();
    inline void PutValue(const variant_t& par_pval);
    inline bstr_t GetName();
    inline ADODB::DataTypeEnum GetType();
    inline long GetAttributes();
    inline void PutAttributes(long par_plAttributes);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutAttributes, get=GetAttributes))
    long Attributes;
    __declspec(property(get=GetName))
    bstr_t Name;
    __declspec(property(get=GetType))
    ADODB::DataTypeEnum Type;
    __declspec(property(put=PutValue, get=GetValue))
    variant_t Value;
#endif
};

template<> struct wrap_t<ADODB::RecordsetEvents> {

    // Wrapper declarations
    inline void WillChangeField(long par_cFields, const variant_t& par_Fields, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void MoveComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void EndOfRecordset(bool& par_fMoreData, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FetchComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
};

template<> struct wrap_t<ADODB::RecordsetEventsVt> {

    // Wrapper declarations
    inline void WillChangeField(long par_cFields, const variant_t& par_Fields, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void MoveComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void EndOfRecordset(bool& par_fMoreData, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
    inline void FetchComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset);
};

template<> struct wrap_t<ADODB::_Command15> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline com_ptr<ADODB::_Connection> GetActiveConnection();
    inline void PutrefActiveConnection(const com_ptr<ADODB::_Connection>& par_ppvObject);
    inline void PutActiveConnection(const variant_t& par_ppvObject);
    inline bstr_t GetCommandText();
    inline void PutCommandText(const bstr_t& par_pbstr);
    inline long GetCommandTimeout();
    inline void PutCommandTimeout(long par_pl);
    inline bool GetPrepared();
    inline void PutPrepared(bool par_pfPrepared);
    inline com_ptr<ADODB::_Recordset> Execute(variant_t& par_RecordsAffected, const variant_t& par_Parameters = variant_t::missing(), long par_Options = -1);
    inline com_ptr<ADODB::_Parameter> CreateParameter(const bstr_t& par_Name = L"", enum ADODB::DataTypeEnum par_Type = enum ADODB::DataTypeEnum(0), enum ADODB::ParameterDirectionEnum par_Direction = enum ADODB::ParameterDirectionEnum(1), long par_Size = 0, const variant_t& par_Value = variant_t::missing());
    inline com_ptr<ADODB::Parameters> GetParameters();
    inline void PutCommandType(enum ADODB::CommandTypeEnum par_plCmdType);
    inline ADODB::CommandTypeEnum GetCommandType();
    inline bstr_t GetName();
    inline void PutName(const bstr_t& par_pbstrName);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutCommandText, get=GetCommandText))
    bstr_t CommandText;
    __declspec(property(put=PutCommandTimeout, get=GetCommandTimeout))
    long CommandTimeout;
    __declspec(property(put=PutCommandType, get=GetCommandType))
    ADODB::CommandTypeEnum CommandType;
    __declspec(property(put=PutName, get=GetName))
    bstr_t Name;
    __declspec(property(get=GetParameters))
    com_ptr<ADODB::Parameters> Parameters;
    __declspec(property(put=PutPrepared, get=GetPrepared))
    bool Prepared;
#endif
};

template<> struct wrap_t<ADODB::_Command> : public wrap_t<ADODB::_Command15> {

    // Wrapper declarations
    inline long GetState();
    inline void Cancel();

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetState))
    long State;
#endif
};

template<> struct wrap_t<ADODB::_Connection15> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline bstr_t GetConnectionString();
    inline void PutConnectionString(const bstr_t& par_pbstr);
    inline long GetCommandTimeout();
    inline void PutCommandTimeout(long par_plTimeout);
    inline long GetConnectionTimeout();
    inline void PutConnectionTimeout(long par_plTimeout);
    inline bstr_t GetVersion();
    inline void Close();
    inline com_ptr<ADODB::_Recordset> Execute(const bstr_t& par_CommandText, variant_t& par_RecordsAffected, long par_Options = -1);
    inline long BeginTrans();
    inline void CommitTrans();
    inline void RollbackTrans();
    inline void Open(const bstr_t& par_ConnectionString = L"", const bstr_t& par_UserID = L"", const bstr_t& par_Password = L"", long par_Options = -1);
    inline com_ptr<ADODB::Errors> GetErrors();
    inline bstr_t GetDefaultDatabase();
    inline void PutDefaultDatabase(const bstr_t& par_pbstr);
    inline ADODB::IsolationLevelEnum GetIsolationLevel();
    inline void PutIsolationLevel(enum ADODB::IsolationLevelEnum par_Level);
    inline long GetAttributes();
    inline void PutAttributes(long par_plAttr);
    inline ADODB::CursorLocationEnum GetCursorLocation();
    inline void PutCursorLocation(enum ADODB::CursorLocationEnum par_plCursorLoc);
    inline ADODB::ConnectModeEnum GetMode();
    inline void PutMode(enum ADODB::ConnectModeEnum par_plMode);
    inline bstr_t GetProvider();
    inline void PutProvider(const bstr_t& par_pbstr);
    inline long GetState();
    inline com_ptr<ADODB::_Recordset> OpenSchema(enum ADODB::SchemaEnum par_Schema, const variant_t& par_Restrictions = variant_t::missing(), const variant_t& par_SchemaID = variant_t::missing());

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutAttributes, get=GetAttributes))
    long Attributes;
    __declspec(property(put=PutCommandTimeout, get=GetCommandTimeout))
    long CommandTimeout;
    __declspec(property(put=PutConnectionString, get=GetConnectionString))
    bstr_t ConnectionString;
    __declspec(property(put=PutConnectionTimeout, get=GetConnectionTimeout))
    long ConnectionTimeout;
    __declspec(property(put=PutCursorLocation, get=GetCursorLocation))
    ADODB::CursorLocationEnum CursorLocation;
    __declspec(property(put=PutDefaultDatabase, get=GetDefaultDatabase))
    bstr_t DefaultDatabase;
    __declspec(property(get=GetErrors))
    com_ptr<ADODB::Errors> Errors;
    __declspec(property(put=PutIsolationLevel, get=GetIsolationLevel))
    ADODB::IsolationLevelEnum IsolationLevel;
    __declspec(property(put=PutMode, get=GetMode))
    ADODB::ConnectModeEnum Mode;
    __declspec(property(put=PutProvider, get=GetProvider))
    bstr_t Provider;
    __declspec(property(get=GetState))
    long State;
    __declspec(property(get=GetVersion))
    bstr_t Version;
#endif
};

template<> struct wrap_t<ADODB::_Connection> : public wrap_t<ADODB::_Connection15> {

    // Wrapper declarations
    inline void Cancel();
};

template<> struct wrap_t<ADODB::_Parameter> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline bstr_t GetName();
    inline void PutName(const bstr_t& par_pbstr);
    inline variant_t GetValue();
    inline void PutValue(const variant_t& par_pvar);
    inline ADODB::DataTypeEnum GetType();
    inline void PutType(enum ADODB::DataTypeEnum par_psDataType);
    inline void PutDirection(enum ADODB::ParameterDirectionEnum par_plParmDirection);
    inline ADODB::ParameterDirectionEnum GetDirection();
    inline void PutPrecision(unsigned char par_pbPrecision);
    inline unsigned char GetPrecision();
    inline void PutNumericScale(unsigned char par_pbScale);
    inline unsigned char GetNumericScale();
    inline void PutSize(long par_pl);
    inline long GetSize();
    inline void AppendChunk(const variant_t& par_Val);
    inline long GetAttributes();
    inline void PutAttributes(long par_plParmAttribs);

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutAttributes, get=GetAttributes))
    long Attributes;
    __declspec(property(put=PutDirection, get=GetDirection))
    ADODB::ParameterDirectionEnum Direction;
    __declspec(property(put=PutName, get=GetName))
    bstr_t Name;
    __declspec(property(put=PutNumericScale, get=GetNumericScale))
    unsigned char NumericScale;
    __declspec(property(put=PutPrecision, get=GetPrecision))
    unsigned char Precision;
    __declspec(property(put=PutSize, get=GetSize))
    long Size;
    __declspec(property(put=PutType, get=GetType))
    ADODB::DataTypeEnum Type;
    __declspec(property(put=PutValue, get=GetValue))
    variant_t Value;
#endif
};

template<> struct wrap_t<ADODB::_Recordset15> : public wrap_t<ADODB::_ADO> {

    // Wrapper declarations
    inline ADODB::PositionEnum GetAbsolutePosition();
    inline void PutAbsolutePosition(enum ADODB::PositionEnum par_pl);
    inline void PutrefActiveConnection(const com_ptr<IDispatch>& par_pvar);
    inline void PutActiveConnection(const variant_t& par_pvar);
    inline variant_t GetActiveConnection();
    inline bool GetBOF();
    inline variant_t GetBookmark();
    inline void PutBookmark(const variant_t& par_pvBookmark);
    inline long GetCacheSize();
    inline void PutCacheSize(long par_pl);
    inline ADODB::CursorTypeEnum GetCursorType();
    inline void PutCursorType(enum ADODB::CursorTypeEnum par_plCursorType);
    inline bool GetEOF();
    inline com_ptr<ADODB::Fields> GetFields();
    inline ADODB::LockTypeEnum GetLockType();
    inline void PutLockType(enum ADODB::LockTypeEnum par_plLockType);
    inline long GetMaxRecords();
    inline void PutMaxRecords(long par_plMaxRecords);
    inline long GetRecordCount();
    inline void PutrefSource(const com_ptr<IDispatch>& par_pvSource);
    inline void PutSource(const bstr_t& par_pvSource);
    inline variant_t GetSource();
    inline void AddNew(const variant_t& par_FieldList = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
    inline void CancelUpdate();
    inline void Close();
    inline void Delete(enum ADODB::AffectEnum par_AffectRecords = enum ADODB::AffectEnum(1));
    inline variant_t GetRows(long par_Rows = -1, const variant_t& par_Start = variant_t::missing(), const variant_t& par_Fields = variant_t::missing());
    inline void Move(long par_NumRecords, const variant_t& par_Start = variant_t::missing());
    inline void MoveNext();
    inline void MovePrevious();
    inline void MoveFirst();
    inline void MoveLast();
    inline void Open(const variant_t& par_Source = variant_t::missing(), const variant_t& par_ActiveConnection = variant_t::missing(), enum ADODB::CursorTypeEnum par_CursorType = enum ADODB::CursorTypeEnum(-1), enum ADODB::LockTypeEnum par_LockType = enum ADODB::LockTypeEnum(-1), long par_Options = -1);
    inline void Requery(long par_Options = -1);
    inline void _xResync(enum ADODB::AffectEnum par_AffectRecords = enum ADODB::AffectEnum(3));
    inline void Update(const variant_t& par_Fields = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
    inline ADODB::PositionEnum GetAbsolutePage();
    inline void PutAbsolutePage(enum ADODB::PositionEnum par_pl);
    inline ADODB::EditModeEnum GetEditMode();
    inline variant_t GetFilter();
    inline void PutFilter(const variant_t& par_Criteria);
    inline long GetPageCount();
    inline long GetPageSize();
    inline void PutPageSize(long par_pl);
    inline bstr_t GetSort();
    inline void PutSort(const bstr_t& par_Criteria);
    inline long GetStatus();
    inline long GetState();
    inline com_ptr<ADODB::_Recordset> _xClone();
    inline void UpdateBatch(enum ADODB::AffectEnum par_AffectRecords = enum ADODB::AffectEnum(3));
    inline void CancelBatch(enum ADODB::AffectEnum par_AffectRecords = enum ADODB::AffectEnum(3));
    inline ADODB::CursorLocationEnum GetCursorLocation();
    inline void PutCursorLocation(enum ADODB::CursorLocationEnum par_plCursorLoc);
    inline com_ptr<ADODB::_Recordset> NextRecordset(variant_t& par_RecordsAffected);
    inline bool Supports(enum ADODB::CursorOptionEnum par_CursorOptions);
    inline variant_t GetCollect(const variant_t& par_Index);
    inline void PutCollect(const variant_t& par_Index, const variant_t& par_pvar);
    inline ADODB::MarshalOptionsEnum GetMarshalOptions();
    inline void PutMarshalOptions(enum ADODB::MarshalOptionsEnum par_peMarshal);
    inline void Find(const bstr_t& par_Criteria, long par_SkipRecords = 0, enum ADODB::SearchDirectionEnum par_SearchDirection = enum ADODB::SearchDirectionEnum(1), const variant_t& par_Start = variant_t::missing());

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(put=PutAbsolutePage, get=GetAbsolutePage))
    ADODB::PositionEnum AbsolutePage;
    __declspec(property(put=PutAbsolutePosition, get=GetAbsolutePosition))
    ADODB::PositionEnum AbsolutePosition;
    __declspec(property(put=PutActiveConnection, get=GetActiveConnection))
    variant_t ActiveConnection;
    __declspec(property(get=GetBOF))
    bool BOF;
    __declspec(property(put=PutBookmark, get=GetBookmark))
    variant_t Bookmark;
    __declspec(property(put=PutCacheSize, get=GetCacheSize))
    long CacheSize;
    __declspec(property(put=PutCollect, get=GetCollect))
    variant_t Collect[];
    __declspec(property(put=PutCursorLocation, get=GetCursorLocation))
    ADODB::CursorLocationEnum CursorLocation;
    __declspec(property(put=PutCursorType, get=GetCursorType))
    ADODB::CursorTypeEnum CursorType;
    __declspec(property(get=GetEndOfFile))
    bool EndOfFile;
    __declspec(property(get=GetEditMode))
    ADODB::EditModeEnum EditMode;
    __declspec(property(get=GetFields))
    com_ptr<ADODB::Fields> Fields;
    __declspec(property(put=PutFilter, get=GetFilter))
    variant_t Filter;
    __declspec(property(put=PutLockType, get=GetLockType))
    ADODB::LockTypeEnum LockType;
    __declspec(property(put=PutMarshalOptions, get=GetMarshalOptions))
    ADODB::MarshalOptionsEnum MarshalOptions;
    __declspec(property(put=PutMaxRecords, get=GetMaxRecords))
    long MaxRecords;
    __declspec(property(get=GetPageCount))
    long PageCount;
    __declspec(property(put=PutPageSize, get=GetPageSize))
    long PageSize;
    __declspec(property(get=GetRecordCount))
    long RecordCount;
    __declspec(property(put=PutSort, get=GetSort))
    bstr_t Sort;
    __declspec(property(put=PutSource, get=GetSource))
    variant_t Source;
    __declspec(property(get=GetState))
    long State;
    __declspec(property(get=GetStatus))
    long Status;
#endif
};

template<> struct wrap_t<ADODB::_Recordset> : public wrap_t<ADODB::_Recordset15> {

    // Wrapper declarations
    inline void Cancel();
    inline com_ptr<IUnknown> GetDataSource();
    inline void PutDataSource(const com_ptr<IUnknown>& par_ppunkDataSource);
    inline void Save(const bstr_t& par_FileName = (BSTR)0, enum ADODB::PersistFormatEnum par_PersistFormat = enum ADODB::PersistFormatEnum(0));
    inline com_ptr<IDispatch> GetActiveCommand();
    inline void PutStayInSync(bool par_pbStayInSync);
    inline bool GetStayInSync();
    inline bstr_t GetString(enum ADODB::StringFormatEnum par_StringFormat = enum ADODB::StringFormatEnum(2), long par_NumRows = -1, const bstr_t& par_ColumnDelimeter = (BSTR)0, const bstr_t& par_RowDelimeter = (BSTR)0, const bstr_t& par_NullExpr = (BSTR)0);
    inline bstr_t GetDataMember();
    inline void PutDataMember(const bstr_t& par_pbstrDataMember);
    inline ADODB::CompareEnum CompareBookmarks(const variant_t& par_Bookmark1, const variant_t& par_Bookmark2);
    inline com_ptr<ADODB::_Recordset> Clone(enum ADODB::LockTypeEnum par_LockType = enum ADODB::LockTypeEnum(-1));
    inline void Resync(enum ADODB::AffectEnum par_AffectRecords = enum ADODB::AffectEnum(3), enum ADODB::ResyncEnum par_ResyncValues = enum ADODB::ResyncEnum(2));

    // Properties
#ifdef COMET_ALLOW_DECLSPEC_PROPERTY
    __declspec(property(get=GetActiveCommand))
    com_ptr<IDispatch> ActiveCommand;
    __declspec(property(put=PutDataMember, get=GetDataMember))
    bstr_t DataMember;
    __declspec(property(put=PutDataSource, get=GetDataSource))
    com_ptr<IUnknown> DataSource;
    __declspec(property(put=PutStayInSync, get=GetStayInSync))
    bool StayInSync;
#endif
};

//
// Method wrappers
//

inline com_ptr<IUnknown> wrap_t<ADODB::ADOCommandConstruction>::GetOLEDBCommand()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADOCommandConstruction*>(this)->get_OLEDBCommand(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADOCommandConstruction*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::ADOCommandConstruction>::PutOLEDBCommand(const com_ptr<IUnknown>& par_ppOLEDBCommand)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ADOCommandConstruction*>(this)->put_OLEDBCommand(par_ppOLEDBCommand.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADOCommandConstruction*>(this), _hr_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::ADOConnectionConstruction15>::GetDSO()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this)->get_DSO(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::ADOConnectionConstruction15>::GetSession()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this)->get_Session(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::ADOConnectionConstruction15>::WrapDSOandSession(const com_ptr<IUnknown>& par_pDSO, const com_ptr<IUnknown>& par_pSession)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this)->raw_WrapDSOandSession(par_pDSO.in(), par_pSession.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADOConnectionConstruction15*>(this), _hr_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::ADORecordsetConstruction>::GetRowset()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->get_Rowset(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::ADORecordsetConstruction>::PutRowset(const com_ptr<IUnknown>& par_ppRowset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->put_Rowset(par_ppRowset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
}

inline long wrap_t<ADODB::ADORecordsetConstruction>::GetChapter()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->get_Chapter(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::ADORecordsetConstruction>::PutChapter(long par_plChapter)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->put_Chapter(par_plChapter);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::ADORecordsetConstruction>::GetRowPosition()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->get_RowPosition(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::ADORecordsetConstruction>::PutRowPosition(const com_ptr<IUnknown>& par_ppRowPos)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ADORecordsetConstruction*>(this)->put_RowPosition(par_ppRowPos.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ADORecordsetConstruction*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::InfoMessage(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[3];
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::BeginTransComplete(long par_TransactionLevel, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_TransactionLevel; V_VT(&(vars[3])) = VT_I4;
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::CommitTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[3];
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::RollbackTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[3];
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::WillExecute(bstr_t& par_Source, enum ADODB::CursorTypeEnum& par_CursorType, enum ADODB::LockTypeEnum& par_LockType, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[8];
    V_BSTRREF(&vars[7]) = par_Source.inout(); V_VT(&(vars[7])) = (VT_BSTR | VT_BYREF);
    V_I4REF(&vars[6]) = (long *)&par_CursorType; V_VT(&(vars[6])) = (VT_I4 | VT_BYREF);
    V_I4REF(&vars[5]) = (long *)&par_LockType; V_VT(&(vars[5])) = (VT_I4 | VT_BYREF);
    V_I4REF(&vars[4]) = &par_Options; V_VT(&(vars[4])) = (VT_I4 | VT_BYREF);
    V_I4REF(&vars[3]) = (long *)&par_adStatus; V_VT(&(vars[3])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[2]) = par_pCommand.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_DISPATCH(&vars[1]) = par_pRecordset.in(); V_VT(&(vars[1])) = VT_DISPATCH;
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 8, 0 };
    HRESULT _hr_ = raw(this)->Invoke(4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::ExecuteComplete(long par_RecordsAffected, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[6];
    V_I4(&vars[5]) = par_RecordsAffected; V_VT(&(vars[5])) = VT_I4;
    V_DISPATCH(&vars[4]) = par_pError.in(); V_VT(&(vars[4])) = VT_DISPATCH;
    V_I4REF(&vars[3]) = (long *)&par_adStatus; V_VT(&(vars[3])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[2]) = par_pCommand.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_DISPATCH(&vars[1]) = par_pRecordset.in(); V_VT(&(vars[1])) = VT_DISPATCH;
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 6, 0 };
    HRESULT _hr_ = raw(this)->Invoke(5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[6];
    V_BSTRREF(&vars[5]) = par_ConnectionString.inout(); V_VT(&(vars[5])) = (VT_BSTR | VT_BYREF);
    V_BSTRREF(&vars[4]) = par_UserID.inout(); V_VT(&(vars[4])) = (VT_BSTR | VT_BYREF);
    V_BSTRREF(&vars[3]) = par_Password.inout(); V_VT(&(vars[3])) = (VT_BSTR | VT_BYREF);
    V_I4REF(&vars[2]) = &par_Options; V_VT(&(vars[2])) = (VT_I4 | VT_BYREF);
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 6, 0 };
    HRESULT _hr_ = raw(this)->Invoke(6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::ConnectComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[3];
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEvents>::Disconnect(enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    VARIANT vars[2];
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pConnection.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 2, 0 };
    HRESULT _hr_ = raw(this)->Invoke(8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::InfoMessage(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_InfoMessage(par_pError.in(), &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::BeginTransComplete(long par_TransactionLevel, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_BeginTransComplete(par_TransactionLevel, par_pError.in(), &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::CommitTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_CommitTransComplete(par_pError.in(), &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::RollbackTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_RollbackTransComplete(par_pError.in(), &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::WillExecute(bstr_t& par_Source, enum ADODB::CursorTypeEnum& par_CursorType, enum ADODB::LockTypeEnum& par_LockType, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_WillExecute(par_Source.inout(), &par_CursorType, &par_LockType, &par_Options, &par_adStatus, par_pCommand.in(), par_pRecordset.in(), par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::ExecuteComplete(long par_RecordsAffected, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_ExecuteComplete(par_RecordsAffected, par_pError.in(), &par_adStatus, par_pCommand.in(), par_pRecordset.in(), par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_WillConnect(par_ConnectionString.inout(), par_UserID.inout(), par_Password.inout(), &par_Options, &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::ConnectComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_ConnectComplete(par_pError.in(), &par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::ConnectionEventsVt>::Disconnect(enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::ConnectionEventsVt*>(this)->raw_Disconnect(&par_adStatus, par_pConnection.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::ConnectionEventsVt*>(this), _hr_);
}

inline long wrap_t<ADODB::Error>::GetNumber()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_Number(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return _result_;
}

inline bstr_t wrap_t<ADODB::Error>::GetSource()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_Source(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return auto_attach(_result_);
}

inline bstr_t wrap_t<ADODB::Error>::GetDescription()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_Description(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return auto_attach(_result_);
}

inline bstr_t wrap_t<ADODB::Error>::GetHelpFile()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_HelpFile(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return auto_attach(_result_);
}

inline long wrap_t<ADODB::Error>::GetHelpContext()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_HelpContext(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return _result_;
}

inline bstr_t wrap_t<ADODB::Error>::GetSQLState()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_SQLState(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return auto_attach(_result_);
}

inline long wrap_t<ADODB::Error>::GetNativeError()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Error*>(this)->get_NativeError(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Error*>(this), _hr_);
    return _result_;
}

inline com_ptr<ADODB::Error> wrap_t<ADODB::Errors>::GetItem(const variant_t& par_Index)
{
    ADODB::Error* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Errors*>(this)->get_Item(par_Index.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Errors*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Errors>::Clear()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Errors*>(this)->raw_Clear();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Errors*>(this), _hr_);
}

inline long wrap_t<ADODB::Field>::GetActualSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_ActualSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::Field>::GetAttributes()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_Attributes(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::Field>::GetDefinedSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_DefinedSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return _result_;
}

inline bstr_t wrap_t<ADODB::Field>::GetName()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_Name(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline ADODB::DataTypeEnum wrap_t<ADODB::Field>::GetType()
{
    enum ADODB::DataTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_Type(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return enum ADODB::DataTypeEnum(_result_);
}

inline variant_t wrap_t<ADODB::Field>::GetValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_Value(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Field>::PutValue(const variant_t& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_Value(par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline unsigned char wrap_t<ADODB::Field>::GetPrecision()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_Precision(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return _result_;
}

inline unsigned char wrap_t<ADODB::Field>::GetNumericScale()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_NumericScale(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::Field>::AppendChunk(const variant_t& par_Data)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->raw_AppendChunk(par_Data.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::Field>::GetChunk(long par_Length)
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->raw_GetChunk(par_Length, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline variant_t wrap_t<ADODB::Field>::GetOriginalValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_OriginalValue(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline variant_t wrap_t<ADODB::Field>::GetUnderlyingValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_UnderlyingValue(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::Field>::GetDataFormat()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->get_DataFormat(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Field>::PutDataFormat(const com_ptr<IUnknown>& par_ppiDF)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->putref_DataFormat(par_ppiDF.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline void wrap_t<ADODB::Field>::PutPrecision(unsigned char par_pbPrecision)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_Precision(par_pbPrecision);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline void wrap_t<ADODB::Field>::PutNumericScale(unsigned char par_pbNumericScale)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_NumericScale(par_pbNumericScale);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline void wrap_t<ADODB::Field>::PutType(enum ADODB::DataTypeEnum par_pDataType)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_Type(par_pDataType);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline void wrap_t<ADODB::Field>::PutDefinedSize(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_DefinedSize(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline void wrap_t<ADODB::Field>::PutAttributes(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field*>(this)->put_Attributes(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field*>(this), _hr_);
}

inline long wrap_t<ADODB::Field15>::GetActualSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_ActualSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::Field15>::GetAttributes()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_Attributes(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::Field15>::GetDefinedSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_DefinedSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return _result_;
}

inline bstr_t wrap_t<ADODB::Field15>::GetName()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_Name(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return auto_attach(_result_);
}

inline ADODB::DataTypeEnum wrap_t<ADODB::Field15>::GetType()
{
    enum ADODB::DataTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_Type(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return enum ADODB::DataTypeEnum(_result_);
}

inline variant_t wrap_t<ADODB::Field15>::GetValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_Value(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Field15>::PutValue(const variant_t& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->put_Value(par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
}

inline unsigned char wrap_t<ADODB::Field15>::GetPrecision()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_Precision(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return _result_;
}

inline unsigned char wrap_t<ADODB::Field15>::GetNumericScale()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_NumericScale(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::Field15>::AppendChunk(const variant_t& par_Data)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->raw_AppendChunk(par_Data.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::Field15>::GetChunk(long par_Length)
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->raw_GetChunk(par_Length, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return auto_attach(_result_);
}

inline variant_t wrap_t<ADODB::Field15>::GetOriginalValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_OriginalValue(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return auto_attach(_result_);
}

inline variant_t wrap_t<ADODB::Field15>::GetUnderlyingValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Field15*>(this)->get_UnderlyingValue(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Field15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Fields>::Append(const bstr_t& par_Name, enum ADODB::DataTypeEnum par_Type, long par_DefinedSize, enum ADODB::FieldAttributeEnum par_Attrib)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Fields*>(this)->raw_Append(par_Name.in(), par_Type, par_DefinedSize, par_Attrib);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Fields*>(this), _hr_);
}

inline void wrap_t<ADODB::Fields>::Delete(const variant_t& par_Index)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Fields*>(this)->raw_Delete(par_Index.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Fields*>(this), _hr_);
}

inline com_ptr<ADODB::Field> wrap_t<ADODB::Fields15>::GetItem(const variant_t& par_Index)
{
    ADODB::Field* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Fields15*>(this)->get_Item(par_Index.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Fields15*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<ADODB::_Parameter> wrap_t<ADODB::Parameters>::GetItem(const variant_t& par_Index)
{
    ADODB::_Parameter* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Parameters*>(this)->get_Item(par_Index.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Parameters*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<ADODB::Property> wrap_t<ADODB::Properties>::GetItem(const variant_t& par_Index)
{
    ADODB::Property* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Properties*>(this)->get_Item(par_Index.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Properties*>(this), _hr_);
    return auto_attach(_result_);
}

inline variant_t wrap_t<ADODB::Property>::GetValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->get_Value(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::Property>::PutValue(const variant_t& par_pval)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->put_Value(par_pval.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::Property>::GetName()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->get_Name(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
    return auto_attach(_result_);
}

inline ADODB::DataTypeEnum wrap_t<ADODB::Property>::GetType()
{
    enum ADODB::DataTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->get_Type(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
    return enum ADODB::DataTypeEnum(_result_);
}

inline long wrap_t<ADODB::Property>::GetAttributes()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->get_Attributes(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::Property>::PutAttributes(long par_plAttributes)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::Property*>(this)->put_Attributes(par_plAttributes);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::Property*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::WillChangeField(long par_cFields, const variant_t& par_Fields, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_cFields; V_VT(&(vars[3])) = VT_I4;
    vars[2] = par_Fields.in();     V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[5];
    V_I4(&vars[4]) = par_cFields; V_VT(&(vars[4])) = VT_I4;
    vars[3] = par_Fields.in();     V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 5, 0 };
    HRESULT _hr_ = raw(this)->Invoke(10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_adReason; V_VT(&(vars[3])) = VT_I4;
    V_I4(&vars[2]) = par_cRecords; V_VT(&(vars[2])) = VT_I4;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[5];
    V_I4(&vars[4]) = par_adReason; V_VT(&(vars[4])) = VT_I4;
    V_I4(&vars[3]) = par_cRecords; V_VT(&(vars[3])) = VT_I4;
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 5, 0 };
    HRESULT _hr_ = raw(this)->Invoke(12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[3];
    V_I4(&vars[2]) = par_adReason; V_VT(&(vars[2])) = VT_I4;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_adReason; V_VT(&(vars[3])) = VT_I4;
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[3];
    V_I4(&vars[2]) = par_adReason; V_VT(&(vars[2])) = VT_I4;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::MoveComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_adReason; V_VT(&(vars[3])) = VT_I4;
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::EndOfRecordset(bool& par_fMoreData, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[3];
    bool_inout bool_inout_1(par_fMoreData);
    V_BOOLREF(&vars[2]) = bool_inout_1; V_VT(&(vars[2])) = (VT_BOOL | VT_BYREF);
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(17, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[4];
    V_I4(&vars[3]) = par_Progress; V_VT(&(vars[3])) = VT_I4;
    V_I4(&vars[2]) = par_MaxProgress; V_VT(&(vars[2])) = VT_I4;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 4, 0 };
    HRESULT _hr_ = raw(this)->Invoke(18, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEvents>::FetchComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    VARIANT vars[3];
    V_DISPATCH(&vars[2]) = par_pError.in(); V_VT(&(vars[2])) = VT_DISPATCH;
    V_I4REF(&vars[1]) = (long *)&par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
    V_DISPATCH(&vars[0]) = par_pRecordset.in(); V_VT(&(vars[0])) = VT_DISPATCH;
    DISPPARAMS disp = { vars, 0, 3, 0 };
    HRESULT _hr_ = raw(this)->Invoke(19, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEvents*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::WillChangeField(long par_cFields, const variant_t& par_Fields, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_WillChangeField(par_cFields, par_Fields.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_FieldChangeComplete(par_cFields, par_Fields.in(), par_pError.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_WillChangeRecord(par_adReason, par_cRecords, &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_RecordChangeComplete(par_adReason, par_cRecords, par_pError.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_WillChangeRecordset(par_adReason, &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_RecordsetChangeComplete(par_adReason, par_pError.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_WillMove(par_adReason, &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::MoveComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_MoveComplete(par_adReason, par_pError.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::EndOfRecordset(bool& par_fMoreData, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_EndOfRecordset(bool_inout(par_fMoreData), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_FetchProgress(par_Progress, par_MaxProgress, &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline void wrap_t<ADODB::RecordsetEventsVt>::FetchComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::RecordsetEventsVt*>(this)->raw_FetchComplete(par_pError.in(), &par_adStatus, par_pRecordset.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::RecordsetEventsVt*>(this), _hr_);
}

inline com_ptr<ADODB::Properties> wrap_t<ADODB::_ADO>::GetProperties()
{
    ADODB::Properties* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_ADO*>(this)->get_Properties(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_ADO*>(this), _hr_);
    return auto_attach(_result_);
}

inline long wrap_t<ADODB::_Collection>::GetCount()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Collection*>(this)->get_Count(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Collection*>(this), _hr_);
    return _result_;
}

inline com_ptr<IUnknown> wrap_t<ADODB::_Collection>::_NewEnum()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Collection*>(this)->raw__NewEnum(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Collection*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Collection>::Refresh()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Collection*>(this)->raw_Refresh();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Collection*>(this), _hr_);
}

inline long wrap_t<ADODB::_Command>::GetState()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command*>(this)->get_State(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Command>::Cancel()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command*>(this)->raw_Cancel();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command*>(this), _hr_);
}

inline com_ptr<ADODB::_Connection> wrap_t<ADODB::_Command15>::GetActiveConnection()
{
    ADODB::_Connection* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_ActiveConnection(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Command15>::PutrefActiveConnection(const com_ptr<ADODB::_Connection>& par_ppvObject)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->putref_ActiveConnection(par_ppvObject.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Command15>::PutActiveConnection(const variant_t& par_ppvObject)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_ActiveConnection(par_ppvObject.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Command15>::GetCommandText()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_CommandText(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Command15>::PutCommandText(const bstr_t& par_pbstr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_CommandText(par_pbstr.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Command15>::GetCommandTimeout()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_CommandTimeout(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Command15>::PutCommandTimeout(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_CommandTimeout(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline bool wrap_t<ADODB::_Command15>::GetPrepared()
{
    VARIANT_BOOL _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_Prepared(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return _result_ != COMET_VARIANT_FALSE;
}

inline void wrap_t<ADODB::_Command15>::PutPrepared(bool par_pfPrepared)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_Prepared(par_pfPrepared ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Command15>::Execute(variant_t& par_RecordsAffected, const variant_t& par_Parameters, long par_Options)
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->raw_Execute(par_RecordsAffected.out(), par_Parameters.in_ptr(), par_Options, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<ADODB::_Parameter> wrap_t<ADODB::_Command15>::CreateParameter(const bstr_t& par_Name, enum ADODB::DataTypeEnum par_Type, enum ADODB::ParameterDirectionEnum par_Direction, long par_Size, const variant_t& par_Value)
{
    ADODB::_Parameter* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->raw_CreateParameter(par_Name.in(), par_Type, par_Direction, par_Size, par_Value.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline com_ptr<ADODB::Parameters> wrap_t<ADODB::_Command15>::GetParameters()
{
    ADODB::Parameters* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_Parameters(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Command15>::PutCommandType(enum ADODB::CommandTypeEnum par_plCmdType)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_CommandType(par_plCmdType);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline ADODB::CommandTypeEnum wrap_t<ADODB::_Command15>::GetCommandType()
{
    enum ADODB::CommandTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_CommandType(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return enum ADODB::CommandTypeEnum(_result_);
}

inline bstr_t wrap_t<ADODB::_Command15>::GetName()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->get_Name(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Command15>::PutName(const bstr_t& par_pbstrName)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Command15*>(this)->put_Name(par_pbstrName.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Command15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Connection>::Cancel()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection*>(this)->raw_Cancel();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Connection15>::GetConnectionString()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_ConnectionString(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutConnectionString(const bstr_t& par_pbstr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_ConnectionString(par_pbstr.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Connection15>::GetCommandTimeout()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_CommandTimeout(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Connection15>::PutCommandTimeout(long par_plTimeout)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_CommandTimeout(par_plTimeout);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Connection15>::GetConnectionTimeout()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_ConnectionTimeout(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Connection15>::PutConnectionTimeout(long par_plTimeout)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_ConnectionTimeout(par_plTimeout);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Connection15>::GetVersion()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_Version(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Connection15>::Close()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_Close();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Connection15>::Execute(const bstr_t& par_CommandText, variant_t& par_RecordsAffected, long par_Options)
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_Execute(par_CommandText.in(), par_RecordsAffected.out(), par_Options, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline long wrap_t<ADODB::_Connection15>::BeginTrans()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_BeginTrans(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Connection15>::CommitTrans()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_CommitTrans();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Connection15>::RollbackTrans()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_RollbackTrans();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Connection15>::Open(const bstr_t& par_ConnectionString, const bstr_t& par_UserID, const bstr_t& par_Password, long par_Options)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_Open(par_ConnectionString.in(), par_UserID.in(), par_Password.in(), par_Options);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline com_ptr<ADODB::Errors> wrap_t<ADODB::_Connection15>::GetErrors()
{
    ADODB::Errors* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_Errors(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline bstr_t wrap_t<ADODB::_Connection15>::GetDefaultDatabase()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_DefaultDatabase(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutDefaultDatabase(const bstr_t& par_pbstr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_DefaultDatabase(par_pbstr.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline ADODB::IsolationLevelEnum wrap_t<ADODB::_Connection15>::GetIsolationLevel()
{
    enum ADODB::IsolationLevelEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_IsolationLevel(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return enum ADODB::IsolationLevelEnum(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutIsolationLevel(enum ADODB::IsolationLevelEnum par_Level)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_IsolationLevel(par_Level);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Connection15>::GetAttributes()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_Attributes(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Connection15>::PutAttributes(long par_plAttr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_Attributes(par_plAttr);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline ADODB::CursorLocationEnum wrap_t<ADODB::_Connection15>::GetCursorLocation()
{
    enum ADODB::CursorLocationEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_CursorLocation(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return enum ADODB::CursorLocationEnum(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutCursorLocation(enum ADODB::CursorLocationEnum par_plCursorLoc)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_CursorLocation(par_plCursorLoc);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline ADODB::ConnectModeEnum wrap_t<ADODB::_Connection15>::GetMode()
{
    enum ADODB::ConnectModeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_Mode(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return enum ADODB::ConnectModeEnum(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutMode(enum ADODB::ConnectModeEnum par_plMode)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_Mode(par_plMode);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Connection15>::GetProvider()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_Provider(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Connection15>::PutProvider(const bstr_t& par_pbstr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->put_Provider(par_pbstr.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Connection15>::GetState()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->get_State(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return _result_;
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Connection15>::OpenSchema(enum ADODB::SchemaEnum par_Schema, const variant_t& par_Restrictions, const variant_t& par_SchemaID)
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Connection15*>(this)->raw_OpenSchema(par_Schema, par_Restrictions.in(), par_SchemaID.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Connection15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_DynaCollection>::Append(const com_ptr<IDispatch>& par_Object)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_DynaCollection*>(this)->raw_Append(par_Object.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_DynaCollection*>(this), _hr_);
}

inline void wrap_t<ADODB::_DynaCollection>::Delete(const variant_t& par_Index)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_DynaCollection*>(this)->raw_Delete(par_Index.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_DynaCollection*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Parameter>::GetName()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Name(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Parameter>::PutName(const bstr_t& par_pbstr)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Name(par_pbstr.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::_Parameter>::GetValue()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Value(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Parameter>::PutValue(const variant_t& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Value(par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline ADODB::DataTypeEnum wrap_t<ADODB::_Parameter>::GetType()
{
    enum ADODB::DataTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Type(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return enum ADODB::DataTypeEnum(_result_);
}

inline void wrap_t<ADODB::_Parameter>::PutType(enum ADODB::DataTypeEnum par_psDataType)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Type(par_psDataType);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline void wrap_t<ADODB::_Parameter>::PutDirection(enum ADODB::ParameterDirectionEnum par_plParmDirection)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Direction(par_plParmDirection);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline ADODB::ParameterDirectionEnum wrap_t<ADODB::_Parameter>::GetDirection()
{
    enum ADODB::ParameterDirectionEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Direction(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return enum ADODB::ParameterDirectionEnum(_result_);
}

inline void wrap_t<ADODB::_Parameter>::PutPrecision(unsigned char par_pbPrecision)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Precision(par_pbPrecision);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline unsigned char wrap_t<ADODB::_Parameter>::GetPrecision()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Precision(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Parameter>::PutNumericScale(unsigned char par_pbScale)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_NumericScale(par_pbScale);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline unsigned char wrap_t<ADODB::_Parameter>::GetNumericScale()
{
    unsigned char _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_NumericScale(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Parameter>::PutSize(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Size(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline long wrap_t<ADODB::_Parameter>::GetSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Size(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Parameter>::AppendChunk(const variant_t& par_Val)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->raw_AppendChunk(par_Val.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline long wrap_t<ADODB::_Parameter>::GetAttributes()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->get_Attributes(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Parameter>::PutAttributes(long par_plParmAttribs)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Parameter*>(this)->put_Attributes(par_plParmAttribs);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Parameter*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset>::Cancel()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_Cancel();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline com_ptr<IUnknown> wrap_t<ADODB::_Recordset>::GetDataSource()
{
    IUnknown * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->get_DataSource(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset>::PutDataSource(const com_ptr<IUnknown>& par_ppunkDataSource)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->putref_DataSource(par_ppunkDataSource.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset>::Save(const bstr_t& par_FileName, enum ADODB::PersistFormatEnum par_PersistFormat)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_Save(par_FileName.in(), par_PersistFormat);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline com_ptr<IDispatch> wrap_t<ADODB::_Recordset>::GetActiveCommand()
{
    IDispatch * _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->get_ActiveCommand(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset>::PutStayInSync(bool par_pbStayInSync)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->put_StayInSync(par_pbStayInSync ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline bool wrap_t<ADODB::_Recordset>::GetStayInSync()
{
    VARIANT_BOOL _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->get_StayInSync(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return _result_ != COMET_VARIANT_FALSE;
}

inline bstr_t wrap_t<ADODB::_Recordset>::GetString(enum ADODB::StringFormatEnum par_StringFormat, long par_NumRows, const bstr_t& par_ColumnDelimeter, const bstr_t& par_RowDelimeter, const bstr_t& par_NullExpr)
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_GetString(par_StringFormat, par_NumRows, par_ColumnDelimeter.in(), par_RowDelimeter.in(), par_NullExpr.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return auto_attach(_result_);
}

inline bstr_t wrap_t<ADODB::_Recordset>::GetDataMember()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->get_DataMember(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset>::PutDataMember(const bstr_t& par_pbstrDataMember)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->put_DataMember(par_pbstrDataMember.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline ADODB::CompareEnum wrap_t<ADODB::_Recordset>::CompareBookmarks(const variant_t& par_Bookmark1, const variant_t& par_Bookmark2)
{
    enum ADODB::CompareEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_CompareBookmarks(par_Bookmark1.in(), par_Bookmark2.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return enum ADODB::CompareEnum(_result_);
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Recordset>::Clone(enum ADODB::LockTypeEnum par_LockType)
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_Clone(par_LockType, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset>::Resync(enum ADODB::AffectEnum par_AffectRecords, enum ADODB::ResyncEnum par_ResyncValues)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset*>(this)->raw_Resync(par_AffectRecords, par_ResyncValues);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset*>(this), _hr_);
}

inline ADODB::PositionEnum wrap_t<ADODB::_Recordset15>::GetAbsolutePosition()
{
    enum ADODB::PositionEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_AbsolutePosition(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::PositionEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutAbsolutePosition(enum ADODB::PositionEnum par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_AbsolutePosition(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::PutrefActiveConnection(const com_ptr<IDispatch>& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->putref_ActiveConnection(par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::PutActiveConnection(const variant_t& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_ActiveConnection(par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetActiveConnection()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_ActiveConnection(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline bool wrap_t<ADODB::_Recordset15>::GetBOF()
{
    VARIANT_BOOL _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_BOF(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_ != COMET_VARIANT_FALSE;
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetBookmark()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Bookmark(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutBookmark(const variant_t& par_pvBookmark)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_Bookmark(par_pvBookmark.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Recordset15>::GetCacheSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_CacheSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Recordset15>::PutCacheSize(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_CacheSize(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline ADODB::CursorTypeEnum wrap_t<ADODB::_Recordset15>::GetCursorType()
{
    enum ADODB::CursorTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_CursorType(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::CursorTypeEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutCursorType(enum ADODB::CursorTypeEnum par_plCursorType)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_CursorType(par_plCursorType);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline bool wrap_t<ADODB::_Recordset15>::GetEOF()
{
    VARIANT_BOOL _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_EOF(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_ != COMET_VARIANT_FALSE;
}

inline com_ptr<ADODB::Fields> wrap_t<ADODB::_Recordset15>::GetFields()
{
    ADODB::Fields* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Fields(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline ADODB::LockTypeEnum wrap_t<ADODB::_Recordset15>::GetLockType()
{
    enum ADODB::LockTypeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_LockType(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::LockTypeEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutLockType(enum ADODB::LockTypeEnum par_plLockType)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_LockType(par_plLockType);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Recordset15>::GetMaxRecords()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_MaxRecords(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Recordset15>::PutMaxRecords(long par_plMaxRecords)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_MaxRecords(par_plMaxRecords);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Recordset15>::GetRecordCount()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_RecordCount(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Recordset15>::PutrefSource(const com_ptr<IDispatch>& par_pvSource)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->putref_Source(par_pvSource.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::PutSource(const bstr_t& par_pvSource)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_Source(par_pvSource.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetSource()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Source(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::AddNew(const variant_t& par_FieldList, const variant_t& par_Values)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_AddNew(par_FieldList.in(), par_Values.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::CancelUpdate()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_CancelUpdate();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Close()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Close();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Delete(enum ADODB::AffectEnum par_AffectRecords)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Delete(par_AffectRecords);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetRows(long par_Rows, const variant_t& par_Start, const variant_t& par_Fields)
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_GetRows(par_Rows, par_Start.in(), par_Fields.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::Move(long par_NumRecords, const variant_t& par_Start)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Move(par_NumRecords, par_Start.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::MoveNext()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_MoveNext();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::MovePrevious()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_MovePrevious();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::MoveFirst()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_MoveFirst();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::MoveLast()
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_MoveLast();
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Open(const variant_t& par_Source, const variant_t& par_ActiveConnection, enum ADODB::CursorTypeEnum par_CursorType, enum ADODB::LockTypeEnum par_LockType, long par_Options)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Open(par_Source.in(), par_ActiveConnection.in(), par_CursorType, par_LockType, par_Options);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Requery(long par_Options)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Requery(par_Options);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::_xResync(enum ADODB::AffectEnum par_AffectRecords)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw__xResync(par_AffectRecords);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Update(const variant_t& par_Fields, const variant_t& par_Values)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Update(par_Fields.in(), par_Values.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline ADODB::PositionEnum wrap_t<ADODB::_Recordset15>::GetAbsolutePage()
{
    enum ADODB::PositionEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_AbsolutePage(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::PositionEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutAbsolutePage(enum ADODB::PositionEnum par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_AbsolutePage(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline ADODB::EditModeEnum wrap_t<ADODB::_Recordset15>::GetEditMode()
{
    enum ADODB::EditModeEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_EditMode(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::EditModeEnum(_result_);
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetFilter()
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Filter(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutFilter(const variant_t& par_Criteria)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_Filter(par_Criteria.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Recordset15>::GetPageCount()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_PageCount(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::_Recordset15>::GetPageSize()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_PageSize(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline void wrap_t<ADODB::_Recordset15>::PutPageSize(long par_pl)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_PageSize(par_pl);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline bstr_t wrap_t<ADODB::_Recordset15>::GetSort()
{
    BSTR _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Sort(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutSort(const bstr_t& par_Criteria)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_Sort(par_Criteria.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline long wrap_t<ADODB::_Recordset15>::GetStatus()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Status(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline long wrap_t<ADODB::_Recordset15>::GetState()
{
    long _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_State(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_;
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Recordset15>::_xClone()
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw__xClone(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::UpdateBatch(enum ADODB::AffectEnum par_AffectRecords)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_UpdateBatch(par_AffectRecords);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::CancelBatch(enum ADODB::AffectEnum par_AffectRecords)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_CancelBatch(par_AffectRecords);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline ADODB::CursorLocationEnum wrap_t<ADODB::_Recordset15>::GetCursorLocation()
{
    enum ADODB::CursorLocationEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_CursorLocation(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::CursorLocationEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutCursorLocation(enum ADODB::CursorLocationEnum par_plCursorLoc)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_CursorLocation(par_plCursorLoc);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline com_ptr<ADODB::_Recordset> wrap_t<ADODB::_Recordset15>::NextRecordset(variant_t& par_RecordsAffected)
{
    ADODB::_Recordset* _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_NextRecordset(par_RecordsAffected.out(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline bool wrap_t<ADODB::_Recordset15>::Supports(enum ADODB::CursorOptionEnum par_CursorOptions)
{
    VARIANT_BOOL _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Supports(par_CursorOptions, &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return _result_ != COMET_VARIANT_FALSE;
}

inline variant_t wrap_t<ADODB::_Recordset15>::GetCollect(const variant_t& par_Index)
{
    VARIANT _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_Collect(par_Index.in(), &_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return auto_attach(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutCollect(const variant_t& par_Index, const variant_t& par_pvar)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_Collect(par_Index.in(), par_pvar.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline ADODB::MarshalOptionsEnum wrap_t<ADODB::_Recordset15>::GetMarshalOptions()
{
    enum ADODB::MarshalOptionsEnum _result_;
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->get_MarshalOptions(&_result_);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
    return enum ADODB::MarshalOptionsEnum(_result_);
}

inline void wrap_t<ADODB::_Recordset15>::PutMarshalOptions(enum ADODB::MarshalOptionsEnum par_peMarshal)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->put_MarshalOptions(par_peMarshal);
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}

inline void wrap_t<ADODB::_Recordset15>::Find(const bstr_t& par_Criteria, long par_SkipRecords, enum ADODB::SearchDirectionEnum par_SearchDirection, const variant_t& par_Start)
{
    HRESULT _hr_ = reinterpret_cast<ADODB::_Recordset15*>(this)->raw_Find(par_Criteria.in(), par_SkipRecords, par_SearchDirection, par_Start.in());
    if (FAILED(_hr_)) throw_com_error(reinterpret_cast<ADODB::_Recordset15*>(this), _hr_);
}


namespace ADODB {

//
// Impl Wrappers (declaration)
//

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000517-0000-0010-8000-00AA006D2EA4") ADOCommandConstructionImpl : public _S
{
    typedef ADOCommandConstruction interface_is;


    // Raw method wrappers
    STDMETHODIMP get_OLEDBCommand(IUnknown ** par_ppOLEDBCommand);
    STDMETHODIMP put_OLEDBCommand(IUnknown * par_ppOLEDBCommand);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<IUnknown> GetOLEDBCommand();
    void PutOLEDBCommand(const com_ptr<IUnknown>& par_ppOLEDBCommand);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000551-0000-0010-8000-00AA006D2EA4") ADOConnectionConstructionImpl : public ADOConnectionConstruction15Impl<_B, _S, _TL>
{
    typedef ADOConnectionConstruction interface_is;


    // Raw method wrappers

    //
    // These are the methods you need to implement: 
    //
/*
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000516-0000-0010-8000-00AA006D2EA4") ADOConnectionConstruction15Impl : public _S
{
    typedef ADOConnectionConstruction15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_DSO(IUnknown ** par_ppDSO);
    STDMETHODIMP get_Session(IUnknown ** par_ppSession);
    STDMETHODIMP raw_WrapDSOandSession(IUnknown * par_pDSO, IUnknown * par_pSession);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<IUnknown> GetDSO();
    com_ptr<IUnknown> GetSession();
    void WrapDSOandSession(const com_ptr<IUnknown>& par_pDSO, const com_ptr<IUnknown>& par_pSession);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000283-0000-0010-8000-00AA006D2EA4") ADORecordsetConstructionImpl : public impl_dispatch<_S, _TL>
{
    typedef ADORecordsetConstruction interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Rowset(IUnknown ** par_ppRowset);
    STDMETHODIMP put_Rowset(IUnknown * par_ppRowset);
    STDMETHODIMP get_Chapter(long* par_plChapter);
    STDMETHODIMP put_Chapter(long par_plChapter);
    STDMETHODIMP get_RowPosition(IUnknown ** par_ppRowPos);
    STDMETHODIMP put_RowPosition(IUnknown * par_ppRowPos);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<IUnknown> GetRowset();
    void PutRowset(const com_ptr<IUnknown>& par_ppRowset);
    long GetChapter();
    void PutChapter(long par_plChapter);
    com_ptr<IUnknown> GetRowPosition();
    void PutRowPosition(const com_ptr<IUnknown>& par_ppRowPos);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000400-0000-0010-8000-00AA006D2EA4") ConnectionEventsImpl : public impl_dispatch<_S, _TL>
{
    typedef ConnectionEvents interface_is;

    private:
        STDMETHOD(Invoke)(DISPID id, REFIID riid, LCID lcid, WORD Flags, DISPPARAMS *DispParams, VARIANT* Result, EXCEPINFO* pe, UINT* pu);
    //
    // These are the methods you need to implement: 
    //
/*
    void InfoMessage(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void BeginTransComplete(long par_TransactionLevel, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void CommitTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void RollbackTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void WillExecute(bstr_t& par_Source, enum CursorTypeEnum& par_CursorType, enum LockTypeEnum& par_LockType, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
    void ExecuteComplete(long par_RecordsAffected, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
    void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void ConnectComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void Disconnect(enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000402-0000-0010-8000-00AA006D2EA4") ConnectionEventsVtImpl : public _S
{
    typedef ConnectionEventsVt interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_InfoMessage(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_BeginTransComplete(long par_TransactionLevel, Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_CommitTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_RollbackTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_WillExecute(BSTR* par_Source, enum CursorTypeEnum* par_CursorType, enum LockTypeEnum* par_LockType, long* par_Options, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection);
    STDMETHODIMP raw_ExecuteComplete(long par_RecordsAffected, Error* par_pError, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection);
    STDMETHODIMP raw_WillConnect(BSTR* par_ConnectionString, BSTR* par_UserID, BSTR* par_Password, long* par_Options, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_ConnectComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);
    STDMETHODIMP raw_Disconnect(enum EventStatusEnum* par_adStatus, _Connection* par_pConnection);

    //
    // These are the methods you need to implement: 
    //
/*
    void InfoMessage(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void BeginTransComplete(long par_TransactionLevel, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void CommitTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void RollbackTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void WillExecute(bstr_t& par_Source, enum CursorTypeEnum& par_CursorType, enum LockTypeEnum& par_LockType, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
    void ExecuteComplete(long par_RecordsAffected, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
    void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void ConnectComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
    void Disconnect(enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000500-0000-0010-8000-00AA006D2EA4") ErrorImpl : public impl_dispatch<_S, _TL>
{
    typedef Error interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Number(long* par_pl);
    STDMETHODIMP get_Source(BSTR* par_pbstr);
    STDMETHODIMP get_Description(BSTR* par_pbstr);
    STDMETHODIMP get_HelpFile(BSTR* par_pbstr);
    STDMETHODIMP get_HelpContext(long* par_pl);
    STDMETHODIMP get_SQLState(BSTR* par_pbstr);
    STDMETHODIMP get_NativeError(long* par_pl);

    //
    // These are the methods you need to implement: 
    //
/*
    long GetNumber();
    bstr_t GetSource();
    bstr_t GetDescription();
    bstr_t GetHelpFile();
    long GetHelpContext();
    bstr_t GetSQLState();
    long GetNativeError();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000501-0000-0010-8000-00AA006D2EA4") ErrorsImpl : public _CollectionImpl<_B, _S, _TL>
{
    typedef Errors interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Item(VARIANT par_Index, Error** par_ppvObject);
    STDMETHODIMP raw_Clear();

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<Error> GetItem(const variant_t& par_Index);
    void Clear();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054C-0000-0010-8000-00AA006D2EA4") FieldImpl : public _ADOImpl<_B, _S, _TL>
{
    typedef Field interface_is;


    // Raw method wrappers
    STDMETHODIMP get_ActualSize(long* par_pl);
    STDMETHODIMP get_Attributes(long* par_pl);
    STDMETHODIMP get_DefinedSize(long* par_pl);
    STDMETHODIMP get_Name(BSTR* par_pbstr);
    STDMETHODIMP get_Type(enum DataTypeEnum* par_pDataType);
    STDMETHODIMP get_Value(VARIANT* par_pvar);
    STDMETHODIMP put_Value(VARIANT par_pvar);
    STDMETHODIMP get_Precision(unsigned char* par_pbPrecision);
    STDMETHODIMP get_NumericScale(unsigned char* par_pbNumericScale);
    STDMETHODIMP raw_AppendChunk(VARIANT par_Data);
    STDMETHODIMP raw_GetChunk(long par_Length, VARIANT* par_pvar);
    STDMETHODIMP get_OriginalValue(VARIANT* par_pvar);
    STDMETHODIMP get_UnderlyingValue(VARIANT* par_pvar);
    STDMETHODIMP get_DataFormat(IUnknown ** par_ppiDF);
    STDMETHODIMP putref_DataFormat(IUnknown * par_ppiDF);
    STDMETHODIMP put_Precision(unsigned char par_pbPrecision);
    STDMETHODIMP put_NumericScale(unsigned char par_pbNumericScale);
    STDMETHODIMP put_Type(enum DataTypeEnum par_pDataType);
    STDMETHODIMP put_DefinedSize(long par_pl);
    STDMETHODIMP put_Attributes(long par_pl);

    //
    // These are the methods you need to implement: 
    //
/*
    long GetActualSize();
    long GetAttributes();
    long GetDefinedSize();
    bstr_t GetName();
    DataTypeEnum GetType();
    variant_t GetValue();
    void PutValue(const variant_t& par_pvar);
    unsigned char GetPrecision();
    unsigned char GetNumericScale();
    void AppendChunk(const variant_t& par_Data);
    variant_t GetChunk(long par_Length);
    variant_t GetOriginalValue();
    variant_t GetUnderlyingValue();
    com_ptr<IUnknown> GetDataFormat();
    void PutDataFormat(const com_ptr<IUnknown>& par_ppiDF);
    void PutPrecision(unsigned char par_pbPrecision);
    void PutNumericScale(unsigned char par_pbNumericScale);
    void PutType(enum DataTypeEnum par_pDataType);
    void PutDefinedSize(long par_pl);
    void PutAttributes(long par_pl);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000505-0000-0010-8000-00AA006D2EA4") Field15Impl : public _ADOImpl<_B, _S, _TL>
{
    typedef Field15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_ActualSize(long* par_pl);
    STDMETHODIMP get_Attributes(long* par_pl);
    STDMETHODIMP get_DefinedSize(long* par_pl);
    STDMETHODIMP get_Name(BSTR* par_pbstr);
    STDMETHODIMP get_Type(enum DataTypeEnum* par_pDataType);
    STDMETHODIMP get_Value(VARIANT* par_pvar);
    STDMETHODIMP put_Value(VARIANT par_pvar);
    STDMETHODIMP get_Precision(unsigned char* par_pbPrecision);
    STDMETHODIMP get_NumericScale(unsigned char* par_pbNumericScale);
    STDMETHODIMP raw_AppendChunk(VARIANT par_Data);
    STDMETHODIMP raw_GetChunk(long par_Length, VARIANT* par_pvar);
    STDMETHODIMP get_OriginalValue(VARIANT* par_pvar);
    STDMETHODIMP get_UnderlyingValue(VARIANT* par_pvar);

    //
    // These are the methods you need to implement: 
    //
/*
    long GetActualSize();
    long GetAttributes();
    long GetDefinedSize();
    bstr_t GetName();
    DataTypeEnum GetType();
    variant_t GetValue();
    void PutValue(const variant_t& par_pvar);
    unsigned char GetPrecision();
    unsigned char GetNumericScale();
    void AppendChunk(const variant_t& par_Data);
    variant_t GetChunk(long par_Length);
    variant_t GetOriginalValue();
    variant_t GetUnderlyingValue();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054D-0000-0010-8000-00AA006D2EA4") FieldsImpl : public Fields15Impl<_B, _S, _TL>
{
    typedef Fields interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_Append(BSTR par_Name, enum DataTypeEnum par_Type, long par_DefinedSize, enum FieldAttributeEnum par_Attrib);
    STDMETHODIMP raw_Delete(VARIANT par_Index);

    //
    // These are the methods you need to implement: 
    //
/*
    void Append(const bstr_t& par_Name, enum DataTypeEnum par_Type, long par_DefinedSize = 0, enum FieldAttributeEnum par_Attrib = enum FieldAttributeEnum(-1));
    void Delete(const variant_t& par_Index);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000506-0000-0010-8000-00AA006D2EA4") Fields15Impl : public _CollectionImpl<_B, _S, _TL>
{
    typedef Fields15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Item(VARIANT par_Index, Field** par_ppvObject);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<Field> GetItem(const variant_t& par_Index);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050D-0000-0010-8000-00AA006D2EA4") ParametersImpl : public _DynaCollectionImpl<_B, _S, _TL>
{
    typedef Parameters interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Item(VARIANT par_Index, _Parameter** par_ppvObject);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<_Parameter> GetItem(const variant_t& par_Index);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000504-0000-0010-8000-00AA006D2EA4") PropertiesImpl : public _CollectionImpl<_B, _S, _TL>
{
    typedef Properties interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Item(VARIANT par_Index, Property** par_ppvObject);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<Property> GetItem(const variant_t& par_Index);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000503-0000-0010-8000-00AA006D2EA4") PropertyImpl : public impl_dispatch<_S, _TL>
{
    typedef Property interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Value(VARIANT* par_pval);
    STDMETHODIMP put_Value(VARIANT par_pval);
    STDMETHODIMP get_Name(BSTR* par_pbstr);
    STDMETHODIMP get_Type(enum DataTypeEnum* par_ptype);
    STDMETHODIMP get_Attributes(long* par_plAttributes);
    STDMETHODIMP put_Attributes(long par_plAttributes);

    //
    // These are the methods you need to implement: 
    //
/*
    variant_t GetValue();
    void PutValue(const variant_t& par_pval);
    bstr_t GetName();
    DataTypeEnum GetType();
    long GetAttributes();
    void PutAttributes(long par_plAttributes);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000266-0000-0010-8000-00AA006D2EA4") RecordsetEventsImpl : public impl_dispatch<_S, _TL>
{
    typedef RecordsetEvents interface_is;

    private:
        STDMETHOD(Invoke)(DISPID id, REFIID riid, LCID lcid, WORD Flags, DISPPARAMS *DispParams, VARIANT* Result, EXCEPINFO* pe, UINT* pu);
    //
    // These are the methods you need to implement: 
    //
/*
    void WillChangeField(long par_cFields, const variant_t& par_Fields, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void RecordsetChangeComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void MoveComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void EndOfRecordset(bool& par_fMoreData, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FetchComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000403-0000-0010-8000-00AA006D2EA4") RecordsetEventsVtImpl : public _S
{
    typedef RecordsetEventsVt interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_WillChangeField(long par_cFields, VARIANT par_Fields, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_FieldChangeComplete(long par_cFields, VARIANT par_Fields, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_RecordsetChangeComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_MoveComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_EndOfRecordset(VARIANT_BOOL* par_fMoreData, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);
    STDMETHODIMP raw_FetchComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset);

    //
    // These are the methods you need to implement: 
    //
/*
    void WillChangeField(long par_cFields, const variant_t& par_Fields, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void RecordsetChangeComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void MoveComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void EndOfRecordset(bool& par_fMoreData, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
    void FetchComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000534-0000-0010-8000-00AA006D2EA4") _ADOImpl : public impl_dispatch<_S, _TL>
{
    typedef _ADO interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Properties(Properties** par_ppvObject);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<Properties> GetProperties();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000512-0000-0010-8000-00AA006D2EA4") _CollectionImpl : public impl_dispatch<_S, _TL>
{
    typedef _Collection interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Count(long* par_c);
    STDMETHODIMP raw__NewEnum(IUnknown ** par_ppvObject);
    STDMETHODIMP raw_Refresh();

    //
    // These are the methods you need to implement: 
    //
/*
    long GetCount();
    com_ptr<IUnknown> _NewEnum();
    void Refresh();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054E-0000-0010-8000-00AA006D2EA4") _CommandImpl : public _Command15Impl<_B, _S, _TL>
{
    typedef _Command interface_is;


    // Raw method wrappers
    STDMETHODIMP get_State(long* par_plObjState);
    STDMETHODIMP raw_Cancel();

    //
    // These are the methods you need to implement: 
    //
/*
    long GetState();
    void Cancel();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000508-0000-0010-8000-00AA006D2EA4") _Command15Impl : public _ADOImpl<_B, _S, _TL>
{
    typedef _Command15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_ActiveConnection(_Connection** par_ppvObject);
    STDMETHODIMP putref_ActiveConnection(_Connection* par_ppvObject);
    STDMETHODIMP put_ActiveConnection(VARIANT par_ppvObject);
    STDMETHODIMP get_CommandText(BSTR* par_pbstr);
    STDMETHODIMP put_CommandText(BSTR par_pbstr);
    STDMETHODIMP get_CommandTimeout(long* par_pl);
    STDMETHODIMP put_CommandTimeout(long par_pl);
    STDMETHODIMP get_Prepared(VARIANT_BOOL* par_pfPrepared);
    STDMETHODIMP put_Prepared(VARIANT_BOOL par_pfPrepared);
    STDMETHODIMP raw_Execute(VARIANT* par_RecordsAffected, VARIANT* par_Parameters, long par_Options, _Recordset** par_ppiRs);
    STDMETHODIMP raw_CreateParameter(BSTR par_Name, enum DataTypeEnum par_Type, enum ParameterDirectionEnum par_Direction, long par_Size, VARIANT par_Value, _Parameter** par_ppiprm);
    STDMETHODIMP get_Parameters(Parameters** par_ppvObject);
    STDMETHODIMP put_CommandType(enum CommandTypeEnum par_plCmdType);
    STDMETHODIMP get_CommandType(enum CommandTypeEnum* par_plCmdType);
    STDMETHODIMP get_Name(BSTR* par_pbstrName);
    STDMETHODIMP put_Name(BSTR par_pbstrName);

    //
    // These are the methods you need to implement: 
    //
/*
    com_ptr<_Connection> GetActiveConnection();
    void PutrefActiveConnection(const com_ptr<_Connection>& par_ppvObject);
    void PutActiveConnection(const variant_t& par_ppvObject);
    bstr_t GetCommandText();
    void PutCommandText(const bstr_t& par_pbstr);
    long GetCommandTimeout();
    void PutCommandTimeout(long par_pl);
    bool GetPrepared();
    void PutPrepared(bool par_pfPrepared);
    com_ptr<_Recordset> Execute(variant_t& par_RecordsAffected, const variant_t& par_Parameters = variant_t::missing(), long par_Options = -1);
    com_ptr<_Parameter> CreateParameter(const bstr_t& par_Name = L"", enum DataTypeEnum par_Type = enum DataTypeEnum(0), enum ParameterDirectionEnum par_Direction = enum ParameterDirectionEnum(1), long par_Size = 0, const variant_t& par_Value = variant_t::missing());
    com_ptr<Parameters> GetParameters();
    void PutCommandType(enum CommandTypeEnum par_plCmdType);
    CommandTypeEnum GetCommandType();
    bstr_t GetName();
    void PutName(const bstr_t& par_pbstrName);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000550-0000-0010-8000-00AA006D2EA4") _ConnectionImpl : public _Connection15Impl<_B, _S, _TL>
{
    typedef _Connection interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_Cancel();

    //
    // These are the methods you need to implement: 
    //
/*
    void Cancel();
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000515-0000-0010-8000-00AA006D2EA4") _Connection15Impl : public _ADOImpl<_B, _S, _TL>
{
    typedef _Connection15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_ConnectionString(BSTR* par_pbstr);
    STDMETHODIMP put_ConnectionString(BSTR par_pbstr);
    STDMETHODIMP get_CommandTimeout(long* par_plTimeout);
    STDMETHODIMP put_CommandTimeout(long par_plTimeout);
    STDMETHODIMP get_ConnectionTimeout(long* par_plTimeout);
    STDMETHODIMP put_ConnectionTimeout(long par_plTimeout);
    STDMETHODIMP get_Version(BSTR* par_pbstr);
    STDMETHODIMP raw_Close();
    STDMETHODIMP raw_Execute(BSTR par_CommandText, VARIANT* par_RecordsAffected, long par_Options, _Recordset** par_ppiRset);
    STDMETHODIMP raw_BeginTrans(long* par_TransactionLevel);
    STDMETHODIMP raw_CommitTrans();
    STDMETHODIMP raw_RollbackTrans();
    STDMETHODIMP raw_Open(BSTR par_ConnectionString, BSTR par_UserID, BSTR par_Password, long par_Options);
    STDMETHODIMP get_Errors(Errors** par_ppvObject);
    STDMETHODIMP get_DefaultDatabase(BSTR* par_pbstr);
    STDMETHODIMP put_DefaultDatabase(BSTR par_pbstr);
    STDMETHODIMP get_IsolationLevel(enum IsolationLevelEnum* par_Level);
    STDMETHODIMP put_IsolationLevel(enum IsolationLevelEnum par_Level);
    STDMETHODIMP get_Attributes(long* par_plAttr);
    STDMETHODIMP put_Attributes(long par_plAttr);
    STDMETHODIMP get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc);
    STDMETHODIMP put_CursorLocation(enum CursorLocationEnum par_plCursorLoc);
    STDMETHODIMP get_Mode(enum ConnectModeEnum* par_plMode);
    STDMETHODIMP put_Mode(enum ConnectModeEnum par_plMode);
    STDMETHODIMP get_Provider(BSTR* par_pbstr);
    STDMETHODIMP put_Provider(BSTR par_pbstr);
    STDMETHODIMP get_State(long* par_plObjState);
    STDMETHODIMP raw_OpenSchema(enum SchemaEnum par_Schema, VARIANT par_Restrictions, VARIANT par_SchemaID, _Recordset** par_pprset);

    //
    // These are the methods you need to implement: 
    //
/*
    bstr_t GetConnectionString();
    void PutConnectionString(const bstr_t& par_pbstr);
    long GetCommandTimeout();
    void PutCommandTimeout(long par_plTimeout);
    long GetConnectionTimeout();
    void PutConnectionTimeout(long par_plTimeout);
    bstr_t GetVersion();
    void Close();
    com_ptr<_Recordset> Execute(const bstr_t& par_CommandText, variant_t& par_RecordsAffected, long par_Options = -1);
    long BeginTrans();
    void CommitTrans();
    void RollbackTrans();
    void Open(const bstr_t& par_ConnectionString = L"", const bstr_t& par_UserID = L"", const bstr_t& par_Password = L"", long par_Options = -1);
    com_ptr<Errors> GetErrors();
    bstr_t GetDefaultDatabase();
    void PutDefaultDatabase(const bstr_t& par_pbstr);
    IsolationLevelEnum GetIsolationLevel();
    void PutIsolationLevel(enum IsolationLevelEnum par_Level);
    long GetAttributes();
    void PutAttributes(long par_plAttr);
    CursorLocationEnum GetCursorLocation();
    void PutCursorLocation(enum CursorLocationEnum par_plCursorLoc);
    ConnectModeEnum GetMode();
    void PutMode(enum ConnectModeEnum par_plMode);
    bstr_t GetProvider();
    void PutProvider(const bstr_t& par_pbstr);
    long GetState();
    com_ptr<_Recordset> OpenSchema(enum SchemaEnum par_Schema, const variant_t& par_Restrictions = variant_t::missing(), const variant_t& par_SchemaID = variant_t::missing());
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("00000513-0000-0010-8000-00AA006D2EA4") _DynaCollectionImpl : public _CollectionImpl<_B, _S, _TL>
{
    typedef _DynaCollection interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_Append(IDispatch * par_Object);
    STDMETHODIMP raw_Delete(VARIANT par_Index);

    //
    // These are the methods you need to implement: 
    //
/*
    void Append(const com_ptr<IDispatch>& par_Object);
    void Delete(const variant_t& par_Index);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050C-0000-0010-8000-00AA006D2EA4") _ParameterImpl : public _ADOImpl<_B, _S, _TL>
{
    typedef _Parameter interface_is;


    // Raw method wrappers
    STDMETHODIMP get_Name(BSTR* par_pbstr);
    STDMETHODIMP put_Name(BSTR par_pbstr);
    STDMETHODIMP get_Value(VARIANT* par_pvar);
    STDMETHODIMP put_Value(VARIANT par_pvar);
    STDMETHODIMP get_Type(enum DataTypeEnum* par_psDataType);
    STDMETHODIMP put_Type(enum DataTypeEnum par_psDataType);
    STDMETHODIMP put_Direction(enum ParameterDirectionEnum par_plParmDirection);
    STDMETHODIMP get_Direction(enum ParameterDirectionEnum* par_plParmDirection);
    STDMETHODIMP put_Precision(unsigned char par_pbPrecision);
    STDMETHODIMP get_Precision(unsigned char* par_pbPrecision);
    STDMETHODIMP put_NumericScale(unsigned char par_pbScale);
    STDMETHODIMP get_NumericScale(unsigned char* par_pbScale);
    STDMETHODIMP put_Size(long par_pl);
    STDMETHODIMP get_Size(long* par_pl);
    STDMETHODIMP raw_AppendChunk(VARIANT par_Val);
    STDMETHODIMP get_Attributes(long* par_plParmAttribs);
    STDMETHODIMP put_Attributes(long par_plParmAttribs);

    //
    // These are the methods you need to implement: 
    //
/*
    bstr_t GetName();
    void PutName(const bstr_t& par_pbstr);
    variant_t GetValue();
    void PutValue(const variant_t& par_pvar);
    DataTypeEnum GetType();
    void PutType(enum DataTypeEnum par_psDataType);
    void PutDirection(enum ParameterDirectionEnum par_plParmDirection);
    ParameterDirectionEnum GetDirection();
    void PutPrecision(unsigned char par_pbPrecision);
    unsigned char GetPrecision();
    void PutNumericScale(unsigned char par_pbScale);
    unsigned char GetNumericScale();
    void PutSize(long par_pl);
    long GetSize();
    void AppendChunk(const variant_t& par_Val);
    long GetAttributes();
    void PutAttributes(long par_plParmAttribs);
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000054F-0000-0010-8000-00AA006D2EA4") _RecordsetImpl : public _Recordset15Impl<_B, _S, _TL>
{
    typedef _Recordset interface_is;


    // Raw method wrappers
    STDMETHODIMP raw_Cancel();
    STDMETHODIMP get_DataSource(IUnknown ** par_ppunkDataSource);
    STDMETHODIMP putref_DataSource(IUnknown * par_ppunkDataSource);
    STDMETHODIMP raw_Save(BSTR par_FileName, enum PersistFormatEnum par_PersistFormat);
    STDMETHODIMP get_ActiveCommand(IDispatch ** par_ppCmd);
    STDMETHODIMP put_StayInSync(VARIANT_BOOL par_pbStayInSync);
    STDMETHODIMP get_StayInSync(VARIANT_BOOL* par_pbStayInSync);
    STDMETHODIMP raw_GetString(enum StringFormatEnum par_StringFormat, long par_NumRows, BSTR par_ColumnDelimeter, BSTR par_RowDelimeter, BSTR par_NullExpr, BSTR* par_pRetString);
    STDMETHODIMP get_DataMember(BSTR* par_pbstrDataMember);
    STDMETHODIMP put_DataMember(BSTR par_pbstrDataMember);
    STDMETHODIMP raw_CompareBookmarks(VARIANT par_Bookmark1, VARIANT par_Bookmark2, enum CompareEnum* par_pCompare);
    STDMETHODIMP raw_Clone(enum LockTypeEnum par_LockType, _Recordset** par_ppvObject);
    STDMETHODIMP raw_Resync(enum AffectEnum par_AffectRecords, enum ResyncEnum par_ResyncValues);

    //
    // These are the methods you need to implement: 
    //
/*
    void Cancel();
    com_ptr<IUnknown> GetDataSource();
    void PutDataSource(const com_ptr<IUnknown>& par_ppunkDataSource);
    void Save(const bstr_t& par_FileName = (BSTR)0, enum PersistFormatEnum par_PersistFormat = enum PersistFormatEnum(0));
    com_ptr<IDispatch> GetActiveCommand();
    void PutStayInSync(bool par_pbStayInSync);
    bool GetStayInSync();
    bstr_t GetString(enum StringFormatEnum par_StringFormat = enum StringFormatEnum(2), long par_NumRows = -1, const bstr_t& par_ColumnDelimeter = (BSTR)0, const bstr_t& par_RowDelimeter = (BSTR)0, const bstr_t& par_NullExpr = (BSTR)0);
    bstr_t GetDataMember();
    void PutDataMember(const bstr_t& par_pbstrDataMember);
    CompareEnum CompareBookmarks(const variant_t& par_Bookmark1, const variant_t& par_Bookmark2);
    com_ptr<_Recordset> Clone(enum LockTypeEnum par_LockType = enum LockTypeEnum(-1));
    void Resync(enum AffectEnum par_AffectRecords = enum AffectEnum(3), enum ResyncEnum par_ResyncValues = enum ResyncEnum(2));
*/
};

template<typename _B, typename _S, typename _TL>
struct ATL_NO_VTABLE DECLSPEC_UUID("0000050E-0000-0010-8000-00AA006D2EA4") _Recordset15Impl : public _ADOImpl<_B, _S, _TL>
{
    typedef _Recordset15 interface_is;


    // Raw method wrappers
    STDMETHODIMP get_AbsolutePosition(enum PositionEnum* par_pl);
    STDMETHODIMP put_AbsolutePosition(enum PositionEnum par_pl);
    STDMETHODIMP putref_ActiveConnection(IDispatch * par_pvar);
    STDMETHODIMP put_ActiveConnection(VARIANT par_pvar);
    STDMETHODIMP get_ActiveConnection(VARIANT* par_pvar);
    STDMETHODIMP get_BOF(VARIANT_BOOL* par_pb);
    STDMETHODIMP get_Bookmark(VARIANT* par_pvBookmark);
    STDMETHODIMP put_Bookmark(VARIANT par_pvBookmark);
    STDMETHODIMP get_CacheSize(long* par_pl);
    STDMETHODIMP put_CacheSize(long par_pl);
    STDMETHODIMP get_CursorType(enum CursorTypeEnum* par_plCursorType);
    STDMETHODIMP put_CursorType(enum CursorTypeEnum par_plCursorType);
    STDMETHODIMP get_EOF(VARIANT_BOOL* par_pb);
    STDMETHODIMP get_Fields(Fields** par_ppvObject);
    STDMETHODIMP get_LockType(enum LockTypeEnum* par_plLockType);
    STDMETHODIMP put_LockType(enum LockTypeEnum par_plLockType);
    STDMETHODIMP get_MaxRecords(long* par_plMaxRecords);
    STDMETHODIMP put_MaxRecords(long par_plMaxRecords);
    STDMETHODIMP get_RecordCount(long* par_pl);
    STDMETHODIMP putref_Source(IDispatch * par_pvSource);
    STDMETHODIMP put_Source(BSTR par_pvSource);
    STDMETHODIMP get_Source(VARIANT* par_pvSource);
    STDMETHODIMP raw_AddNew(VARIANT par_FieldList, VARIANT par_Values);
    STDMETHODIMP raw_CancelUpdate();
    STDMETHODIMP raw_Close();
    STDMETHODIMP raw_Delete(enum AffectEnum par_AffectRecords);
    STDMETHODIMP raw_GetRows(long par_Rows, VARIANT par_Start, VARIANT par_Fields, VARIANT* par_pvar);
    STDMETHODIMP raw_Move(long par_NumRecords, VARIANT par_Start);
    STDMETHODIMP raw_MoveNext();
    STDMETHODIMP raw_MovePrevious();
    STDMETHODIMP raw_MoveFirst();
    STDMETHODIMP raw_MoveLast();
    STDMETHODIMP raw_Open(VARIANT par_Source, VARIANT par_ActiveConnection, enum CursorTypeEnum par_CursorType, enum LockTypeEnum par_LockType, long par_Options);
    STDMETHODIMP raw_Requery(long par_Options);
    STDMETHODIMP raw__xResync(enum AffectEnum par_AffectRecords);
    STDMETHODIMP raw_Update(VARIANT par_Fields, VARIANT par_Values);
    STDMETHODIMP get_AbsolutePage(enum PositionEnum* par_pl);
    STDMETHODIMP put_AbsolutePage(enum PositionEnum par_pl);
    STDMETHODIMP get_EditMode(enum EditModeEnum* par_pl);
    STDMETHODIMP get_Filter(VARIANT* par_Criteria);
    STDMETHODIMP put_Filter(VARIANT par_Criteria);
    STDMETHODIMP get_PageCount(long* par_pl);
    STDMETHODIMP get_PageSize(long* par_pl);
    STDMETHODIMP put_PageSize(long par_pl);
    STDMETHODIMP get_Sort(BSTR* par_Criteria);
    STDMETHODIMP put_Sort(BSTR par_Criteria);
    STDMETHODIMP get_Status(long* par_pl);
    STDMETHODIMP get_State(long* par_plObjState);
    STDMETHODIMP raw__xClone(_Recordset** par_ppvObject);
    STDMETHODIMP raw_UpdateBatch(enum AffectEnum par_AffectRecords);
    STDMETHODIMP raw_CancelBatch(enum AffectEnum par_AffectRecords);
    STDMETHODIMP get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc);
    STDMETHODIMP put_CursorLocation(enum CursorLocationEnum par_plCursorLoc);
    STDMETHODIMP raw_NextRecordset(VARIANT* par_RecordsAffected, _Recordset** par_ppiRs);
    STDMETHODIMP raw_Supports(enum CursorOptionEnum par_CursorOptions, VARIANT_BOOL* par_pb);
    STDMETHODIMP get_Collect(VARIANT par_Index, VARIANT* par_pvar);
    STDMETHODIMP put_Collect(VARIANT par_Index, VARIANT par_pvar);
    STDMETHODIMP get_MarshalOptions(enum MarshalOptionsEnum* par_peMarshal);
    STDMETHODIMP put_MarshalOptions(enum MarshalOptionsEnum par_peMarshal);
    STDMETHODIMP raw_Find(BSTR par_Criteria, long par_SkipRecords, enum SearchDirectionEnum par_SearchDirection, VARIANT par_Start);

    //
    // These are the methods you need to implement: 
    //
/*
    PositionEnum GetAbsolutePosition();
    void PutAbsolutePosition(enum PositionEnum par_pl);
    void PutrefActiveConnection(const com_ptr<IDispatch>& par_pvar);
    void PutActiveConnection(const variant_t& par_pvar);
    variant_t GetActiveConnection();
    bool GetBOF();
    variant_t GetBookmark();
    void PutBookmark(const variant_t& par_pvBookmark);
    long GetCacheSize();
    void PutCacheSize(long par_pl);
    CursorTypeEnum GetCursorType();
    void PutCursorType(enum CursorTypeEnum par_plCursorType);
    bool GetEOF();
    com_ptr<Fields> GetFields();
    LockTypeEnum GetLockType();
    void PutLockType(enum LockTypeEnum par_plLockType);
    long GetMaxRecords();
    void PutMaxRecords(long par_plMaxRecords);
    long GetRecordCount();
    void PutrefSource(const com_ptr<IDispatch>& par_pvSource);
    void PutSource(const bstr_t& par_pvSource);
    variant_t GetSource();
    void AddNew(const variant_t& par_FieldList = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
    void CancelUpdate();
    void Close();
    void Delete(enum AffectEnum par_AffectRecords = enum AffectEnum(1));
    variant_t GetRows(long par_Rows = -1, const variant_t& par_Start = variant_t::missing(), const variant_t& par_Fields = variant_t::missing());
    void Move(long par_NumRecords, const variant_t& par_Start = variant_t::missing());
    void MoveNext();
    void MovePrevious();
    void MoveFirst();
    void MoveLast();
    void Open(const variant_t& par_Source = variant_t::missing(), const variant_t& par_ActiveConnection = variant_t::missing(), enum CursorTypeEnum par_CursorType = enum CursorTypeEnum(-1), enum LockTypeEnum par_LockType = enum LockTypeEnum(-1), long par_Options = -1);
    void Requery(long par_Options = -1);
    void _xResync(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
    void Update(const variant_t& par_Fields = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
    PositionEnum GetAbsolutePage();
    void PutAbsolutePage(enum PositionEnum par_pl);
    EditModeEnum GetEditMode();
    variant_t GetFilter();
    void PutFilter(const variant_t& par_Criteria);
    long GetPageCount();
    long GetPageSize();
    void PutPageSize(long par_pl);
    bstr_t GetSort();
    void PutSort(const bstr_t& par_Criteria);
    long GetStatus();
    long GetState();
    com_ptr<_Recordset> _xClone();
    void UpdateBatch(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
    void CancelBatch(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
    CursorLocationEnum GetCursorLocation();
    void PutCursorLocation(enum CursorLocationEnum par_plCursorLoc);
    com_ptr<_Recordset> NextRecordset(variant_t& par_RecordsAffected);
    bool Supports(enum CursorOptionEnum par_CursorOptions);
    variant_t GetCollect(const variant_t& par_Index);
    void PutCollect(const variant_t& par_Index, const variant_t& par_pvar);
    MarshalOptionsEnum GetMarshalOptions();
    void PutMarshalOptions(enum MarshalOptionsEnum par_peMarshal);
    void Find(const bstr_t& par_Criteria, long par_SkipRecords = 0, enum SearchDirectionEnum par_SearchDirection = enum SearchDirectionEnum(1), const variant_t& par_Start = variant_t::missing());
*/
};

//
// Impl Wrappers (implementation)
//

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADOCommandConstructionImpl<_B, _S, _TL>::get_OLEDBCommand(IUnknown ** par_ppOLEDBCommand)
{
    COMET_ASSERT(par_ppOLEDBCommand);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppOLEDBCommand) return E_POINTER;
#endif
    (*par_ppOLEDBCommand) = 0;
    try {
        /*
          com_ptr<IUnknown> GetOLEDBCommand();
        */
        *par_ppOLEDBCommand = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetOLEDBCommand());
    } COMET_CATCH_CLASS(L"GetOLEDBCommand");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADOCommandConstructionImpl<_B, _S, _TL>::put_OLEDBCommand(IUnknown * par_ppOLEDBCommand)
{
    try {
        /*
          void PutOLEDBCommand(const com_ptr<IUnknown>& par_ppOLEDBCommand);
        */
        static_cast<_B*>(this)->PutOLEDBCommand(com_ptr<IUnknown>::create_const_reference(par_ppOLEDBCommand));
    } COMET_CATCH_CLASS(L"PutOLEDBCommand");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADOConnectionConstruction15Impl<_B, _S, _TL>::get_DSO(IUnknown ** par_ppDSO)
{
    COMET_ASSERT(par_ppDSO);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppDSO) return E_POINTER;
#endif
    (*par_ppDSO) = 0;
    try {
        /*
          com_ptr<IUnknown> GetDSO();
        */
        *par_ppDSO = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetDSO());
    } COMET_CATCH_CLASS(L"GetDSO");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADOConnectionConstruction15Impl<_B, _S, _TL>::get_Session(IUnknown ** par_ppSession)
{
    COMET_ASSERT(par_ppSession);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppSession) return E_POINTER;
#endif
    (*par_ppSession) = 0;
    try {
        /*
          com_ptr<IUnknown> GetSession();
        */
        *par_ppSession = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetSession());
    } COMET_CATCH_CLASS(L"GetSession");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADOConnectionConstruction15Impl<_B, _S, _TL>::raw_WrapDSOandSession(IUnknown * par_pDSO, IUnknown * par_pSession)
{
    try {
        /*
          void WrapDSOandSession(const com_ptr<IUnknown>& par_pDSO, const com_ptr<IUnknown>& par_pSession);
        */
        static_cast<_B*>(this)->WrapDSOandSession(com_ptr<IUnknown>::create_const_reference(par_pDSO), com_ptr<IUnknown>::create_const_reference(par_pSession));
    } COMET_CATCH_CLASS(L"WrapDSOandSession");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::get_Rowset(IUnknown ** par_ppRowset)
{
    COMET_ASSERT(par_ppRowset);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppRowset) return E_POINTER;
#endif
    (*par_ppRowset) = 0;
    try {
        /*
          com_ptr<IUnknown> GetRowset();
        */
        *par_ppRowset = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetRowset());
    } COMET_CATCH_CLASS(L"GetRowset");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::put_Rowset(IUnknown * par_ppRowset)
{
    try {
        /*
          void PutRowset(const com_ptr<IUnknown>& par_ppRowset);
        */
        static_cast<_B*>(this)->PutRowset(com_ptr<IUnknown>::create_const_reference(par_ppRowset));
    } COMET_CATCH_CLASS(L"PutRowset");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::get_Chapter(long* par_plChapter)
{
    COMET_ASSERT(par_plChapter);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plChapter) return E_POINTER;
#endif
    try {
        /*
          long GetChapter();
        */
        *par_plChapter = static_cast<_B*>(this)->GetChapter();
    } COMET_CATCH_CLASS(L"GetChapter");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::put_Chapter(long par_plChapter)
{
    try {
        /*
          void PutChapter(long par_plChapter);
        */
        static_cast<_B*>(this)->PutChapter(par_plChapter);
    } COMET_CATCH_CLASS(L"PutChapter");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::get_RowPosition(IUnknown ** par_ppRowPos)
{
    COMET_ASSERT(par_ppRowPos);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppRowPos) return E_POINTER;
#endif
    (*par_ppRowPos) = 0;
    try {
        /*
          com_ptr<IUnknown> GetRowPosition();
        */
        *par_ppRowPos = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetRowPosition());
    } COMET_CATCH_CLASS(L"GetRowPosition");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ADORecordsetConstructionImpl<_B, _S, _TL>::put_RowPosition(IUnknown * par_ppRowPos)
{
    try {
        /*
          void PutRowPosition(const com_ptr<IUnknown>& par_ppRowPos);
        */
        static_cast<_B*>(this)->PutRowPosition(com_ptr<IUnknown>::create_const_reference(par_ppRowPos));
    } COMET_CATCH_CLASS(L"PutRowPosition");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsImpl<_B, _S, _TL>::Invoke(DISPID id, REFIID , LCID , WORD Flags, DISPPARAMS *DispParams, VARIANT* Result, EXCEPINFO* pe, UINT* pu)
{
  std::list<variant_t> argconvert_copy;
  if (DispParams->cNamedArgs > 0) return DISP_E_NONAMEDARGS;
    try {
        switch(id)
        {
        case 0:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // InfoMessage: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void InfoMessage(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->InfoMessage(try_cast(par_pError), *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"InfoMessage");
                return S_OK;

            } 
            break;
        case 1:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // BeginTransComplete: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                long par_TransactionLevel;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_TransactionLevel = V_I4(&vit->get());
                }
                else par_TransactionLevel = V_I4(&DispParams->rgvarg[3]);
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void BeginTransComplete(long par_TransactionLevel, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->BeginTransComplete(par_TransactionLevel, try_cast(par_pError), *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"BeginTransComplete");
                return S_OK;

            } 
            break;
        case 2:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // RollbackTransComplete: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void RollbackTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->RollbackTransComplete(try_cast(par_pError), *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"RollbackTransComplete");
                return S_OK;

            } 
            break;
        case 3:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // CommitTransComplete: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void CommitTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->CommitTransComplete(try_cast(par_pError), *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"CommitTransComplete");
                return S_OK;

            } 
            break;
        case 4:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillExecute: Method
                if (DispParams->cArgs != 8) return DISP_E_BADPARAMCOUNT;

                BSTR* par_Source;
                if (V_VT(&DispParams->rgvarg[7]) != (VT_BSTR | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[7], 0, (VT_BSTR | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Source = V_BSTRREF(&vit->get());
                }
                else par_Source = V_BSTRREF(&DispParams->rgvarg[7]);
                enum CursorTypeEnum* par_CursorType;
                if (V_VT(&DispParams->rgvarg[6]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[6], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_CursorType = (enum CursorTypeEnum*)V_I4REF(&vit->get());
                }
                else par_CursorType = (enum CursorTypeEnum*)V_I4REF(&DispParams->rgvarg[6]);
                enum LockTypeEnum* par_LockType;
                if (V_VT(&DispParams->rgvarg[5]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[5], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_LockType = (enum LockTypeEnum*)V_I4REF(&vit->get());
                }
                else par_LockType = (enum LockTypeEnum*)V_I4REF(&DispParams->rgvarg[5]);
                long* par_Options;
                if (V_VT(&DispParams->rgvarg[4]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[4], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Options = V_I4REF(&vit->get());
                }
                else par_Options = V_I4REF(&DispParams->rgvarg[4]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[3]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[3]);
                IDispatch* par_pCommand;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pCommand = V_DISPATCH(&vit->get());
                }
                else par_pCommand = V_DISPATCH(&DispParams->rgvarg[2]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[1]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillExecute(bstr_t& par_Source, enum CursorTypeEnum& par_CursorType, enum LockTypeEnum& par_LockType, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->WillExecute(bstr_t::create_reference(*par_Source), *par_CursorType, *par_LockType, *par_Options, *par_adStatus, try_cast(par_pCommand), try_cast(par_pRecordset), try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"WillExecute");
                return S_OK;

            } 
            break;
        case 5:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // ExecuteComplete: Method
                if (DispParams->cArgs != 6) return DISP_E_BADPARAMCOUNT;

                long par_RecordsAffected;
                if (V_VT(&DispParams->rgvarg[5]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[5], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_RecordsAffected = V_I4(&vit->get());
                }
                else par_RecordsAffected = V_I4(&DispParams->rgvarg[5]);
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[4]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[4], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[4]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[3]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[3]);
                IDispatch* par_pCommand;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pCommand = V_DISPATCH(&vit->get());
                }
                else par_pCommand = V_DISPATCH(&DispParams->rgvarg[2]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[1]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void ExecuteComplete(long par_RecordsAffected, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->ExecuteComplete(par_RecordsAffected, try_cast(par_pError), *par_adStatus, try_cast(par_pCommand), try_cast(par_pRecordset), try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"ExecuteComplete");
                return S_OK;

            } 
            break;
        case 6:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillConnect: Method
                if (DispParams->cArgs != 6) return DISP_E_BADPARAMCOUNT;

                BSTR* par_ConnectionString;
                if (V_VT(&DispParams->rgvarg[5]) != (VT_BSTR | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[5], 0, (VT_BSTR | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_ConnectionString = V_BSTRREF(&vit->get());
                }
                else par_ConnectionString = V_BSTRREF(&DispParams->rgvarg[5]);
                BSTR* par_UserID;
                if (V_VT(&DispParams->rgvarg[4]) != (VT_BSTR | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[4], 0, (VT_BSTR | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_UserID = V_BSTRREF(&vit->get());
                }
                else par_UserID = V_BSTRREF(&DispParams->rgvarg[4]);
                BSTR* par_Password;
                if (V_VT(&DispParams->rgvarg[3]) != (VT_BSTR | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, (VT_BSTR | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Password = V_BSTRREF(&vit->get());
                }
                else par_Password = V_BSTRREF(&DispParams->rgvarg[3]);
                long* par_Options;
                if (V_VT(&DispParams->rgvarg[2]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Options = V_I4REF(&vit->get());
                }
                else par_Options = V_I4REF(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->WillConnect(bstr_t::create_reference(*par_ConnectionString), bstr_t::create_reference(*par_UserID), bstr_t::create_reference(*par_Password), *par_Options, *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"WillConnect");
                return S_OK;

            } 
            break;
        case 7:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // ConnectComplete: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void ConnectComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->ConnectComplete(try_cast(par_pError), *par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"ConnectComplete");
                return S_OK;

            } 
            break;
        case 8:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // Disconnect: Method
                if (DispParams->cArgs != 2) return DISP_E_BADPARAMCOUNT;

                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pConnection;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pConnection = V_DISPATCH(&vit->get());
                }
                else par_pConnection = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void Disconnect(enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
                    */
                    static_cast<_B*>(this)->Disconnect(*par_adStatus, try_cast(par_pConnection));
                } COMET_CATCH_CLASS(L"Disconnect");
                return S_OK;

            } 
            break;
        default:
                return DISP_E_MEMBERNOTFOUND;
        }
    } COMET_CATCH_CLASS(bstr_t());
    return S_OK;
}
template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_InfoMessage(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void InfoMessage(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->InfoMessage(com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"InfoMessage");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_BeginTransComplete(long par_TransactionLevel, Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void BeginTransComplete(long par_TransactionLevel, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->BeginTransComplete(par_TransactionLevel, com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"BeginTransComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_CommitTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void CommitTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->CommitTransComplete(com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"CommitTransComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_RollbackTransComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void RollbackTransComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->RollbackTransComplete(com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"RollbackTransComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_WillExecute(BSTR* par_Source, enum CursorTypeEnum* par_CursorType, enum LockTypeEnum* par_LockType, long* par_Options, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection)
{
    COMET_ASSERT(par_Source);
    COMET_ASSERT(par_CursorType);
    COMET_ASSERT(par_LockType);
    COMET_ASSERT(par_Options);
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_Source) return E_POINTER;
    if (!par_CursorType) return E_POINTER;
    if (!par_LockType) return E_POINTER;
    if (!par_Options) return E_POINTER;
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillExecute(bstr_t& par_Source, enum CursorTypeEnum& par_CursorType, enum LockTypeEnum& par_LockType, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->WillExecute(bstr_t::create_reference(*par_Source), *par_CursorType, *par_LockType, *par_Options, *par_adStatus, com_ptr<_Command>::create_const_reference(par_pCommand), com_ptr<_Recordset>::create_const_reference(par_pRecordset), com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"WillExecute");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_ExecuteComplete(long par_RecordsAffected, Error* par_pError, enum EventStatusEnum* par_adStatus, _Command* par_pCommand, _Recordset* par_pRecordset, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void ExecuteComplete(long par_RecordsAffected, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Command>& par_pCommand, const com_ptr<_Recordset>& par_pRecordset, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->ExecuteComplete(par_RecordsAffected, com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Command>::create_const_reference(par_pCommand), com_ptr<_Recordset>::create_const_reference(par_pRecordset), com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"ExecuteComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_WillConnect(BSTR* par_ConnectionString, BSTR* par_UserID, BSTR* par_Password, long* par_Options, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_ConnectionString);
    COMET_ASSERT(par_UserID);
    COMET_ASSERT(par_Password);
    COMET_ASSERT(par_Options);
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ConnectionString) return E_POINTER;
    if (!par_UserID) return E_POINTER;
    if (!par_Password) return E_POINTER;
    if (!par_Options) return E_POINTER;
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->WillConnect(bstr_t::create_reference(*par_ConnectionString), bstr_t::create_reference(*par_UserID), bstr_t::create_reference(*par_Password), *par_Options, *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"WillConnect");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_ConnectComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void ConnectComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->ConnectComplete(com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"ConnectComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ConnectionEventsVtImpl<_B, _S, _TL>::raw_Disconnect(enum EventStatusEnum* par_adStatus, _Connection* par_pConnection)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void Disconnect(enum EventStatusEnum& par_adStatus, const com_ptr<_Connection>& par_pConnection);
        */
        static_cast<_B*>(this)->Disconnect(*par_adStatus, com_ptr<_Connection>::create_const_reference(par_pConnection));
    } COMET_CATCH_CLASS(L"Disconnect");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_Number(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetNumber();
        */
        *par_pl = static_cast<_B*>(this)->GetNumber();
    } COMET_CATCH_CLASS(L"GetNumber");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_Source(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetSource();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetSource());
    } COMET_CATCH_CLASS(L"GetSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_Description(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetDescription();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetDescription());
    } COMET_CATCH_CLASS(L"GetDescription");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_HelpFile(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetHelpFile();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetHelpFile());
    } COMET_CATCH_CLASS(L"GetHelpFile");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_HelpContext(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetHelpContext();
        */
        *par_pl = static_cast<_B*>(this)->GetHelpContext();
    } COMET_CATCH_CLASS(L"GetHelpContext");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_SQLState(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetSQLState();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetSQLState());
    } COMET_CATCH_CLASS(L"GetSQLState");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorImpl<_B, _S, _TL>::get_NativeError(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetNativeError();
        */
        *par_pl = static_cast<_B*>(this)->GetNativeError();
    } COMET_CATCH_CLASS(L"GetNativeError");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorsImpl<_B, _S, _TL>::get_Item(VARIANT par_Index, Error** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Error> GetItem(const variant_t& par_Index);
        */
        *par_ppvObject = com_ptr<Error>::detach(static_cast<_B*>(this)->GetItem(variant_t::create_const_reference(par_Index)));
    } COMET_CATCH_CLASS(L"GetItem");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ErrorsImpl<_B, _S, _TL>::raw_Clear()
{
    try {
        /*
          void Clear();
        */
        static_cast<_B*>(this)->Clear();
    } COMET_CATCH_CLASS(L"Clear");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_ActualSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetActualSize();
        */
        *par_pl = static_cast<_B*>(this)->GetActualSize();
    } COMET_CATCH_CLASS(L"GetActualSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_Attributes(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetAttributes();
        */
        *par_pl = static_cast<_B*>(this)->GetAttributes();
    } COMET_CATCH_CLASS(L"GetAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_DefinedSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetDefinedSize();
        */
        *par_pl = static_cast<_B*>(this)->GetDefinedSize();
    } COMET_CATCH_CLASS(L"GetDefinedSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_Name(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetName();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetName());
    } COMET_CATCH_CLASS(L"GetName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_Type(enum DataTypeEnum* par_pDataType)
{
    COMET_ASSERT(par_pDataType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pDataType) return E_POINTER;
#endif
    try {
        /*
          DataTypeEnum GetType();
        */
        *par_pDataType = static_cast<_B*>(this)->GetType();
    } COMET_CATCH_CLASS(L"GetType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_Value(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetValue());
    } COMET_CATCH_CLASS(L"GetValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_Value(VARIANT par_pvar)
{
    try {
        /*
          void PutValue(const variant_t& par_pvar);
        */
        static_cast<_B*>(this)->PutValue(variant_t::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_Precision(unsigned char* par_pbPrecision)
{
    COMET_ASSERT(par_pbPrecision);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbPrecision) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetPrecision();
        */
        *par_pbPrecision = static_cast<_B*>(this)->GetPrecision();
    } COMET_CATCH_CLASS(L"GetPrecision");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_NumericScale(unsigned char* par_pbNumericScale)
{
    COMET_ASSERT(par_pbNumericScale);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbNumericScale) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetNumericScale();
        */
        *par_pbNumericScale = static_cast<_B*>(this)->GetNumericScale();
    } COMET_CATCH_CLASS(L"GetNumericScale");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::raw_AppendChunk(VARIANT par_Data)
{
    try {
        /*
          void AppendChunk(const variant_t& par_Data);
        */
        static_cast<_B*>(this)->AppendChunk(variant_t::create_const_reference(par_Data));
    } COMET_CATCH_CLASS(L"AppendChunk");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::raw_GetChunk(long par_Length, VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetChunk(long par_Length);
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetChunk(par_Length));
    } COMET_CATCH_CLASS(L"GetChunk");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_OriginalValue(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetOriginalValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetOriginalValue());
    } COMET_CATCH_CLASS(L"GetOriginalValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_UnderlyingValue(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetUnderlyingValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetUnderlyingValue());
    } COMET_CATCH_CLASS(L"GetUnderlyingValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::get_DataFormat(IUnknown ** par_ppiDF)
{
    COMET_ASSERT(par_ppiDF);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppiDF) return E_POINTER;
#endif
    (*par_ppiDF) = 0;
    try {
        /*
          com_ptr<IUnknown> GetDataFormat();
        */
        *par_ppiDF = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetDataFormat());
    } COMET_CATCH_CLASS(L"GetDataFormat");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::putref_DataFormat(IUnknown * par_ppiDF)
{
    try {
        /*
          void PutDataFormat(const com_ptr<IUnknown>& par_ppiDF);
        */
        static_cast<_B*>(this)->PutDataFormat(com_ptr<IUnknown>::create_const_reference(par_ppiDF));
    } COMET_CATCH_CLASS(L"PutDataFormat");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_Precision(unsigned char par_pbPrecision)
{
    try {
        /*
          void PutPrecision(unsigned char par_pbPrecision);
        */
        static_cast<_B*>(this)->PutPrecision(par_pbPrecision);
    } COMET_CATCH_CLASS(L"PutPrecision");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_NumericScale(unsigned char par_pbNumericScale)
{
    try {
        /*
          void PutNumericScale(unsigned char par_pbNumericScale);
        */
        static_cast<_B*>(this)->PutNumericScale(par_pbNumericScale);
    } COMET_CATCH_CLASS(L"PutNumericScale");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_Type(enum DataTypeEnum par_pDataType)
{
    try {
        /*
          void PutType(enum DataTypeEnum par_pDataType);
        */
        static_cast<_B*>(this)->PutType(par_pDataType);
    } COMET_CATCH_CLASS(L"PutType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_DefinedSize(long par_pl)
{
    try {
        /*
          void PutDefinedSize(long par_pl);
        */
        static_cast<_B*>(this)->PutDefinedSize(par_pl);
    } COMET_CATCH_CLASS(L"PutDefinedSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldImpl<_B, _S, _TL>::put_Attributes(long par_pl)
{
    try {
        /*
          void PutAttributes(long par_pl);
        */
        static_cast<_B*>(this)->PutAttributes(par_pl);
    } COMET_CATCH_CLASS(L"PutAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_ActualSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetActualSize();
        */
        *par_pl = static_cast<_B*>(this)->GetActualSize();
    } COMET_CATCH_CLASS(L"GetActualSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_Attributes(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetAttributes();
        */
        *par_pl = static_cast<_B*>(this)->GetAttributes();
    } COMET_CATCH_CLASS(L"GetAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_DefinedSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetDefinedSize();
        */
        *par_pl = static_cast<_B*>(this)->GetDefinedSize();
    } COMET_CATCH_CLASS(L"GetDefinedSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_Name(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetName();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetName());
    } COMET_CATCH_CLASS(L"GetName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_Type(enum DataTypeEnum* par_pDataType)
{
    COMET_ASSERT(par_pDataType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pDataType) return E_POINTER;
#endif
    try {
        /*
          DataTypeEnum GetType();
        */
        *par_pDataType = static_cast<_B*>(this)->GetType();
    } COMET_CATCH_CLASS(L"GetType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_Value(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetValue());
    } COMET_CATCH_CLASS(L"GetValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::put_Value(VARIANT par_pvar)
{
    try {
        /*
          void PutValue(const variant_t& par_pvar);
        */
        static_cast<_B*>(this)->PutValue(variant_t::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_Precision(unsigned char* par_pbPrecision)
{
    COMET_ASSERT(par_pbPrecision);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbPrecision) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetPrecision();
        */
        *par_pbPrecision = static_cast<_B*>(this)->GetPrecision();
    } COMET_CATCH_CLASS(L"GetPrecision");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_NumericScale(unsigned char* par_pbNumericScale)
{
    COMET_ASSERT(par_pbNumericScale);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbNumericScale) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetNumericScale();
        */
        *par_pbNumericScale = static_cast<_B*>(this)->GetNumericScale();
    } COMET_CATCH_CLASS(L"GetNumericScale");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::raw_AppendChunk(VARIANT par_Data)
{
    try {
        /*
          void AppendChunk(const variant_t& par_Data);
        */
        static_cast<_B*>(this)->AppendChunk(variant_t::create_const_reference(par_Data));
    } COMET_CATCH_CLASS(L"AppendChunk");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::raw_GetChunk(long par_Length, VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetChunk(long par_Length);
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetChunk(par_Length));
    } COMET_CATCH_CLASS(L"GetChunk");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_OriginalValue(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetOriginalValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetOriginalValue());
    } COMET_CATCH_CLASS(L"GetOriginalValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Field15Impl<_B, _S, _TL>::get_UnderlyingValue(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetUnderlyingValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetUnderlyingValue());
    } COMET_CATCH_CLASS(L"GetUnderlyingValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldsImpl<_B, _S, _TL>::raw_Append(BSTR par_Name, enum DataTypeEnum par_Type, long par_DefinedSize, enum FieldAttributeEnum par_Attrib)
{
    try {
        /*
          void Append(const bstr_t& par_Name, enum DataTypeEnum par_Type, long par_DefinedSize = 0, enum FieldAttributeEnum par_Attrib = enum FieldAttributeEnum(-1));
        */
        static_cast<_B*>(this)->Append(bstr_t::create_const_reference(par_Name), par_Type, par_DefinedSize, par_Attrib);
    } COMET_CATCH_CLASS(L"Append");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP FieldsImpl<_B, _S, _TL>::raw_Delete(VARIANT par_Index)
{
    try {
        /*
          void Delete(const variant_t& par_Index);
        */
        static_cast<_B*>(this)->Delete(variant_t::create_const_reference(par_Index));
    } COMET_CATCH_CLASS(L"Delete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP Fields15Impl<_B, _S, _TL>::get_Item(VARIANT par_Index, Field** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Field> GetItem(const variant_t& par_Index);
        */
        *par_ppvObject = com_ptr<Field>::detach(static_cast<_B*>(this)->GetItem(variant_t::create_const_reference(par_Index)));
    } COMET_CATCH_CLASS(L"GetItem");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP ParametersImpl<_B, _S, _TL>::get_Item(VARIANT par_Index, _Parameter** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Parameter> GetItem(const variant_t& par_Index);
        */
        *par_ppvObject = com_ptr<_Parameter>::detach(static_cast<_B*>(this)->GetItem(variant_t::create_const_reference(par_Index)));
    } COMET_CATCH_CLASS(L"GetItem");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertiesImpl<_B, _S, _TL>::get_Item(VARIANT par_Index, Property** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Property> GetItem(const variant_t& par_Index);
        */
        *par_ppvObject = com_ptr<Property>::detach(static_cast<_B*>(this)->GetItem(variant_t::create_const_reference(par_Index)));
    } COMET_CATCH_CLASS(L"GetItem");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::get_Value(VARIANT* par_pval)
{
    COMET_ASSERT(par_pval);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pval) return E_POINTER;
#endif
    ::VariantInit(par_pval);
    try {
        /*
          variant_t GetValue();
        */
        *par_pval = variant_t::detach(static_cast<_B*>(this)->GetValue());
    } COMET_CATCH_CLASS(L"GetValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::put_Value(VARIANT par_pval)
{
    try {
        /*
          void PutValue(const variant_t& par_pval);
        */
        static_cast<_B*>(this)->PutValue(variant_t::create_const_reference(par_pval));
    } COMET_CATCH_CLASS(L"PutValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::get_Name(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetName();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetName());
    } COMET_CATCH_CLASS(L"GetName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::get_Type(enum DataTypeEnum* par_ptype)
{
    COMET_ASSERT(par_ptype);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ptype) return E_POINTER;
#endif
    try {
        /*
          DataTypeEnum GetType();
        */
        *par_ptype = static_cast<_B*>(this)->GetType();
    } COMET_CATCH_CLASS(L"GetType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::get_Attributes(long* par_plAttributes)
{
    COMET_ASSERT(par_plAttributes);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plAttributes) return E_POINTER;
#endif
    try {
        /*
          long GetAttributes();
        */
        *par_plAttributes = static_cast<_B*>(this)->GetAttributes();
    } COMET_CATCH_CLASS(L"GetAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP PropertyImpl<_B, _S, _TL>::put_Attributes(long par_plAttributes)
{
    try {
        /*
          void PutAttributes(long par_plAttributes);
        */
        static_cast<_B*>(this)->PutAttributes(par_plAttributes);
    } COMET_CATCH_CLASS(L"PutAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsImpl<_B, _S, _TL>::Invoke(DISPID id, REFIID , LCID , WORD Flags, DISPPARAMS *DispParams, VARIANT* Result, EXCEPINFO* pe, UINT* pu)
{
  std::list<variant_t> argconvert_copy;
  if (DispParams->cNamedArgs > 0) return DISP_E_NONAMEDARGS;
    try {
        switch(id)
        {
        case 9:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillChangeField: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                long par_cFields;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_cFields = V_I4(&vit->get());
                }
                else par_cFields = V_I4(&DispParams->rgvarg[3]);
                VARIANT par_Fields;
                if (V_VT(&DispParams->rgvarg[2]) != VT_VARIANT)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_VARIANT) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Fields = vit->get();
                }
                else par_Fields = DispParams->rgvarg[2];
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillChangeField(long par_cFields, const variant_t& par_Fields, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->WillChangeField(par_cFields, variant_t::create_const_reference(par_Fields), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"WillChangeField");
                return S_OK;

            } 
            break;
        case 10:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // FieldChangeComplete: Method
                if (DispParams->cArgs != 5) return DISP_E_BADPARAMCOUNT;

                long par_cFields;
                if (V_VT(&DispParams->rgvarg[4]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[4], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_cFields = V_I4(&vit->get());
                }
                else par_cFields = V_I4(&DispParams->rgvarg[4]);
                VARIANT par_Fields;
                if (V_VT(&DispParams->rgvarg[3]) != VT_VARIANT)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_VARIANT) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Fields = vit->get();
                }
                else par_Fields = DispParams->rgvarg[3];
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->FieldChangeComplete(par_cFields, variant_t::create_const_reference(par_Fields), try_cast(par_pError), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"FieldChangeComplete");
                return S_OK;

            } 
            break;
        case 11:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillChangeRecord: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[3]);
                long par_cRecords;
                if (V_VT(&DispParams->rgvarg[2]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_cRecords = V_I4(&vit->get());
                }
                else par_cRecords = V_I4(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->WillChangeRecord(par_adReason, par_cRecords, *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"WillChangeRecord");
                return S_OK;

            } 
            break;
        case 12:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // RecordChangeComplete: Method
                if (DispParams->cArgs != 5) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[4]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[4], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[4]);
                long par_cRecords;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_cRecords = V_I4(&vit->get());
                }
                else par_cRecords = V_I4(&DispParams->rgvarg[3]);
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->RecordChangeComplete(par_adReason, par_cRecords, try_cast(par_pError), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"RecordChangeComplete");
                return S_OK;

            } 
            break;
        case 13:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillChangeRecordset: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[2]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->WillChangeRecordset(par_adReason, *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"WillChangeRecordset");
                return S_OK;

            } 
            break;
        case 14:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // RecordsetChangeComplete: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[3]);
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void RecordsetChangeComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->RecordsetChangeComplete(par_adReason, try_cast(par_pError), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"RecordsetChangeComplete");
                return S_OK;

            } 
            break;
        case 15:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // WillMove: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[2]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->WillMove(par_adReason, *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"WillMove");
                return S_OK;

            } 
            break;
        case 16:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // MoveComplete: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                enum EventReasonEnum par_adReason;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adReason = (enum EventReasonEnum)V_I4(&vit->get());
                }
                else par_adReason = (enum EventReasonEnum)V_I4(&DispParams->rgvarg[3]);
                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void MoveComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->MoveComplete(par_adReason, try_cast(par_pError), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"MoveComplete");
                return S_OK;

            } 
            break;
        case 17:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // EndOfRecordset: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                VARIANT_BOOL* par_fMoreData;
                if (V_VT(&DispParams->rgvarg[2]) != (VT_BOOL | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, (VT_BOOL | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_fMoreData = V_BOOLREF(&vit->get());
                }
                else par_fMoreData = V_BOOLREF(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void EndOfRecordset(bool& par_fMoreData, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->EndOfRecordset(impl::bool_adapter_t(par_fMoreData).ref(), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"EndOfRecordset");
                return S_OK;

            } 
            break;
        case 18:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // FetchProgress: Method
                if (DispParams->cArgs != 4) return DISP_E_BADPARAMCOUNT;

                long par_Progress;
                if (V_VT(&DispParams->rgvarg[3]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[3], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_Progress = V_I4(&vit->get());
                }
                else par_Progress = V_I4(&DispParams->rgvarg[3]);
                long par_MaxProgress;
                if (V_VT(&DispParams->rgvarg[2]) != VT_I4)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_I4) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_MaxProgress = V_I4(&vit->get());
                }
                else par_MaxProgress = V_I4(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->FetchProgress(par_Progress, par_MaxProgress, *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"FetchProgress");
                return S_OK;

            } 
            break;
        case 19:
            if ( (Flags & DISPATCH_METHOD) != 0) {
                // FetchComplete: Method
                if (DispParams->cArgs != 3) return DISP_E_BADPARAMCOUNT;

                IDispatch* par_pError;
                if (V_VT(&DispParams->rgvarg[2]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[2], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pError = V_DISPATCH(&vit->get());
                }
                else par_pError = V_DISPATCH(&DispParams->rgvarg[2]);
                enum EventStatusEnum* par_adStatus;
                if (V_VT(&DispParams->rgvarg[1]) != (VT_I4 | VT_BYREF))
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[1], 0, (VT_I4 | VT_BYREF)) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_adStatus = (enum EventStatusEnum*)V_I4REF(&vit->get());
                }
                else par_adStatus = (enum EventStatusEnum*)V_I4REF(&DispParams->rgvarg[1]);
                IDispatch* par_pRecordset;
                if (V_VT(&DispParams->rgvarg[0]) != VT_DISPATCH)
                {
                    std::list<variant_t>::iterator vit= argconvert_copy.insert(argconvert_copy.end(), variant_t());
                    if ( VariantChangeType( vit->inout(), &DispParams->rgvarg[0], 0, VT_DISPATCH) != S_OK )
                            return DISP_E_BADVARTYPE;
                    par_pRecordset = V_DISPATCH(&vit->get());
                }
                else par_pRecordset = V_DISPATCH(&DispParams->rgvarg[0]);
                try {
                    /*
                      void FetchComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
                    */
                    static_cast<_B*>(this)->FetchComplete(try_cast(par_pError), *par_adStatus, try_cast(par_pRecordset));
                } COMET_CATCH_CLASS(L"FetchComplete");
                return S_OK;

            } 
            break;
        default:
                return DISP_E_MEMBERNOTFOUND;
        }
    } COMET_CATCH_CLASS(bstr_t());
    return S_OK;
}
template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_WillChangeField(long par_cFields, VARIANT par_Fields, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillChangeField(long par_cFields, const variant_t& par_Fields, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->WillChangeField(par_cFields, variant_t::create_const_reference(par_Fields), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"WillChangeField");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_FieldChangeComplete(long par_cFields, VARIANT par_Fields, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->FieldChangeComplete(par_cFields, variant_t::create_const_reference(par_Fields), com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"FieldChangeComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillChangeRecord(enum EventReasonEnum par_adReason, long par_cRecords, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->WillChangeRecord(par_adReason, par_cRecords, *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"WillChangeRecord");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void RecordChangeComplete(enum EventReasonEnum par_adReason, long par_cRecords, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->RecordChangeComplete(par_adReason, par_cRecords, com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"RecordChangeComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillChangeRecordset(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->WillChangeRecordset(par_adReason, *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"WillChangeRecordset");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_RecordsetChangeComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void RecordsetChangeComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->RecordsetChangeComplete(par_adReason, com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"RecordsetChangeComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void WillMove(enum EventReasonEnum par_adReason, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->WillMove(par_adReason, *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"WillMove");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_MoveComplete(enum EventReasonEnum par_adReason, Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void MoveComplete(enum EventReasonEnum par_adReason, const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->MoveComplete(par_adReason, com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"MoveComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_EndOfRecordset(VARIANT_BOOL* par_fMoreData, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_fMoreData);
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_fMoreData) return E_POINTER;
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void EndOfRecordset(bool& par_fMoreData, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->EndOfRecordset(impl::bool_adapter_t(par_fMoreData).ref(), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"EndOfRecordset");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void FetchProgress(long par_Progress, long par_MaxProgress, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->FetchProgress(par_Progress, par_MaxProgress, *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"FetchProgress");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP RecordsetEventsVtImpl<_B, _S, _TL>::raw_FetchComplete(Error* par_pError, enum EventStatusEnum* par_adStatus, _Recordset* par_pRecordset)
{
    COMET_ASSERT(par_adStatus);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_adStatus) return E_POINTER;
#endif
    try {
        /*
          void FetchComplete(const com_ptr<Error>& par_pError, enum EventStatusEnum& par_adStatus, const com_ptr<_Recordset>& par_pRecordset);
        */
        static_cast<_B*>(this)->FetchComplete(com_ptr<Error>::create_const_reference(par_pError), *par_adStatus, com_ptr<_Recordset>::create_const_reference(par_pRecordset));
    } COMET_CATCH_CLASS(L"FetchComplete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ADOImpl<_B, _S, _TL>::get_Properties(Properties** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Properties> GetProperties();
        */
        *par_ppvObject = com_ptr<Properties>::detach(static_cast<_B*>(this)->GetProperties());
    } COMET_CATCH_CLASS(L"GetProperties");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _CollectionImpl<_B, _S, _TL>::get_Count(long* par_c)
{
    COMET_ASSERT(par_c);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_c) return E_POINTER;
#endif
    try {
        /*
          long GetCount();
        */
        *par_c = static_cast<_B*>(this)->GetCount();
    } COMET_CATCH_CLASS(L"GetCount");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _CollectionImpl<_B, _S, _TL>::raw__NewEnum(IUnknown ** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    (*par_ppvObject) = 0;
    try {
        /*
          com_ptr<IUnknown> _NewEnum();
        */
        *par_ppvObject = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->_NewEnum());
    } COMET_CATCH_CLASS(L"_NewEnum");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _CollectionImpl<_B, _S, _TL>::raw_Refresh()
{
    try {
        /*
          void Refresh();
        */
        static_cast<_B*>(this)->Refresh();
    } COMET_CATCH_CLASS(L"Refresh");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _CommandImpl<_B, _S, _TL>::get_State(long* par_plObjState)
{
    COMET_ASSERT(par_plObjState);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plObjState) return E_POINTER;
#endif
    try {
        /*
          long GetState();
        */
        *par_plObjState = static_cast<_B*>(this)->GetState();
    } COMET_CATCH_CLASS(L"GetState");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _CommandImpl<_B, _S, _TL>::raw_Cancel()
{
    try {
        /*
          void Cancel();
        */
        static_cast<_B*>(this)->Cancel();
    } COMET_CATCH_CLASS(L"Cancel");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_ActiveConnection(_Connection** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Connection> GetActiveConnection();
        */
        *par_ppvObject = com_ptr<_Connection>::detach(static_cast<_B*>(this)->GetActiveConnection());
    } COMET_CATCH_CLASS(L"GetActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::putref_ActiveConnection(_Connection* par_ppvObject)
{
    try {
        /*
          void PutrefActiveConnection(const com_ptr<_Connection>& par_ppvObject);
        */
        static_cast<_B*>(this)->PutrefActiveConnection(com_ptr<_Connection>::create_const_reference(par_ppvObject));
    } COMET_CATCH_CLASS(L"PutrefActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_ActiveConnection(VARIANT par_ppvObject)
{
    try {
        /*
          void PutActiveConnection(const variant_t& par_ppvObject);
        */
        static_cast<_B*>(this)->PutActiveConnection(variant_t::create_const_reference(par_ppvObject));
    } COMET_CATCH_CLASS(L"PutActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_CommandText(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetCommandText();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetCommandText());
    } COMET_CATCH_CLASS(L"GetCommandText");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_CommandText(BSTR par_pbstr)
{
    try {
        /*
          void PutCommandText(const bstr_t& par_pbstr);
        */
        static_cast<_B*>(this)->PutCommandText(bstr_t::create_const_reference(par_pbstr));
    } COMET_CATCH_CLASS(L"PutCommandText");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_CommandTimeout(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetCommandTimeout();
        */
        *par_pl = static_cast<_B*>(this)->GetCommandTimeout();
    } COMET_CATCH_CLASS(L"GetCommandTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_CommandTimeout(long par_pl)
{
    try {
        /*
          void PutCommandTimeout(long par_pl);
        */
        static_cast<_B*>(this)->PutCommandTimeout(par_pl);
    } COMET_CATCH_CLASS(L"PutCommandTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_Prepared(VARIANT_BOOL* par_pfPrepared)
{
    COMET_ASSERT(par_pfPrepared);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pfPrepared) return E_POINTER;
#endif
    try {
        /*
          bool GetPrepared();
        */
        *par_pfPrepared = static_cast<_B*>(this)->GetPrepared() ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE;
    } COMET_CATCH_CLASS(L"GetPrepared");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_Prepared(VARIANT_BOOL par_pfPrepared)
{
    try {
        /*
          void PutPrepared(bool par_pfPrepared);
        */
        static_cast<_B*>(this)->PutPrepared(par_pfPrepared!= COMET_VARIANT_FALSE);
    } COMET_CATCH_CLASS(L"PutPrepared");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::raw_Execute(VARIANT* par_RecordsAffected, VARIANT* par_Parameters, long par_Options, _Recordset** par_ppiRs)
{
    COMET_ASSERT(par_RecordsAffected);
    COMET_ASSERT(par_ppiRs);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_RecordsAffected) return E_POINTER;
    if (!par_ppiRs) return E_POINTER;
#endif
    ::VariantInit(par_RecordsAffected);
    try {
        variant_t par_RecordsAffected_tmp;
        /*
          com_ptr<_Recordset> Execute(variant_t& par_RecordsAffected, const variant_t& par_Parameters = variant_t::missing(), long par_Options = -1);
        */
        *par_ppiRs = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->Execute(par_RecordsAffected_tmp, variant_t::create_const_reference(*par_Parameters), par_Options));
        *par_RecordsAffected = variant_t::detach(par_RecordsAffected_tmp);
    } COMET_CATCH_CLASS(L"Execute");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::raw_CreateParameter(BSTR par_Name, enum DataTypeEnum par_Type, enum ParameterDirectionEnum par_Direction, long par_Size, VARIANT par_Value, _Parameter** par_ppiprm)
{
    COMET_ASSERT(par_ppiprm);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppiprm) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Parameter> CreateParameter(const bstr_t& par_Name = L"", enum DataTypeEnum par_Type = enum DataTypeEnum(0), enum ParameterDirectionEnum par_Direction = enum ParameterDirectionEnum(1), long par_Size = 0, const variant_t& par_Value = variant_t::missing());
        */
        *par_ppiprm = com_ptr<_Parameter>::detach(static_cast<_B*>(this)->CreateParameter(bstr_t::create_const_reference(par_Name), par_Type, par_Direction, par_Size, variant_t::create_const_reference(par_Value)));
    } COMET_CATCH_CLASS(L"CreateParameter");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_Parameters(Parameters** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Parameters> GetParameters();
        */
        *par_ppvObject = com_ptr<Parameters>::detach(static_cast<_B*>(this)->GetParameters());
    } COMET_CATCH_CLASS(L"GetParameters");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_CommandType(enum CommandTypeEnum par_plCmdType)
{
    try {
        /*
          void PutCommandType(enum CommandTypeEnum par_plCmdType);
        */
        static_cast<_B*>(this)->PutCommandType(par_plCmdType);
    } COMET_CATCH_CLASS(L"PutCommandType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_CommandType(enum CommandTypeEnum* par_plCmdType)
{
    COMET_ASSERT(par_plCmdType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plCmdType) return E_POINTER;
#endif
    try {
        /*
          CommandTypeEnum GetCommandType();
        */
        *par_plCmdType = static_cast<_B*>(this)->GetCommandType();
    } COMET_CATCH_CLASS(L"GetCommandType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::get_Name(BSTR* par_pbstrName)
{
    COMET_ASSERT(par_pbstrName);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstrName) return E_POINTER;
#endif
    (*par_pbstrName) = 0;
    try {
        /*
          bstr_t GetName();
        */
        *par_pbstrName = bstr_t::detach(static_cast<_B*>(this)->GetName());
    } COMET_CATCH_CLASS(L"GetName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Command15Impl<_B, _S, _TL>::put_Name(BSTR par_pbstrName)
{
    try {
        /*
          void PutName(const bstr_t& par_pbstrName);
        */
        static_cast<_B*>(this)->PutName(bstr_t::create_const_reference(par_pbstrName));
    } COMET_CATCH_CLASS(L"PutName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ConnectionImpl<_B, _S, _TL>::raw_Cancel()
{
    try {
        /*
          void Cancel();
        */
        static_cast<_B*>(this)->Cancel();
    } COMET_CATCH_CLASS(L"Cancel");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_ConnectionString(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetConnectionString();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetConnectionString());
    } COMET_CATCH_CLASS(L"GetConnectionString");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_ConnectionString(BSTR par_pbstr)
{
    try {
        /*
          void PutConnectionString(const bstr_t& par_pbstr);
        */
        static_cast<_B*>(this)->PutConnectionString(bstr_t::create_const_reference(par_pbstr));
    } COMET_CATCH_CLASS(L"PutConnectionString");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_CommandTimeout(long* par_plTimeout)
{
    COMET_ASSERT(par_plTimeout);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plTimeout) return E_POINTER;
#endif
    try {
        /*
          long GetCommandTimeout();
        */
        *par_plTimeout = static_cast<_B*>(this)->GetCommandTimeout();
    } COMET_CATCH_CLASS(L"GetCommandTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_CommandTimeout(long par_plTimeout)
{
    try {
        /*
          void PutCommandTimeout(long par_plTimeout);
        */
        static_cast<_B*>(this)->PutCommandTimeout(par_plTimeout);
    } COMET_CATCH_CLASS(L"PutCommandTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_ConnectionTimeout(long* par_plTimeout)
{
    COMET_ASSERT(par_plTimeout);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plTimeout) return E_POINTER;
#endif
    try {
        /*
          long GetConnectionTimeout();
        */
        *par_plTimeout = static_cast<_B*>(this)->GetConnectionTimeout();
    } COMET_CATCH_CLASS(L"GetConnectionTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_ConnectionTimeout(long par_plTimeout)
{
    try {
        /*
          void PutConnectionTimeout(long par_plTimeout);
        */
        static_cast<_B*>(this)->PutConnectionTimeout(par_plTimeout);
    } COMET_CATCH_CLASS(L"PutConnectionTimeout");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_Version(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetVersion();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetVersion());
    } COMET_CATCH_CLASS(L"GetVersion");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_Close()
{
    try {
        /*
          void Close();
        */
        static_cast<_B*>(this)->Close();
    } COMET_CATCH_CLASS(L"Close");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_Execute(BSTR par_CommandText, VARIANT* par_RecordsAffected, long par_Options, _Recordset** par_ppiRset)
{
    COMET_ASSERT(par_RecordsAffected);
    COMET_ASSERT(par_ppiRset);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_RecordsAffected) return E_POINTER;
    if (!par_ppiRset) return E_POINTER;
#endif
    ::VariantInit(par_RecordsAffected);
    try {
        variant_t par_RecordsAffected_tmp;
        /*
          com_ptr<_Recordset> Execute(const bstr_t& par_CommandText, variant_t& par_RecordsAffected, long par_Options = -1);
        */
        *par_ppiRset = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->Execute(bstr_t::create_const_reference(par_CommandText), par_RecordsAffected_tmp, par_Options));
        *par_RecordsAffected = variant_t::detach(par_RecordsAffected_tmp);
    } COMET_CATCH_CLASS(L"Execute");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_BeginTrans(long* par_TransactionLevel)
{
    COMET_ASSERT(par_TransactionLevel);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_TransactionLevel) return E_POINTER;
#endif
    try {
        /*
          long BeginTrans();
        */
        *par_TransactionLevel = static_cast<_B*>(this)->BeginTrans();
    } COMET_CATCH_CLASS(L"BeginTrans");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_CommitTrans()
{
    try {
        /*
          void CommitTrans();
        */
        static_cast<_B*>(this)->CommitTrans();
    } COMET_CATCH_CLASS(L"CommitTrans");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_RollbackTrans()
{
    try {
        /*
          void RollbackTrans();
        */
        static_cast<_B*>(this)->RollbackTrans();
    } COMET_CATCH_CLASS(L"RollbackTrans");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_Open(BSTR par_ConnectionString, BSTR par_UserID, BSTR par_Password, long par_Options)
{
    try {
        /*
          void Open(const bstr_t& par_ConnectionString = L"", const bstr_t& par_UserID = L"", const bstr_t& par_Password = L"", long par_Options = -1);
        */
        static_cast<_B*>(this)->Open(bstr_t::create_const_reference(par_ConnectionString), bstr_t::create_const_reference(par_UserID), bstr_t::create_const_reference(par_Password), par_Options);
    } COMET_CATCH_CLASS(L"Open");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_Errors(Errors** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Errors> GetErrors();
        */
        *par_ppvObject = com_ptr<Errors>::detach(static_cast<_B*>(this)->GetErrors());
    } COMET_CATCH_CLASS(L"GetErrors");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_DefaultDatabase(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetDefaultDatabase();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetDefaultDatabase());
    } COMET_CATCH_CLASS(L"GetDefaultDatabase");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_DefaultDatabase(BSTR par_pbstr)
{
    try {
        /*
          void PutDefaultDatabase(const bstr_t& par_pbstr);
        */
        static_cast<_B*>(this)->PutDefaultDatabase(bstr_t::create_const_reference(par_pbstr));
    } COMET_CATCH_CLASS(L"PutDefaultDatabase");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_IsolationLevel(enum IsolationLevelEnum* par_Level)
{
    COMET_ASSERT(par_Level);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_Level) return E_POINTER;
#endif
    try {
        /*
          IsolationLevelEnum GetIsolationLevel();
        */
        *par_Level = static_cast<_B*>(this)->GetIsolationLevel();
    } COMET_CATCH_CLASS(L"GetIsolationLevel");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_IsolationLevel(enum IsolationLevelEnum par_Level)
{
    try {
        /*
          void PutIsolationLevel(enum IsolationLevelEnum par_Level);
        */
        static_cast<_B*>(this)->PutIsolationLevel(par_Level);
    } COMET_CATCH_CLASS(L"PutIsolationLevel");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_Attributes(long* par_plAttr)
{
    COMET_ASSERT(par_plAttr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plAttr) return E_POINTER;
#endif
    try {
        /*
          long GetAttributes();
        */
        *par_plAttr = static_cast<_B*>(this)->GetAttributes();
    } COMET_CATCH_CLASS(L"GetAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_Attributes(long par_plAttr)
{
    try {
        /*
          void PutAttributes(long par_plAttr);
        */
        static_cast<_B*>(this)->PutAttributes(par_plAttr);
    } COMET_CATCH_CLASS(L"PutAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc)
{
    COMET_ASSERT(par_plCursorLoc);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plCursorLoc) return E_POINTER;
#endif
    try {
        /*
          CursorLocationEnum GetCursorLocation();
        */
        *par_plCursorLoc = static_cast<_B*>(this)->GetCursorLocation();
    } COMET_CATCH_CLASS(L"GetCursorLocation");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_CursorLocation(enum CursorLocationEnum par_plCursorLoc)
{
    try {
        /*
          void PutCursorLocation(enum CursorLocationEnum par_plCursorLoc);
        */
        static_cast<_B*>(this)->PutCursorLocation(par_plCursorLoc);
    } COMET_CATCH_CLASS(L"PutCursorLocation");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_Mode(enum ConnectModeEnum* par_plMode)
{
    COMET_ASSERT(par_plMode);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plMode) return E_POINTER;
#endif
    try {
        /*
          ConnectModeEnum GetMode();
        */
        *par_plMode = static_cast<_B*>(this)->GetMode();
    } COMET_CATCH_CLASS(L"GetMode");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_Mode(enum ConnectModeEnum par_plMode)
{
    try {
        /*
          void PutMode(enum ConnectModeEnum par_plMode);
        */
        static_cast<_B*>(this)->PutMode(par_plMode);
    } COMET_CATCH_CLASS(L"PutMode");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_Provider(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetProvider();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetProvider());
    } COMET_CATCH_CLASS(L"GetProvider");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::put_Provider(BSTR par_pbstr)
{
    try {
        /*
          void PutProvider(const bstr_t& par_pbstr);
        */
        static_cast<_B*>(this)->PutProvider(bstr_t::create_const_reference(par_pbstr));
    } COMET_CATCH_CLASS(L"PutProvider");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::get_State(long* par_plObjState)
{
    COMET_ASSERT(par_plObjState);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plObjState) return E_POINTER;
#endif
    try {
        /*
          long GetState();
        */
        *par_plObjState = static_cast<_B*>(this)->GetState();
    } COMET_CATCH_CLASS(L"GetState");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Connection15Impl<_B, _S, _TL>::raw_OpenSchema(enum SchemaEnum par_Schema, VARIANT par_Restrictions, VARIANT par_SchemaID, _Recordset** par_pprset)
{
    COMET_ASSERT(par_pprset);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pprset) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Recordset> OpenSchema(enum SchemaEnum par_Schema, const variant_t& par_Restrictions = variant_t::missing(), const variant_t& par_SchemaID = variant_t::missing());
        */
        *par_pprset = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->OpenSchema(par_Schema, variant_t::create_const_reference(par_Restrictions), variant_t::create_const_reference(par_SchemaID)));
    } COMET_CATCH_CLASS(L"OpenSchema");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _DynaCollectionImpl<_B, _S, _TL>::raw_Append(IDispatch * par_Object)
{
    try {
        /*
          void Append(const com_ptr<IDispatch>& par_Object);
        */
        static_cast<_B*>(this)->Append(com_ptr<IDispatch>::create_const_reference(par_Object));
    } COMET_CATCH_CLASS(L"Append");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _DynaCollectionImpl<_B, _S, _TL>::raw_Delete(VARIANT par_Index)
{
    try {
        /*
          void Delete(const variant_t& par_Index);
        */
        static_cast<_B*>(this)->Delete(variant_t::create_const_reference(par_Index));
    } COMET_CATCH_CLASS(L"Delete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Name(BSTR* par_pbstr)
{
    COMET_ASSERT(par_pbstr);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstr) return E_POINTER;
#endif
    (*par_pbstr) = 0;
    try {
        /*
          bstr_t GetName();
        */
        *par_pbstr = bstr_t::detach(static_cast<_B*>(this)->GetName());
    } COMET_CATCH_CLASS(L"GetName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Name(BSTR par_pbstr)
{
    try {
        /*
          void PutName(const bstr_t& par_pbstr);
        */
        static_cast<_B*>(this)->PutName(bstr_t::create_const_reference(par_pbstr));
    } COMET_CATCH_CLASS(L"PutName");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Value(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetValue();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetValue());
    } COMET_CATCH_CLASS(L"GetValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Value(VARIANT par_pvar)
{
    try {
        /*
          void PutValue(const variant_t& par_pvar);
        */
        static_cast<_B*>(this)->PutValue(variant_t::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutValue");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Type(enum DataTypeEnum* par_psDataType)
{
    COMET_ASSERT(par_psDataType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_psDataType) return E_POINTER;
#endif
    try {
        /*
          DataTypeEnum GetType();
        */
        *par_psDataType = static_cast<_B*>(this)->GetType();
    } COMET_CATCH_CLASS(L"GetType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Type(enum DataTypeEnum par_psDataType)
{
    try {
        /*
          void PutType(enum DataTypeEnum par_psDataType);
        */
        static_cast<_B*>(this)->PutType(par_psDataType);
    } COMET_CATCH_CLASS(L"PutType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Direction(enum ParameterDirectionEnum par_plParmDirection)
{
    try {
        /*
          void PutDirection(enum ParameterDirectionEnum par_plParmDirection);
        */
        static_cast<_B*>(this)->PutDirection(par_plParmDirection);
    } COMET_CATCH_CLASS(L"PutDirection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Direction(enum ParameterDirectionEnum* par_plParmDirection)
{
    COMET_ASSERT(par_plParmDirection);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plParmDirection) return E_POINTER;
#endif
    try {
        /*
          ParameterDirectionEnum GetDirection();
        */
        *par_plParmDirection = static_cast<_B*>(this)->GetDirection();
    } COMET_CATCH_CLASS(L"GetDirection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Precision(unsigned char par_pbPrecision)
{
    try {
        /*
          void PutPrecision(unsigned char par_pbPrecision);
        */
        static_cast<_B*>(this)->PutPrecision(par_pbPrecision);
    } COMET_CATCH_CLASS(L"PutPrecision");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Precision(unsigned char* par_pbPrecision)
{
    COMET_ASSERT(par_pbPrecision);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbPrecision) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetPrecision();
        */
        *par_pbPrecision = static_cast<_B*>(this)->GetPrecision();
    } COMET_CATCH_CLASS(L"GetPrecision");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_NumericScale(unsigned char par_pbScale)
{
    try {
        /*
          void PutNumericScale(unsigned char par_pbScale);
        */
        static_cast<_B*>(this)->PutNumericScale(par_pbScale);
    } COMET_CATCH_CLASS(L"PutNumericScale");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_NumericScale(unsigned char* par_pbScale)
{
    COMET_ASSERT(par_pbScale);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbScale) return E_POINTER;
#endif
    try {
        /*
          unsigned char GetNumericScale();
        */
        *par_pbScale = static_cast<_B*>(this)->GetNumericScale();
    } COMET_CATCH_CLASS(L"GetNumericScale");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Size(long par_pl)
{
    try {
        /*
          void PutSize(long par_pl);
        */
        static_cast<_B*>(this)->PutSize(par_pl);
    } COMET_CATCH_CLASS(L"PutSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Size(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetSize();
        */
        *par_pl = static_cast<_B*>(this)->GetSize();
    } COMET_CATCH_CLASS(L"GetSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::raw_AppendChunk(VARIANT par_Val)
{
    try {
        /*
          void AppendChunk(const variant_t& par_Val);
        */
        static_cast<_B*>(this)->AppendChunk(variant_t::create_const_reference(par_Val));
    } COMET_CATCH_CLASS(L"AppendChunk");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::get_Attributes(long* par_plParmAttribs)
{
    COMET_ASSERT(par_plParmAttribs);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plParmAttribs) return E_POINTER;
#endif
    try {
        /*
          long GetAttributes();
        */
        *par_plParmAttribs = static_cast<_B*>(this)->GetAttributes();
    } COMET_CATCH_CLASS(L"GetAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _ParameterImpl<_B, _S, _TL>::put_Attributes(long par_plParmAttribs)
{
    try {
        /*
          void PutAttributes(long par_plParmAttribs);
        */
        static_cast<_B*>(this)->PutAttributes(par_plParmAttribs);
    } COMET_CATCH_CLASS(L"PutAttributes");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_Cancel()
{
    try {
        /*
          void Cancel();
        */
        static_cast<_B*>(this)->Cancel();
    } COMET_CATCH_CLASS(L"Cancel");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::get_DataSource(IUnknown ** par_ppunkDataSource)
{
    COMET_ASSERT(par_ppunkDataSource);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppunkDataSource) return E_POINTER;
#endif
    (*par_ppunkDataSource) = 0;
    try {
        /*
          com_ptr<IUnknown> GetDataSource();
        */
        *par_ppunkDataSource = com_ptr<IUnknown>::detach(static_cast<_B*>(this)->GetDataSource());
    } COMET_CATCH_CLASS(L"GetDataSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::putref_DataSource(IUnknown * par_ppunkDataSource)
{
    try {
        /*
          void PutDataSource(const com_ptr<IUnknown>& par_ppunkDataSource);
        */
        static_cast<_B*>(this)->PutDataSource(com_ptr<IUnknown>::create_const_reference(par_ppunkDataSource));
    } COMET_CATCH_CLASS(L"PutDataSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_Save(BSTR par_FileName, enum PersistFormatEnum par_PersistFormat)
{
    try {
        /*
          void Save(const bstr_t& par_FileName = (BSTR)0, enum PersistFormatEnum par_PersistFormat = enum PersistFormatEnum(0));
        */
        static_cast<_B*>(this)->Save(bstr_t::create_const_reference(par_FileName), par_PersistFormat);
    } COMET_CATCH_CLASS(L"Save");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::get_ActiveCommand(IDispatch ** par_ppCmd)
{
    COMET_ASSERT(par_ppCmd);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppCmd) return E_POINTER;
#endif
    (*par_ppCmd) = 0;
    try {
        /*
          com_ptr<IDispatch> GetActiveCommand();
        */
        *par_ppCmd = com_ptr<IDispatch>::detach(static_cast<_B*>(this)->GetActiveCommand());
    } COMET_CATCH_CLASS(L"GetActiveCommand");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::put_StayInSync(VARIANT_BOOL par_pbStayInSync)
{
    try {
        /*
          void PutStayInSync(bool par_pbStayInSync);
        */
        static_cast<_B*>(this)->PutStayInSync(par_pbStayInSync!= COMET_VARIANT_FALSE);
    } COMET_CATCH_CLASS(L"PutStayInSync");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::get_StayInSync(VARIANT_BOOL* par_pbStayInSync)
{
    COMET_ASSERT(par_pbStayInSync);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbStayInSync) return E_POINTER;
#endif
    try {
        /*
          bool GetStayInSync();
        */
        *par_pbStayInSync = static_cast<_B*>(this)->GetStayInSync() ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE;
    } COMET_CATCH_CLASS(L"GetStayInSync");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_GetString(enum StringFormatEnum par_StringFormat, long par_NumRows, BSTR par_ColumnDelimeter, BSTR par_RowDelimeter, BSTR par_NullExpr, BSTR* par_pRetString)
{
    COMET_ASSERT(par_pRetString);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pRetString) return E_POINTER;
#endif
    (*par_pRetString) = 0;
    try {
        /*
          bstr_t GetString(enum StringFormatEnum par_StringFormat = enum StringFormatEnum(2), long par_NumRows = -1, const bstr_t& par_ColumnDelimeter = (BSTR)0, const bstr_t& par_RowDelimeter = (BSTR)0, const bstr_t& par_NullExpr = (BSTR)0);
        */
        *par_pRetString = bstr_t::detach(static_cast<_B*>(this)->GetString(par_StringFormat, par_NumRows, bstr_t::create_const_reference(par_ColumnDelimeter), bstr_t::create_const_reference(par_RowDelimeter), bstr_t::create_const_reference(par_NullExpr)));
    } COMET_CATCH_CLASS(L"GetString");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::get_DataMember(BSTR* par_pbstrDataMember)
{
    COMET_ASSERT(par_pbstrDataMember);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pbstrDataMember) return E_POINTER;
#endif
    (*par_pbstrDataMember) = 0;
    try {
        /*
          bstr_t GetDataMember();
        */
        *par_pbstrDataMember = bstr_t::detach(static_cast<_B*>(this)->GetDataMember());
    } COMET_CATCH_CLASS(L"GetDataMember");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::put_DataMember(BSTR par_pbstrDataMember)
{
    try {
        /*
          void PutDataMember(const bstr_t& par_pbstrDataMember);
        */
        static_cast<_B*>(this)->PutDataMember(bstr_t::create_const_reference(par_pbstrDataMember));
    } COMET_CATCH_CLASS(L"PutDataMember");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_CompareBookmarks(VARIANT par_Bookmark1, VARIANT par_Bookmark2, enum CompareEnum* par_pCompare)
{
    COMET_ASSERT(par_pCompare);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pCompare) return E_POINTER;
#endif
    try {
        /*
          CompareEnum CompareBookmarks(const variant_t& par_Bookmark1, const variant_t& par_Bookmark2);
        */
        *par_pCompare = static_cast<_B*>(this)->CompareBookmarks(variant_t::create_const_reference(par_Bookmark1), variant_t::create_const_reference(par_Bookmark2));
    } COMET_CATCH_CLASS(L"CompareBookmarks");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_Clone(enum LockTypeEnum par_LockType, _Recordset** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Recordset> Clone(enum LockTypeEnum par_LockType = enum LockTypeEnum(-1));
        */
        *par_ppvObject = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->Clone(par_LockType));
    } COMET_CATCH_CLASS(L"Clone");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _RecordsetImpl<_B, _S, _TL>::raw_Resync(enum AffectEnum par_AffectRecords, enum ResyncEnum par_ResyncValues)
{
    try {
        /*
          void Resync(enum AffectEnum par_AffectRecords = enum AffectEnum(3), enum ResyncEnum par_ResyncValues = enum ResyncEnum(2));
        */
        static_cast<_B*>(this)->Resync(par_AffectRecords, par_ResyncValues);
    } COMET_CATCH_CLASS(L"Resync");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_AbsolutePosition(enum PositionEnum* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          PositionEnum GetAbsolutePosition();
        */
        *par_pl = static_cast<_B*>(this)->GetAbsolutePosition();
    } COMET_CATCH_CLASS(L"GetAbsolutePosition");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_AbsolutePosition(enum PositionEnum par_pl)
{
    try {
        /*
          void PutAbsolutePosition(enum PositionEnum par_pl);
        */
        static_cast<_B*>(this)->PutAbsolutePosition(par_pl);
    } COMET_CATCH_CLASS(L"PutAbsolutePosition");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::putref_ActiveConnection(IDispatch * par_pvar)
{
    try {
        /*
          void PutrefActiveConnection(const com_ptr<IDispatch>& par_pvar);
        */
        static_cast<_B*>(this)->PutrefActiveConnection(com_ptr<IDispatch>::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutrefActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_ActiveConnection(VARIANT par_pvar)
{
    try {
        /*
          void PutActiveConnection(const variant_t& par_pvar);
        */
        static_cast<_B*>(this)->PutActiveConnection(variant_t::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_ActiveConnection(VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetActiveConnection();
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetActiveConnection());
    } COMET_CATCH_CLASS(L"GetActiveConnection");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_BOF(VARIANT_BOOL* par_pb)
{
    COMET_ASSERT(par_pb);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pb) return E_POINTER;
#endif
    try {
        /*
          bool GetBOF();
        */
        *par_pb = static_cast<_B*>(this)->GetBOF() ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE;
    } COMET_CATCH_CLASS(L"GetBOF");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Bookmark(VARIANT* par_pvBookmark)
{
    COMET_ASSERT(par_pvBookmark);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvBookmark) return E_POINTER;
#endif
    ::VariantInit(par_pvBookmark);
    try {
        /*
          variant_t GetBookmark();
        */
        *par_pvBookmark = variant_t::detach(static_cast<_B*>(this)->GetBookmark());
    } COMET_CATCH_CLASS(L"GetBookmark");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_Bookmark(VARIANT par_pvBookmark)
{
    try {
        /*
          void PutBookmark(const variant_t& par_pvBookmark);
        */
        static_cast<_B*>(this)->PutBookmark(variant_t::create_const_reference(par_pvBookmark));
    } COMET_CATCH_CLASS(L"PutBookmark");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_CacheSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetCacheSize();
        */
        *par_pl = static_cast<_B*>(this)->GetCacheSize();
    } COMET_CATCH_CLASS(L"GetCacheSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_CacheSize(long par_pl)
{
    try {
        /*
          void PutCacheSize(long par_pl);
        */
        static_cast<_B*>(this)->PutCacheSize(par_pl);
    } COMET_CATCH_CLASS(L"PutCacheSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_CursorType(enum CursorTypeEnum* par_plCursorType)
{
    COMET_ASSERT(par_plCursorType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plCursorType) return E_POINTER;
#endif
    try {
        /*
          CursorTypeEnum GetCursorType();
        */
        *par_plCursorType = static_cast<_B*>(this)->GetCursorType();
    } COMET_CATCH_CLASS(L"GetCursorType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_CursorType(enum CursorTypeEnum par_plCursorType)
{
    try {
        /*
          void PutCursorType(enum CursorTypeEnum par_plCursorType);
        */
        static_cast<_B*>(this)->PutCursorType(par_plCursorType);
    } COMET_CATCH_CLASS(L"PutCursorType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_EOF(VARIANT_BOOL* par_pb)
{
    COMET_ASSERT(par_pb);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pb) return E_POINTER;
#endif
    try {
        /*
          bool GetEOF();
        */
        *par_pb = static_cast<_B*>(this)->GetEOF() ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE;
    } COMET_CATCH_CLASS(L"GetEOF");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Fields(Fields** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<Fields> GetFields();
        */
        *par_ppvObject = com_ptr<Fields>::detach(static_cast<_B*>(this)->GetFields());
    } COMET_CATCH_CLASS(L"GetFields");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_LockType(enum LockTypeEnum* par_plLockType)
{
    COMET_ASSERT(par_plLockType);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plLockType) return E_POINTER;
#endif
    try {
        /*
          LockTypeEnum GetLockType();
        */
        *par_plLockType = static_cast<_B*>(this)->GetLockType();
    } COMET_CATCH_CLASS(L"GetLockType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_LockType(enum LockTypeEnum par_plLockType)
{
    try {
        /*
          void PutLockType(enum LockTypeEnum par_plLockType);
        */
        static_cast<_B*>(this)->PutLockType(par_plLockType);
    } COMET_CATCH_CLASS(L"PutLockType");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_MaxRecords(long* par_plMaxRecords)
{
    COMET_ASSERT(par_plMaxRecords);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plMaxRecords) return E_POINTER;
#endif
    try {
        /*
          long GetMaxRecords();
        */
        *par_plMaxRecords = static_cast<_B*>(this)->GetMaxRecords();
    } COMET_CATCH_CLASS(L"GetMaxRecords");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_MaxRecords(long par_plMaxRecords)
{
    try {
        /*
          void PutMaxRecords(long par_plMaxRecords);
        */
        static_cast<_B*>(this)->PutMaxRecords(par_plMaxRecords);
    } COMET_CATCH_CLASS(L"PutMaxRecords");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_RecordCount(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetRecordCount();
        */
        *par_pl = static_cast<_B*>(this)->GetRecordCount();
    } COMET_CATCH_CLASS(L"GetRecordCount");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::putref_Source(IDispatch * par_pvSource)
{
    try {
        /*
          void PutrefSource(const com_ptr<IDispatch>& par_pvSource);
        */
        static_cast<_B*>(this)->PutrefSource(com_ptr<IDispatch>::create_const_reference(par_pvSource));
    } COMET_CATCH_CLASS(L"PutrefSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_Source(BSTR par_pvSource)
{
    try {
        /*
          void PutSource(const bstr_t& par_pvSource);
        */
        static_cast<_B*>(this)->PutSource(bstr_t::create_const_reference(par_pvSource));
    } COMET_CATCH_CLASS(L"PutSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Source(VARIANT* par_pvSource)
{
    COMET_ASSERT(par_pvSource);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvSource) return E_POINTER;
#endif
    ::VariantInit(par_pvSource);
    try {
        /*
          variant_t GetSource();
        */
        *par_pvSource = variant_t::detach(static_cast<_B*>(this)->GetSource());
    } COMET_CATCH_CLASS(L"GetSource");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_AddNew(VARIANT par_FieldList, VARIANT par_Values)
{
    try {
        /*
          void AddNew(const variant_t& par_FieldList = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
        */
        static_cast<_B*>(this)->AddNew(variant_t::create_const_reference(par_FieldList), variant_t::create_const_reference(par_Values));
    } COMET_CATCH_CLASS(L"AddNew");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_CancelUpdate()
{
    try {
        /*
          void CancelUpdate();
        */
        static_cast<_B*>(this)->CancelUpdate();
    } COMET_CATCH_CLASS(L"CancelUpdate");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Close()
{
    try {
        /*
          void Close();
        */
        static_cast<_B*>(this)->Close();
    } COMET_CATCH_CLASS(L"Close");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Delete(enum AffectEnum par_AffectRecords)
{
    try {
        /*
          void Delete(enum AffectEnum par_AffectRecords = enum AffectEnum(1));
        */
        static_cast<_B*>(this)->Delete(par_AffectRecords);
    } COMET_CATCH_CLASS(L"Delete");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_GetRows(long par_Rows, VARIANT par_Start, VARIANT par_Fields, VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetRows(long par_Rows = -1, const variant_t& par_Start = variant_t::missing(), const variant_t& par_Fields = variant_t::missing());
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetRows(par_Rows, variant_t::create_const_reference(par_Start), variant_t::create_const_reference(par_Fields)));
    } COMET_CATCH_CLASS(L"GetRows");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Move(long par_NumRecords, VARIANT par_Start)
{
    try {
        /*
          void Move(long par_NumRecords, const variant_t& par_Start = variant_t::missing());
        */
        static_cast<_B*>(this)->Move(par_NumRecords, variant_t::create_const_reference(par_Start));
    } COMET_CATCH_CLASS(L"Move");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_MoveNext()
{
    try {
        /*
          void MoveNext();
        */
        static_cast<_B*>(this)->MoveNext();
    } COMET_CATCH_CLASS(L"MoveNext");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_MovePrevious()
{
    try {
        /*
          void MovePrevious();
        */
        static_cast<_B*>(this)->MovePrevious();
    } COMET_CATCH_CLASS(L"MovePrevious");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_MoveFirst()
{
    try {
        /*
          void MoveFirst();
        */
        static_cast<_B*>(this)->MoveFirst();
    } COMET_CATCH_CLASS(L"MoveFirst");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_MoveLast()
{
    try {
        /*
          void MoveLast();
        */
        static_cast<_B*>(this)->MoveLast();
    } COMET_CATCH_CLASS(L"MoveLast");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Open(VARIANT par_Source, VARIANT par_ActiveConnection, enum CursorTypeEnum par_CursorType, enum LockTypeEnum par_LockType, long par_Options)
{
    try {
        /*
          void Open(const variant_t& par_Source = variant_t::missing(), const variant_t& par_ActiveConnection = variant_t::missing(), enum CursorTypeEnum par_CursorType = enum CursorTypeEnum(-1), enum LockTypeEnum par_LockType = enum LockTypeEnum(-1), long par_Options = -1);
        */
        static_cast<_B*>(this)->Open(variant_t::create_const_reference(par_Source), variant_t::create_const_reference(par_ActiveConnection), par_CursorType, par_LockType, par_Options);
    } COMET_CATCH_CLASS(L"Open");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Requery(long par_Options)
{
    try {
        /*
          void Requery(long par_Options = -1);
        */
        static_cast<_B*>(this)->Requery(par_Options);
    } COMET_CATCH_CLASS(L"Requery");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw__xResync(enum AffectEnum par_AffectRecords)
{
    try {
        /*
          void _xResync(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
        */
        static_cast<_B*>(this)->_xResync(par_AffectRecords);
    } COMET_CATCH_CLASS(L"_xResync");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Update(VARIANT par_Fields, VARIANT par_Values)
{
    try {
        /*
          void Update(const variant_t& par_Fields = variant_t::missing(), const variant_t& par_Values = variant_t::missing());
        */
        static_cast<_B*>(this)->Update(variant_t::create_const_reference(par_Fields), variant_t::create_const_reference(par_Values));
    } COMET_CATCH_CLASS(L"Update");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_AbsolutePage(enum PositionEnum* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          PositionEnum GetAbsolutePage();
        */
        *par_pl = static_cast<_B*>(this)->GetAbsolutePage();
    } COMET_CATCH_CLASS(L"GetAbsolutePage");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_AbsolutePage(enum PositionEnum par_pl)
{
    try {
        /*
          void PutAbsolutePage(enum PositionEnum par_pl);
        */
        static_cast<_B*>(this)->PutAbsolutePage(par_pl);
    } COMET_CATCH_CLASS(L"PutAbsolutePage");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_EditMode(enum EditModeEnum* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          EditModeEnum GetEditMode();
        */
        *par_pl = static_cast<_B*>(this)->GetEditMode();
    } COMET_CATCH_CLASS(L"GetEditMode");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Filter(VARIANT* par_Criteria)
{
    COMET_ASSERT(par_Criteria);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_Criteria) return E_POINTER;
#endif
    ::VariantInit(par_Criteria);
    try {
        /*
          variant_t GetFilter();
        */
        *par_Criteria = variant_t::detach(static_cast<_B*>(this)->GetFilter());
    } COMET_CATCH_CLASS(L"GetFilter");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_Filter(VARIANT par_Criteria)
{
    try {
        /*
          void PutFilter(const variant_t& par_Criteria);
        */
        static_cast<_B*>(this)->PutFilter(variant_t::create_const_reference(par_Criteria));
    } COMET_CATCH_CLASS(L"PutFilter");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_PageCount(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetPageCount();
        */
        *par_pl = static_cast<_B*>(this)->GetPageCount();
    } COMET_CATCH_CLASS(L"GetPageCount");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_PageSize(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetPageSize();
        */
        *par_pl = static_cast<_B*>(this)->GetPageSize();
    } COMET_CATCH_CLASS(L"GetPageSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_PageSize(long par_pl)
{
    try {
        /*
          void PutPageSize(long par_pl);
        */
        static_cast<_B*>(this)->PutPageSize(par_pl);
    } COMET_CATCH_CLASS(L"PutPageSize");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Sort(BSTR* par_Criteria)
{
    COMET_ASSERT(par_Criteria);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_Criteria) return E_POINTER;
#endif
    (*par_Criteria) = 0;
    try {
        /*
          bstr_t GetSort();
        */
        *par_Criteria = bstr_t::detach(static_cast<_B*>(this)->GetSort());
    } COMET_CATCH_CLASS(L"GetSort");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_Sort(BSTR par_Criteria)
{
    try {
        /*
          void PutSort(const bstr_t& par_Criteria);
        */
        static_cast<_B*>(this)->PutSort(bstr_t::create_const_reference(par_Criteria));
    } COMET_CATCH_CLASS(L"PutSort");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Status(long* par_pl)
{
    COMET_ASSERT(par_pl);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pl) return E_POINTER;
#endif
    try {
        /*
          long GetStatus();
        */
        *par_pl = static_cast<_B*>(this)->GetStatus();
    } COMET_CATCH_CLASS(L"GetStatus");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_State(long* par_plObjState)
{
    COMET_ASSERT(par_plObjState);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plObjState) return E_POINTER;
#endif
    try {
        /*
          long GetState();
        */
        *par_plObjState = static_cast<_B*>(this)->GetState();
    } COMET_CATCH_CLASS(L"GetState");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw__xClone(_Recordset** par_ppvObject)
{
    COMET_ASSERT(par_ppvObject);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_ppvObject) return E_POINTER;
#endif
    try {
        /*
          com_ptr<_Recordset> _xClone();
        */
        *par_ppvObject = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->_xClone());
    } COMET_CATCH_CLASS(L"_xClone");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_UpdateBatch(enum AffectEnum par_AffectRecords)
{
    try {
        /*
          void UpdateBatch(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
        */
        static_cast<_B*>(this)->UpdateBatch(par_AffectRecords);
    } COMET_CATCH_CLASS(L"UpdateBatch");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_CancelBatch(enum AffectEnum par_AffectRecords)
{
    try {
        /*
          void CancelBatch(enum AffectEnum par_AffectRecords = enum AffectEnum(3));
        */
        static_cast<_B*>(this)->CancelBatch(par_AffectRecords);
    } COMET_CATCH_CLASS(L"CancelBatch");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_CursorLocation(enum CursorLocationEnum* par_plCursorLoc)
{
    COMET_ASSERT(par_plCursorLoc);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_plCursorLoc) return E_POINTER;
#endif
    try {
        /*
          CursorLocationEnum GetCursorLocation();
        */
        *par_plCursorLoc = static_cast<_B*>(this)->GetCursorLocation();
    } COMET_CATCH_CLASS(L"GetCursorLocation");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_CursorLocation(enum CursorLocationEnum par_plCursorLoc)
{
    try {
        /*
          void PutCursorLocation(enum CursorLocationEnum par_plCursorLoc);
        */
        static_cast<_B*>(this)->PutCursorLocation(par_plCursorLoc);
    } COMET_CATCH_CLASS(L"PutCursorLocation");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_NextRecordset(VARIANT* par_RecordsAffected, _Recordset** par_ppiRs)
{
    COMET_ASSERT(par_RecordsAffected);
    COMET_ASSERT(par_ppiRs);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_RecordsAffected) return E_POINTER;
    if (!par_ppiRs) return E_POINTER;
#endif
    ::VariantInit(par_RecordsAffected);
    try {
        variant_t par_RecordsAffected_tmp;
        /*
          com_ptr<_Recordset> NextRecordset(variant_t& par_RecordsAffected);
        */
        *par_ppiRs = com_ptr<_Recordset>::detach(static_cast<_B*>(this)->NextRecordset(par_RecordsAffected_tmp));
        *par_RecordsAffected = variant_t::detach(par_RecordsAffected_tmp);
    } COMET_CATCH_CLASS(L"NextRecordset");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Supports(enum CursorOptionEnum par_CursorOptions, VARIANT_BOOL* par_pb)
{
    COMET_ASSERT(par_pb);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pb) return E_POINTER;
#endif
    try {
        /*
          bool Supports(enum CursorOptionEnum par_CursorOptions);
        */
        *par_pb = static_cast<_B*>(this)->Supports(par_CursorOptions) ? COMET_VARIANT_TRUE : COMET_VARIANT_FALSE;
    } COMET_CATCH_CLASS(L"Supports");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_Collect(VARIANT par_Index, VARIANT* par_pvar)
{
    COMET_ASSERT(par_pvar);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_pvar) return E_POINTER;
#endif
    ::VariantInit(par_pvar);
    try {
        /*
          variant_t GetCollect(const variant_t& par_Index);
        */
        *par_pvar = variant_t::detach(static_cast<_B*>(this)->GetCollect(variant_t::create_const_reference(par_Index)));
    } COMET_CATCH_CLASS(L"GetCollect");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_Collect(VARIANT par_Index, VARIANT par_pvar)
{
    try {
        /*
          void PutCollect(const variant_t& par_Index, const variant_t& par_pvar);
        */
        static_cast<_B*>(this)->PutCollect(variant_t::create_const_reference(par_Index), variant_t::create_const_reference(par_pvar));
    } COMET_CATCH_CLASS(L"PutCollect");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::get_MarshalOptions(enum MarshalOptionsEnum* par_peMarshal)
{
    COMET_ASSERT(par_peMarshal);
#ifndef COMET_NO_POINTER_CHECKING
    if (!par_peMarshal) return E_POINTER;
#endif
    try {
        /*
          MarshalOptionsEnum GetMarshalOptions();
        */
        *par_peMarshal = static_cast<_B*>(this)->GetMarshalOptions();
    } COMET_CATCH_CLASS(L"GetMarshalOptions");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::put_MarshalOptions(enum MarshalOptionsEnum par_peMarshal)
{
    try {
        /*
          void PutMarshalOptions(enum MarshalOptionsEnum par_peMarshal);
        */
        static_cast<_B*>(this)->PutMarshalOptions(par_peMarshal);
    } COMET_CATCH_CLASS(L"PutMarshalOptions");
    return S_OK;
}

template<typename _B, typename _S, typename _TL>
STDMETHODIMP _Recordset15Impl<_B, _S, _TL>::raw_Find(BSTR par_Criteria, long par_SkipRecords, enum SearchDirectionEnum par_SearchDirection, VARIANT par_Start)
{
    try {
        /*
          void Find(const bstr_t& par_Criteria, long par_SkipRecords = 0, enum SearchDirectionEnum par_SearchDirection = enum SearchDirectionEnum(1), const variant_t& par_Start = variant_t::missing());
        */
        static_cast<_B*>(this)->Find(bstr_t::create_const_reference(par_Criteria), par_SkipRecords, par_SearchDirection, variant_t::create_const_reference(par_Start));
    } COMET_CATCH_CLASS(L"Find");
    return S_OK;
}

} // end of namespace

//
// Connection Point implementation
//

template<> class connection_point<ADODB::ConnectionEvents> : public connection_point_impl<ADODB::ConnectionEvents> {
public:
    connection_point(IUnknown* pUnk) : connection_point_impl<ADODB::ConnectionEvents>(pUnk) {}

    inline void Fire_InfoMessage(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_InfoMessage(par_pError.in(), &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_BeginTransComplete(long par_TransactionLevel, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_BeginTransComplete(par_TransactionLevel, par_pError.in(), &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_CommitTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_CommitTransComplete(par_pError.in(), &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_RollbackTransComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_RollbackTransComplete(par_pError.in(), &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_WillExecute(bstr_t& par_Source, enum ADODB::CursorTypeEnum& par_CursorType, enum ADODB::LockTypeEnum& par_LockType, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_WillExecute(par_Source.inout(), &par_CursorType, &par_LockType, &par_Options, &par_adStatus, par_pCommand.in(), par_pRecordset.in(), par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_ExecuteComplete(long par_RecordsAffected, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Command>& par_pCommand, const com_ptr<ADODB::_Recordset>& par_pRecordset, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_ExecuteComplete(par_RecordsAffected, par_pError.in(), &par_adStatus, par_pCommand.in(), par_pRecordset.in(), par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_WillConnect(bstr_t& par_ConnectionString, bstr_t& par_UserID, bstr_t& par_Password, long& par_Options, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_WillConnect(par_ConnectionString.inout(), par_UserID.inout(), par_Password.inout(), &par_Options, &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_ConnectComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_ConnectComplete(par_pError.in(), &par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    inline void Fire_Disconnect(enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Connection>& par_pConnection)
    {
        Fire_Disconnect(&par_adStatus, par_pConnection.in(), comet::cp_throw());
    }

    template<typename HANDLER>
    void Fire_InfoMessage(IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_BeginTransComplete(long par_TransactionLevel, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = par_TransactionLevel; V_VT(&(vars[3])) = VT_I4;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_CommitTransComplete(IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_RollbackTransComplete(IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_WillExecute(BSTR* par_Source, enum ADODB::CursorTypeEnum* par_CursorType, enum ADODB::LockTypeEnum* par_LockType, long* par_Options, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pCommand, IDispatch* par_pRecordset, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[8];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_BSTRREF(&vars[7]) = par_Source; V_VT(&(vars[7])) = (VT_BSTR | VT_BYREF);
            V_I4REF(&vars[6]) = (long*)par_CursorType; V_VT(&(vars[6])) = (VT_I4 | VT_BYREF);
            V_I4REF(&vars[5]) = (long*)par_LockType; V_VT(&(vars[5])) = (VT_I4 | VT_BYREF);
            V_I4REF(&vars[4]) = par_Options; V_VT(&(vars[4])) = (VT_I4 | VT_BYREF);
            V_I4REF(&vars[3]) = (long*)par_adStatus; V_VT(&(vars[3])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[2]) = par_pCommand; V_VT(&(vars[2])) = VT_DISPATCH;
            V_DISPATCH(&vars[1]) = par_pRecordset; V_VT(&(vars[1])) = VT_DISPATCH;
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 8, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_ExecuteComplete(long par_RecordsAffected, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pCommand, IDispatch* par_pRecordset, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[6];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[5]) = par_RecordsAffected; V_VT(&(vars[5])) = VT_I4;
            V_DISPATCH(&vars[4]) = par_pError; V_VT(&(vars[4])) = VT_DISPATCH;
            V_I4REF(&vars[3]) = (long*)par_adStatus; V_VT(&(vars[3])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[2]) = par_pCommand; V_VT(&(vars[2])) = VT_DISPATCH;
            V_DISPATCH(&vars[1]) = par_pRecordset; V_VT(&(vars[1])) = VT_DISPATCH;
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 6, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_WillConnect(BSTR* par_ConnectionString, BSTR* par_UserID, BSTR* par_Password, long* par_Options, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[6];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_BSTRREF(&vars[5]) = par_ConnectionString; V_VT(&(vars[5])) = (VT_BSTR | VT_BYREF);
            V_BSTRREF(&vars[4]) = par_UserID; V_VT(&(vars[4])) = (VT_BSTR | VT_BYREF);
            V_BSTRREF(&vars[3]) = par_Password; V_VT(&(vars[3])) = (VT_BSTR | VT_BYREF);
            V_I4REF(&vars[2]) = par_Options; V_VT(&(vars[2])) = (VT_I4 | VT_BYREF);
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 6, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_ConnectComplete(IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_Disconnect(enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pConnection,  HANDLER &_par_h )
    {
        VARIANT vars[2];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pConnection; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 2, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

};

template<> class connection_point<ADODB::RecordsetEvents> : public connection_point_impl<ADODB::RecordsetEvents> {
public:
    connection_point(IUnknown* pUnk) : connection_point_impl<ADODB::RecordsetEvents>(pUnk) {}

    inline void Fire_WillChangeField(long par_cFields, const variant_t& par_Fields, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_WillChangeField(par_cFields, par_Fields.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_FieldChangeComplete(long par_cFields, const variant_t& par_Fields, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_FieldChangeComplete(par_cFields, par_Fields.in(), par_pError.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_WillChangeRecord(par_adReason, par_cRecords, &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_RecordChangeComplete(par_adReason, par_cRecords, par_pError.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_WillChangeRecordset(par_adReason, &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_RecordsetChangeComplete(par_adReason, par_pError.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_WillMove(par_adReason, &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_MoveComplete(enum ADODB::EventReasonEnum par_adReason, const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_MoveComplete(par_adReason, par_pError.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_EndOfRecordset(bool& par_fMoreData, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_EndOfRecordset(bool_inout(par_fMoreData), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_FetchProgress(par_Progress, par_MaxProgress, &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    inline void Fire_FetchComplete(const com_ptr<ADODB::Error>& par_pError, enum ADODB::EventStatusEnum& par_adStatus, const com_ptr<ADODB::_Recordset>& par_pRecordset)
    {
        Fire_FetchComplete(par_pError.in(), &par_adStatus, par_pRecordset.in(), comet::cp_throw());
    }

    template<typename HANDLER>
    void Fire_WillChangeField(long par_cFields, VARIANT par_Fields, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = par_cFields; V_VT(&(vars[3])) = VT_I4;
            vars[2] = par_Fields;             V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_FieldChangeComplete(long par_cFields, VARIANT par_Fields, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[5];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[4]) = par_cFields; V_VT(&(vars[4])) = VT_I4;
            vars[3] = par_Fields;             V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 5, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_WillChangeRecord(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = (long)par_adReason; V_VT(&(vars[3])) = VT_I4;
            V_I4(&vars[2]) = par_cRecords; V_VT(&(vars[2])) = VT_I4;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_RecordChangeComplete(enum ADODB::EventReasonEnum par_adReason, long par_cRecords, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[5];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[4]) = (long)par_adReason; V_VT(&(vars[4])) = VT_I4;
            V_I4(&vars[3]) = par_cRecords; V_VT(&(vars[3])) = VT_I4;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 5, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_WillChangeRecordset(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[2]) = (long)par_adReason; V_VT(&(vars[2])) = VT_I4;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_RecordsetChangeComplete(enum ADODB::EventReasonEnum par_adReason, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = (long)par_adReason; V_VT(&(vars[3])) = VT_I4;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_WillMove(enum ADODB::EventReasonEnum par_adReason, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[2]) = (long)par_adReason; V_VT(&(vars[2])) = VT_I4;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_MoveComplete(enum ADODB::EventReasonEnum par_adReason, IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = (long)par_adReason; V_VT(&(vars[3])) = VT_I4;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_EndOfRecordset(VARIANT_BOOL* par_fMoreData, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_BOOLREF(&vars[2]) = par_fMoreData; V_VT(&(vars[2])) = (VT_BOOL | VT_BYREF);
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(17, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_FetchProgress(long par_Progress, long par_MaxProgress, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[4];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_I4(&vars[3]) = par_Progress; V_VT(&(vars[3])) = VT_I4;
            V_I4(&vars[2]) = par_MaxProgress; V_VT(&(vars[2])) = VT_I4;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 4, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(18, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

    template<typename HANDLER>
    void Fire_FetchComplete(IDispatch* par_pError, enum ADODB::EventStatusEnum* par_adStatus, IDispatch* par_pRecordset,  HANDLER &_par_h )
    {
        VARIANT vars[3];

        for (CONNECTIONS::iterator next,it = connections_.begin(); it != connections_.end(); it=next)
        {
            next=it;++next;
            V_DISPATCH(&vars[2]) = par_pError; V_VT(&(vars[2])) = VT_DISPATCH;
            V_I4REF(&vars[1]) = (long*)par_adStatus; V_VT(&(vars[1])) = (VT_I4 | VT_BYREF);
            V_DISPATCH(&vars[0]) = par_pRecordset; V_VT(&(vars[0])) = VT_DISPATCH;
            DISPPARAMS disp = { vars, 0, 3, 0 };
            HRESULT _hr_ = it->second.raw()->Invoke(19, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, 0, 0, 0);
            if( _par_h.check_fail( _hr_ ) )  _par_h.on_fail( connections_, it);
        }
    }

};

} // end of namespace

#pragma pack(pop)
#endif
