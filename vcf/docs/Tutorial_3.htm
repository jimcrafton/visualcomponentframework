<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:fontset("Arial","Arial") -->
  <!-- $MVD$:fontset("Verdana","Verdana") -->
  <!-- $MVD$:fontset("Courier New","Courier New") -->
  <TITLE>Tutorial 3</TITLE>
  <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK REL="StyleSheet" HREF="default.css"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <H1>
   <IMG SRC="vcflogo.gif" WIDTH="230" HEIGHT="172" VSPACE="0" HSPACE="0" BORDER="0"></H1>
  <H1>
   Tutorial 3</H1>
  <P>
   In this tutorial we'll cover the basics of events and how to add 
   support for them to our Employee class. For a more detailed 
   discussion of events see the <A HREF="Events_In_the_VCF.htm">Events</A> topic.</P>
  <P>
   Events happen when something changes in an object. When you click on 
   the close button of a window you fire off an event that closes the 
   window, and possible the application it represents. Events are 
   particularly useful because they allow other objects to be notified 
   when the event happens. These other objects are called Listeners in 
   the VCF. This is a standard pattern in which an observer is notified 
   when an Event is fired in the object being observed (formally this is 
   known as the &quot;Observer&quot; pattern).</P>
  <P>
   Lets get a little more specific and talk about this is terms of our 
   Employee class. Lets say that when an Employee's age changes, then 
   the Employee fires off an Event. Just firing off the event is 
   meaningless unless we actually have something to fire off the event 
   to, in other words, a list of Listeners that are interested in 
   knowing that the Employee's age has changed. These Listeners are 
   identified through a common interface that describes the kind of 
   events the Employee can fire off, and the Listener can in turn 
   respond to. So, in addition to firing off the event, the Employee 
   must also have some means of allowing for Listeners to be added and 
   removed from the Employee's Listener list. Lets create the Listener 
   interface for the Employee and call it EmployeeListener, and describe 
   it as follows:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> EmployeeListener : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Listener {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~EmployeeListener(){};<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> <SPAN STYLE="font-weight : bold;">void</SPAN> onAgeChange( EmployeeEvent* event )<SPAN STYLE="font-weight : bold;"> = 0</SPAN>;<BR>}; </PRE><P>
   There are several things to note here: firstly, the class has no 
   constructor declared. This is OK because we'll never create an 
   instance of the class, but we do need the virtual destructor to make 
   the C++ compiler happy. The class itself derives from common base 
   class Listener, which has not methods itself, but serves it purpose 
   by essentially being a &quot;marker&quot; class, i.e. a common base 
   class for RTTI purposes. The other thing to note is the onAgeChange() 
   method. It is marked virtual, and pure (that's what the <SPAN STYLE="font-style : italic;font-weight : bold;">=
    0</SPAN> syntax does), which means that whoever inherits from this 
   class must implement this method in order for the deriving class to 
   be able to be instantiated. Notice that the onAgeChange() method also 
   takes a pointer to an EmployeeEvent object, which we need to define. 
   This EmployeeEvent object will contain information about the event 
   that was just fired, such as the who fired it (i.e. a pointer to the 
   Employee object whose age changed), when the event was fired, and any 
   other information that might be pertinent. All methods on listener 
   classes should have the form:</P><PRE><SPAN
    STYLE="font-weight : bold;">void</SPAN> methodName( EventDerivedClass* event )</PRE><P>
   Where the EventDerivedClass is some class that derives the VCF Event class.</P>
  <P>
   Just as EmployeeListener derived from a common base class, so to will 
   our EmployeeEvent derive from Event, the common base class in the VCF 
   for all event classes. The Event class provides support for 
   identifying who sent the event (the sender must be derived from 
   Object), when it was sent, and an optional integer event type value. 
   So let's define our EmployeeEvent as follows:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> EmployeeEvent : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Event {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     EmployeeEvent( Object* sender ) :<BR>          Event( sender ){};<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~EmployeeEvent(){};<BR><BR>};</PRE><P>
   Now we have our event class defined and our listener interface what 
   can we do with them ? Well in more tradional event models, the 
   &quot;listner&quot; is a single callback, a function pointer to some 
   global function that gets called when the event happens. The problem 
   with this is that (typically) only one of these functions can get 
   called, and if you would like a variety of different objects to get 
   notified when the event happens you are out of luck, you have to come 
   up with something else. In the Listener pattern, the object 
   interested in receiving hte event notifications can register itself 
   with the object that fires the event, thus a single event can notfiy 
   any number of listeners. When the object that was 
   &quot;listening&quot; no longer cares about receiving events it can 
   unregister itself with the object it was listening to as well. In the 
   VCF this registration/unregistration takes the form of two methods, 
   one with the naming pattern &quot;add&quot; plus the name of the 
   Listener interface and the other (the unregistration method) with the 
   naming pattern &quot;remove&quot; plus the name of the Listener 
   interface. In the case of the Employee object we would have the following:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object{<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//....rest of class declaration ommitted for clarity</FONT></SPAN><BR><BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">//registers the Listener with the Employee</SPAN></FONT></SPAN>   <BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> addEmployeeListener( EmployeeListener* listener );<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">//unregisters the Listener with the Employee</SPAN></FONT></SPAN>  <BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> removeEmployeeListener( EmployeeListener* listener );<BR>};</PRE><P>
   Now we can add and remove any EmployeeListener we want to any 
   Employee object. A typical implementation of this would be to keep a 
   vector of EmployeeListener* and simply add and remove items to the 
   list as neccessary. In addition, when the event was fired, the 
   Employee would simply loop through the vector and call the proper 
   EmployeeListener method on each pointer in the vector. Because this 
   is basically the same code over and over again, a set of macros has 
   been provided to simplify the process, you don't have to use them, 
   but it saves typing ! To use them we would replace the above code as follows:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object{<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//....rest of class declaration ommitted for clarity</FONT></SPAN><BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//makes a std::vector&lt;EmployeeListener*&gt; member variable  </FONT></SPAN><BR>     LISTENER_LIST( EmployeeListener )<BR><BR><SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">     //registers the Listener with the Employee</SPAN></FONT></SPAN>   <BR>     ADD_LISTENER( EmployeeListener )<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">//unregisters the Listener with the Employee</SPAN></FONT></SPAN>  <BR>     REMOVE_LISTENER( EmployeeListener )<BR>};</PRE><P>
   The LISTENER_LIST() macro takes the Listener type (in this case an 
   EmployeeListener) and declares a member variable of the type 
   std::vector&lt;EmployeeListener*&gt;. The ADD_LISTENER() macro 
   declares the addEmployeeListener() method and implements it inline as 
   discussed before (if you're interested in the implementation, please 
   see the Listener.h file where these macros are defined). Likewise the 
   REMOVE_LISTENER() macro declares the removeEmployeeListener() method 
   and also implements it inline. Both implementations use the vector 
   member variable declared with the LISTENER_LIST macro.</P>
  <P>
   Now that we have the Listener housekeeping done, we still need to 
   decalre methods on the Employee class that fire off the event and 
   notify all the registered listeners. While we can call the method 
   anything we want, in the VCF the naming pattern is &quot;notify_&quot;
    plus the method on the Listener interface that will be called. So in 
   the case of the Employee we would do the this:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object{<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//....rest of class declaration ommitted for clarity</FONT></SPAN><BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//makes a std::vector&lt;EmployeeListener*&gt; member variable  </FONT></SPAN><BR>     LISTENER_LIST( EmployeeListener )<BR><BR><SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">     //registers the Listener with the Employee</SPAN></FONT></SPAN>    <BR>     ADD_LISTENER( EmployeeListener )<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">//unregisters the Listener with the Employee</SPAN></FONT></SPAN>  <BR>     REMOVE_LISTENER( EmployeeListener )<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//fire the event and notify the EmployeeListeners</FONT></SPAN><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> notify_onAgeChange( EmployeeEvent* event );   <BR>};</PRE><P>
   Like the add and remove listener methods, the code for the event 
   firing is always the same, as we mentioned above. Loop through the 
   vector of listeners and call the appropriate method on each of the 
   listener pointers. To make this kind of repetitive code easier to 
   work with, a macro has been declared to simplify things. So we can 
   now write:</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Employee : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object{<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Employee();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Employee();<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//....rest of class declaration ommitted for clarity</FONT></SPAN><BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//makes a std::vector&lt;EmployeeListener*&gt; member variable  </FONT></SPAN><BR>     LISTENER_LIST( EmployeeListener )<BR><BR><SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">     //registers the Listener with the Employee</SPAN></FONT></SPAN>   <BR>     ADD_LISTENER( EmployeeListener )<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE"><SPAN STYLE="font-weight : normal;">//unregisters the Listener with the Employee</SPAN></FONT></SPAN>  <BR>     REMOVE_LISTENER( EmployeeListener )<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//fire the event and notify the EmployeeListeners</FONT></SPAN><BR><SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">     </FONT></SPAN>NOTIFIER(EmployeeListener, onAgeChange, EmployeeEvent )<BR>};</PRE><P>
   The NOTIFIER() macro declares a method the same as what we previously 
   had ( notify_onAgeChange() ), and implements it inline as discussed 
   before. You use by passing in the type of the listener interface, the 
   method to call on the listener, and the event type the method takes. 
   Remember that all listener methods have a similar form, that is they 
   are void functions that take a pointer to some object that is itself 
   derived from Event.</P>
  <P>
   We now have all the pieces neccessary for firing events, so let's 
   look at a possible implementation that does this. Remember we said 
   that when the Employee's age changes we want to fire an event, os 
   let's look at the Employee::setAge() method:</P><PRE><SPAN
    STYLE="font-weight : bold;">void</SPAN> Employee::setAge( <SPAN STYLE="font-weight : bold;">const</SPAN> <SPAN STYLE="font-weight : bold;">int</SPAN>&amp; age )<BR>{<BR>     <SPAN
    STYLE="font-weight : bold;">int</SPAN> previousAge = m_age;<BR>     m_age = age;<BR>     <SPAN
    STYLE="font-weight : bold;">if</SPAN> ( previousAge != m_age )  { <SPAN STYLE="font-style : italic;font-weight : normal;"><FONT COLOR="BLUE">//the age changed</FONT></SPAN><BR><SPAN
    STYLE="font-style : italic;font-weight : normal;"><FONT COLOR="BLUE">          </FONT></SPAN><SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//Create a new event object and pass in the Employee instance as the sender</FONT></SPAN><BR>          EmployeeEvent ageChangedEvent( <SPAN
    STYLE="font-weight : bold;">this</SPAN> );<BR><BR>          notify_onAgeChange( &amp;ageChangedEvent );<BR>     }<BR>}</PRE><P>
   Now anyone registered with the particular Employee instance will 
   receive a notification when the Employee's age changes ! Later on you 
   might want to modify the EmployeeEvent so that it stores more useful 
   information, such as the Employee's previous age prior to the change, 
   but for now I think the point of what is going on is hopefully pretty clear.</P>
  <P>
   So far we have focused entirely on the Employee's implementation of 
   firing off events, but we haven't yet looked at the other side of the 
   equation: the Listener implementation itself. To do this lets create 
   a simple class for the sake of demonstrating the techniques, the evil 
   Manager class.</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Manager : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object  {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Manager();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Manager();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> setManagerIsEvil( <SPAN STYLE="font-weight : bold;">const</SPAN> <SPAN STYLE="font-weight : bold;">bool</SPAN>&amp; managerIsEvil ) {<BR>          m_evilManager = managerIsEvil;<BR>     }<BR><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> fireEmployee( Employee* employeeToBeFired );<BR><SPAN
    STYLE="font-weight : bold;">private</SPAN>:<BR>     <SPAN
    STYLE="font-weight : bold;">bool</SPAN> m_evilManager;      <BR>};</PRE><P>
   The Manager will want to be notified whenever one of it's Employee's 
   age changes. If the Manager's m_evilManager member is true, then the 
   Manager will fire the Employee when the Employee's age is greater 
   than 160 (remember - this is an evil manager we're talking about here 
   - yes, yes I realize this is not completely politically correct, it's 
   a joke, and this is the simplest example I could think of ! ).</P>
  <P>
   So, how does all this happen ? Well there are several ways to do 
   this, the simplest being for the Manager class to implement the 
   EmployeeListener <A HREF="JavaScript:hhctrl.TextPopup('The term Interface in the VCF does not mean a COM interface, instead it is just a C++ class that has a set of virtual pure methods defined that must be implemented by a deriving class. Further more the interface class must either derive from another inter','Arial,8',10,10,00000000,0xc0ffff)">interface</A>.
    The problem with this occurs when the Manager wants to listen to 
   multiple Employee's and do different things depending on the 
   Employee. Another, more flexible way, is to create a simple object 
   that implements the EmployeeListener interface, and that simply makes 
   a callback to the appropriate Manager method. In the VCF this kind of 
   class is called an Adapter (or also a Handler), and it simply acts as 
   a sophisticated callback mechanism. To manage the various adapters, 
   any class that derives from VCF::Object can add the adapter to the 
   Object's list of adapters by calling addEventHandler() and passing in 
   a pointer to the adapter and it's name (whatever you want to call 
   it). This list will autmatically be cleared and the adapters deleted 
   when the Object is destroyed. The adapters work by keeping a pointer 
   to the source object (in this case the Manager), and memeber 
   variables that represent member function pointers on the source 
   object. Each listener method they implement then simply calls the 
   appropriate member function pointer on the source object. This 
   probably sounds more complicated than it actually is, so let's look 
   an example:</P><PRE><!-- $MVD$:spaceretainer() --> <BR><SPAN
    STYLE="font-weight : bold;">typedef</SPAN> <SPAN STYLE="font-weight : bold;">void</SPAN> (VCF::Object*OnEmployeeEvent)( EmployeeEvent* event );<BR><BR><SPAN
    STYLE="font-weight : bold;">class</SPAN> EmployeeAdapter : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object, <SPAN STYLE="font-weight : bold;">public</SPAN> EmployeeListener {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     EmployeeAdapter( VCF::Object* source )  {<BR>          m_source = source;<BR>          m_ageChangeCallback = NULL; <BR>     }<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~EmployeeAdapter(){};<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> <SPAN STYLE="font-weight : bold;">void</SPAN> onAgeChange( EmployeeEvent* event )  {<BR>          <SPAN
    STYLE="font-weight : bold;">if</SPAN> ( (<SPAN STYLE="font-weight : bold;">NULL</SPAN> <SPAN STYLE="font-weight : normal;">!=</SPAN> m_source) <SPAN STYLE="font-weight : bold;">&amp;&amp;</SPAN> (<SPAN STYLE="font-weight : bold;">NULL</SPAN> != m_ageChangeCallback) )  {<BR>              (m_source-&gt;*m_ageChangeCallback)( event );<BR>          }<BR>     }<BR><BR>     VCF::Object* m_source;<BR>     OnEmployeeEvent m_ageChangeCallback;<BR>};</PRE><P>
   First we create a typedef for our function pointer - they must all be 
   member functions on objects that are derived from VCF::Object, and 
   they take a single EmployeeEvent pointer as their argument. Next we 
   declare our adapter class, calling it EmployeeAdapater, and deriving 
   from VC::Object (this is required) as well as the EmployeeListener 
   class. We then declare two member variables, one for the source of 
   the EmployeeAdapter (called, surprise, surprise, m_source) and 
   another for the member function pointer. The implementation is also 
   pretty simple, we implement the EmployeeListener's sole method 
   onAgeChange(), by doing just what we described earlier - we call the 
   function pointer on the source ( that's what the 
   m_source-&gt;*m_ageChangeCallback syntax does) and pass in the event 
   pointer that was passed to us.</P>
  <P>
   Now that we have a working adapter, lets flush out our Manager class :</P><PRE><SPAN
    STYLE="font-weight : bold;">class</SPAN> Manager : <SPAN STYLE="font-weight : bold;">public</SPAN> VCF::Object  {<BR><SPAN
    STYLE="font-weight : bold;">public</SPAN>:<BR>     Manager();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">virtual</SPAN> ~Manager();<BR><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> setManagerIsEvil( <SPAN STYLE="font-weight : bold;">const</SPAN> <SPAN STYLE="font-weight : bold;">bool</SPAN>&amp; managerIsEvil ) {<BR>          m_evilManager = managerIsEvil;<BR>     }<BR><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> fireEmployee( Employee* employeeToBeFired );<BR><BR>     <SPAN
    STYLE="font-style : italic;"><FONT COLOR="BLUE">//here's our callback </FONT></SPAN><BR>     <SPAN
    STYLE="font-weight : bold;">void</SPAN> onEmployeeGetsOlder( EmployeeEvent* event ) { <BR>          Employee* employee = (Employee*)event-&gt;getSender();<BR>          <SPAN
    STYLE="font-weight : bold;">if</SPAN> ( (employee-&gt;getAge() &gt; 160) &amp;&amp; (m_evilManager == <SPAN STYLE="font-weight : bold;">true</SPAN>) )  {<BR>               fireEmployee( employee );<BR>          }<BR>     } <BR><SPAN
    STYLE="font-weight : bold;">private</SPAN>:<BR>     <SPAN
    STYLE="font-weight : bold;">bool</SPAN> m_evilManager;      <BR>};</PRE><P>
   There's our evil Manager class, now let's get an example going !</P><PRE><FONT
    COLOR="GRAY"><SPAN STYLE="font-weight : bold;">1</SPAN></FONT> <SPAN STYLE="font-weight : bold;">int</SPAN> main()<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">2</FONT></SPAN> {<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN>     initFoundationKit();<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">4</FONT></SPAN>     Employee bob;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">5</FONT></SPAN>     bob.setName( <FONT COLOR="RED">&quot;Bob Johansen&quot;</FONT> );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">6</FONT></SPAN>     bob.setAge( <FONT COLOR="FUCHSIA">26</FONT> ); <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">7</FONT></SPAN>      <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">8</FONT></SPAN>     Manager bobsEvilManager;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">9</FONT></SPAN>     Manager bobsNiceManager;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">10</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">11</FONT></SPAN>    bobsEvilManager.setManagerIsEvil( <SPAN STYLE="font-weight : bold;">true</SPAN> );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">12</FONT></SPAN>    bobsNiceManager.setManagerIsEvil( <SPAN STYLE="font-weight : bold;">false</SPAN> );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">13</FONT></SPAN>      <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">14</FONT></SPAN>    <SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//create and link up the Adapater</FONT></SPAN>    <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">15</FONT></SPAN>    EmployeeAdapter* empAdapter1 = <SPAN STYLE="font-weight : bold;">new</SPAN> EmployeeAdapter( &amp;bobsEvilManager );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">16</FONT></SPAN>    EmployeeAdapter* empAdapter2 = <SPAN STYLE="font-weight : bold;">new</SPAN> EmployeeAdapter( &amp;bobsNiceManager );  <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">17</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">18</FONT></SPAN>    empAdapter1-&gt;m_ageChangeCallback = (OnEmployeeEvent) Manager::onEmployeeGetsOlder;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">19</FONT></SPAN>    empAdapter2-&gt;m_ageChangeCallback = (OnEmployeeEvent) Manager::onEmployeeGetsOlder;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">20</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">21</FONT></SPAN>      <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">22</FONT></SPAN>    <SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//adds the empAdapter as a listner to the Employee bob</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">23</FONT></SPAN>    bob.addEmployeeListener( empAdapter1 );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">24</FONT></SPAN>    bobsEvilManager.addEventHandler( <FONT COLOR="RED">&quot;empAdapter1&quot;</FONT>, empAdapter1 );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">25</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">26</FONT></SPAN>    bob.addEmployeeListener( empAdapter2 );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">27</FONT></SPAN>    bobsNiceManager.addEventHandler( <FONT COLOR="RED">&quot;empAdapter2&quot;</FONT>, empAdapter2 );<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">28</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">29</FONT></SPAN>    <SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//now change bob's age</FONT></SPAN><FONT COLOR="BLUE"> </FONT>  <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">30</FONT></SPAN>    bob.setAge( <FONT COLOR="FUCHSIA">100</FONT> ); <SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//nothing happens yet... </FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">31</FONT></SPAN>      <BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">32</FONT></SPAN>    bob.setAge( <FONT COLOR="FUCHSIA">161</FONT> ); <SPAN STYLE="font-style : italic;"><FONT COLOR="BLUE">//oops ! bob gets fired :(</FONT></SPAN><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN><FONT COLOR="GRAY"><SPAN STYLE="font-weight : bold;">3</SPAN></FONT><BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN><FONT COLOR="GRAY"><SPAN STYLE="font-weight : bold;">4</SPAN></FONT>    <SPAN STYLE="font-weight : bold;">return</SPAN> <FONT COLOR="FUCHSIA">0</FONT>;<BR><SPAN
    STYLE="font-weight : bold;"><FONT COLOR="GRAY">3</FONT></SPAN><FONT COLOR="GRAY"><SPAN STYLE="font-weight : bold;">5</SPAN></FONT> }</PRE><P>
   In our example we create an Employee object named bob (line 4). We 
   also create two Manager objects, one called bobsEvilManager (line 8) 
   and the other called bobsNiceManager (line 9). On lines 15-16 we 
   create our two EmployeeAdapters for our two managers - note that we 
   create them using <SPAN STYLE="font-weight : bold;">new</SPAN>, 
   creating the object on the heap, whereas the other three objects were 
   created on the stack. We then set the adapters' m_ageChangeCallback 
   to point to the Manager::onEmployeeGetsOlder member function (lines 
   18-19). Next we add the adapters as listeners to the bob Employee 
   object (calling the addEmployeeListener() function) and add each 
   adapter to it's respective manager object, which in turn ensures that 
   the adapaters will get cleaned up when the Manager objects are destroyed.</P>
  <P>
   Now that we have everything hooked up lets walk through what will 
   happen as we change bob's age. The first change (line 6) doesn't 
   notify anyone yet because there are no listeners specified. The next 
   change (line 30) changes the age, and in turn, since two listeners 
   have been added, loops twice and calls the onAgeChange() method on 
   both the empAdapter1, and empAdapter2 adapters. These in turn verify 
   that their source and callback member variables are OK and call the 
   onEmployeeGetsOlder() method on each manager object the adapaters are 
   associated with. Both calls result in no action being taken since in 
   the case of the first Manager(bobsEvilManager) the age is less than 
   160, and in the case of the second (bobsNiceManager) the 
   m_evilManager member is set to false.</P>
  <P>
   On the next age change (line 32) the same things happen, except when 
   we get to the bobsEvilManager onEmployeeGetsOlder() call, we see that 
   the age is indeed greater than 160, and sadly the m_evilManager is 
   set to true, thus resulting in bob's premature termination. Naturally 
   this might lead us to want to implement some sort of method to tell 
   the Manager to take this job and..., but we'll leave that as an 
   exercise to the reader !</P>
  <P>
   And there you have it ! Events VCF style. Again, those of who have 
   worked with Java will recognize much of this, while those from a COM 
   background may recognize the design as being similar to COM's 
   ConnectionPoint architecture. </P>
  <P>
   Now let's move on to our next tutorial where we will begin to use 
   what we have learned to write a simple app that has a GUI using the VCF.
 <OBJECT
 CLASSID="clsid:ADB880A6-D8FF-11CF-9377-00AA003B7A11"
 ID="hhctrl"
    WIDTH="0"
    HEIGHT="0"
    BORDER="0"
    VSPACE="0"
    HSPACE="0" TYPE="application/x-oleobject">
 </OBJECT></BODY>
</HTML>