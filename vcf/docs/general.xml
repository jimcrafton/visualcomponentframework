<!--
Copyright (c) 2000-2003, Jim Crafton
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
	Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in 
	the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

NB: This software will not save the world.
-->
<chapter><title>General</title>
	<section><title>Features</title>
		<para>
		The VCF features an easy to use programming API and class hierarchy. Below
		 is a list briefly describing the key features in the framework.
		</para>
		<itemizedlist>
				<listitem><para>
				Modern C++ design - use of modern C++ techniques like exceptions, 
				templates (where useful), name spaces, and heavy use of the Standard 
				Template Library.
				</para></listitem>
				
				<listitem><para>
				Modular - built across several libraries as opposed to one huge 
				monolithic library that then becomes difficult to break apart. 
				This means that while the VCF is incredibly powerful as a framework 
				for writing GUI based applications, if you just want to use the 
				core features, such as threads, file IO, and RTTI you can do so, 
				without having dependencies on all the GUI code. 
				</para></listitem>
				
				<listitem><para>
				Support for Thread, Mutexes, Semaphores, Files, Streaming data, 
				error logging, string utility functions, and other basic services. 
				All of this is part of the FoundationKit and has no dependencies 
				on the graphics or UI code.
				</para></listitem>
				
				<listitem><para>
				Advanced RTTI features that allow for such things as dynamic object 
				creation given a registered class name or a registered UUID string 
				that represents the class, dynamic introspection of a given object's 
				class and listing such data as the class name, super class, the 
				properties of the class, member methods, and implemented interfaces.
				</para></listitem>
				
				<listitem><para>
				Memory leak detection in debug mode for catching VCF::Object derived 
				classes that have not been freed. This can be turned completely off 
				in debug by recompiling the libraries. 
				</para></listitem>
				
				<listitem><para>
				Easy to use and powerful event system, suitable for console as 
				well as GUI based applications. 
				</para></listitem>
				
				<listitem><para>
				Graphics classes for easily drawing on a graphics context, as well 
				as working with images. This includes easily manipulating things 
				like the current color, pen and brush attributes, and current 
				transformation matrix. 
				</para></listitem>
				
				<listitem><para>
				A simple image-loading architecture that allows multiple formats 
				to be registered for loading up a variety of different graphics 
				formats. On Win32 systems the default image loading support is 
				limited to BMP files, but by using the ImageFormats library 
				(also a part of the VCF) a wide variety of additional image types 
				are also supported. Currently the ImageFormats library uses 
				<ulink url="http://freeimage.sourceforge.net">FreeImage</ulink> 
				to support image types such as .TIFF, .TGA, .PSD, .PNG, .PCX, 
				.SGI, .MNG, .RAS, .PBM, .PPM, and many others. 
				</para></listitem>
				
				<listitem><para>
				More advanced classes for customizing the drawing process with 
				application defined behaviors. Advanced features also include 
				support for anti-aliased vector graphics through the use the 
				<ulink url="http://antigrain.com/">Anti Grain Graphics 
				libraries</ulink>.
				</para></listitem>
				
				<listitem><para>
				A complete set of powerful GUI classes, including a common set 
				of base classes enabling advanced custom control creation. Some 
				of the control classes include tree controls, list controls, check 
				box and radio controls, push buttons, single line and multi line 
				text controls, and many others. 
				</para></listitem>
				
				<listitem><para>
				A standard set of application classes for things like resources, 
				loading windows or forms dynamically at application startup, 
				saving of application state, a registry class for common storage 
				of system and application information.
				</para></listitem>
				
				<listitem><para>
				Other application classes include an Undo/Redo architecture based 
				on commands that allow for undoing and redoing commands as well 
				as notifying other objects of the events. 
				</para></listitem>
				
				<listitem><para>
				GUI controls that support both alignment and anchoring. Any control 
				may be aligned to the top, bottom, left or right of it's parent 
				container control.  Alternately controls may use their anchoring 
				properties to anchor themselves to the left, right, top and/or 
				bottom sides of their parent container control. 
				</para></listitem>
				
				<listitem><para>
				The GUI provides a set of Model and View classes for using in MVC 
				patterns. A series of models like the ListModel, TreeModel, and  
				TextModel are used in controls to provide separation of the data 
				from the UI presentation code. Because a View can be dynamically 
				attached to a Control at runtime, it will be possible to develop 
				"themes" in the future. 
				</para></listitem>
				
				<listitem><para>
				Because of the RTTI features and the event handlers, the VCF easily 
				supports component programming. Objects can easily register event 
				handlers with other objects in the system at runtime, without knowing 
				the specifics of each other.
				</para></listitem>
				
				<listitem><para>
				As much as possible, VCF tries to be as flexible as possible, allowing 
				you to use the parts you want, and allowing for interoperability with 
				other frameworks. Thus VCF controls can be used inside of an MFC app 
				if you like. 
				</para></listitem>
				
				<listitem><para>
				No need of special preprocessor tools - if you have a reasonably 
				complete C++ compiler then you're all set to go.
				</para></listitem>
				
				<listitem><para>
				Heavy use of the Standard Template Library throughout the VCF, as well 
				as templates, that make up the RTTI extensions the VCF implements.
				</para></listitem>
				
				<listitem><para>
				Ability to access the low level handles for most native objects. For 
				example, by accessing the Thread's peer class, you can get a handle 
				to the native thread handle itself. For a control, you can access 
				the control's peer and get a handle id that represents the windowing 
				systems native handle for a window/widget. This allows you to use 
				platform specific calls when neccessary.
				</para></listitem>					
		</itemizedlist>			
	</section>

	<section><title>Downloading the VCF</title>
		<para>The VCF can be downloaded from the project's Sourceforge.net 
		<ulink url="http://sourceforge.net/project/showfiles.php?group_id=6796">download site</ulink>. 
		Further details for your platform are given in the next section. 		
		</para>
	</section>

	<section><title>Required Tools</title>
		<para>
		These are the required tools if you want to build the VCF.
		</para>
		<para>
		The tools you need depend on the platform you plan to work on, in the 
		following list.
		</para>
		<itemizedlist>
			<listitem>
				<para>Win32</para>
				<para>
					For this platform the preferred compiler is currently the Microsoft 
					Visual C++ 6 compiler with Service Pack 5 applied. Microft Visual C++ 7 
					also works great, but some settings may be slightly different or found in 
					different places than described in the documentation.
				</para>
				<para>
					Currently, the supported compilers for the Win32 platform are:
					<itemizedlist>
						<listitem>
							Microsoft Visual C++ 6 (service pack 5 or better preferred).
						</listitem>
						<listitem>
							Microsoft Visual C++ 7.0.
						</listitem>
						<listitem>
							Microsoft Visual C++ 7.1.
						</listitem>
						<listitem>
							Microsoft Visual C++ 8.0 (Including the Express edition).
						</listitem>
						<listitem>
							Intels C/C++ compiler version 7 (using Visual Studio 6).
						</listitem>
						<listitem>
							Borland C++ 6
						</listitem>
						<listitem>
							MinGW-GCC compiler with the Code::Blocks IDE
						</listitem>						
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>MacOSX</para>
				<para>The MacOSX port currently uses the Apple Developer Tools that 
				come with OSX. The supported OS versions are:
				<itemizedlist>						
					<listitem>
						Mac OSX 10.3, using XCode 1.x.
					</listitem>
					<listitem>
						Mac OSX 10.4, using XCode 2.x.
					</listitem>
				</itemizedlist>
				Mac OSX 10.2 is currently not supported at the moment, and the Project
				Builder files should be ignored, since Project Builder support has 
				been dropped by Apple in favor of XCode.
				</para>
					
			</listitem>
			
			<listitem>
				<para>Linux</para>
				<para>
					The linux port requires the GCC toolchain be installed in order 
					to build the VCF from source. The VCF has been found to compile 
					with versions of GCC including 2.95, 3.1, 3.2, and the 
					3.3 release (3.3 is reccommended). In addition, the GraphicsKit 
					and ApplicationKit require the presence of GTK 2.x shared libraries 
					and headers and whatever dependencies that entails.
				</para>
			</listitem>			
		</itemizedlist>
	</section>

	<section><title>Installing the VCF</title>
		<section><title>For Win32 systems</title>
		<formalpara><title>Using the VCF Installer</title>
		You can install the VCF in a number of ways. The simplest way to install on a 
		"clean" system, is to simply download the VCF Installer from 
		<ulink url="http://sourceforge.net/project/showfiles.php?group_id=6796">Source Forge</ulink>, 
		save the appropriate file to your hard drive, run it, and Voila! you are ready to 
		rock and roll! 
		</formalpara>		
		<formalpara><title>Install from a source archive</title>
		The more complex way is to pull down the latest cvs tar.gz file (again, you can 
		get that from 
		<ulink url="http://sourceforge.net/project/showfiles.php?group_id=6796">Source Forge</ulink>) 
		and uncompress it somewhere on you hardrive. Once you have done this you'll need 
		to set up some environment variables, which are as follows: 
		</formalpara>
		<itemizedlist>
			<listitem><para>
				VCF_BIN : this should point to the bin under the root where you installed the 
				VCF. For example, on my machine it resolves to "d:\code\vcf\bin". 
			</para></listitem>
			<listitem><para>
				VCF_INCLUDE : this should point to the include directory under the same VCF 
				root mentioned earlier. Once again (as an example), on my machine this 
				resolves to "d:\code\vcf\src".
			</para></listitem>
			<listitem><para>
				VCF_LIB : this should point to the lib directory under the same VCF root 
				mentioned earlier. Once again (as an example), on my machine this resolves 
				to "d:\code\vcf\lib". 
			</para></listitem>
		</itemizedlist>
		<para>
		Once you have this done you can open up the projects in Microsoft Visual Studio and build 
		the various workspaces (.dsw files).
		</para>
		
		
		<formalpara><title>Install via CVS access</title>
		The most "advanced" way is to connect to cvs and pull down either the latest stable 
		version or the latest development version. There are instructions on SourceForge 
		detailing <ulink url="http://sourceforge.net/cvs/?group_id=6796">how to do this</ulink>. 
		<note><title>Anonymous vs. developer cvs access</title>
			<para>
			if you download the VCF via anonymous CVS access, and then, realizing it is the 
			greatest thing since sliced bread and toasted crumpets, you decide to join the 
			project (hint, hint), you will need to either delete the directory where you 
			currently have the VCF, or pull it down with cvs to a different directory.
			</para>
			<para>
			The problem that arises is that you will be unable to check-in anything, despite 
			having joined the project and received write access to the cvs repository. I 
			think this is because cvs thinks you are still "anonymous" and you have no write 
			access for an anonymous user. 
			</para>
		</note>
		</formalpara>
		<para>
		Once you have pulled down the code with cvs repeat the steps above for environment 
		variables.
		</para>
		</section>
		<section><title>For Mac OSX systems</title>
		<para>
		Currently you need to connect to cvs and pull down either the latest 
		stable version or the latest development version. There are instructions on 
		SourceForge detailing <ulink url="http://sourceforge.net/cvs/?group_id=6796">
		how to do this</ulink>. 		
		</para>
		</section>
		<section><title>For Linux systems</title>
		Pull down the latest tar.gz source file and unzip in the directory of you choice.
		</section>
		
		<section><title>Third Party Libraries</title>
		<para>
		In general you don't need to worry about installing any third party libraries,
		as the VCF comes with all the code you need, including third party libraries 
		that it makes use of. However, this section will discuss those third party libraries
		that, due perhaps to the size of the library, are not included in the main VCF
		code base.
		</para>
		<section><title>Open SSL on Win32</title>
		  <para>
		  Currently this is NOT needed! Please ignore these instructions for now.
		  </para>
		  <para>
		  You can get the latest version of SSL from 
		  http://www.openssl.org/source/, and the most recent version is currently 
		  openssl-0.9.7b, but this will obviously change over time.
		  </para>
		  <para>
		  OpenSSL does not use VC workspaces or project files, and unless you want to
		  find some existing binary installer, you'll need to install it from source.
		  To do this you'll need perl installed on your system, as the OpenSSL build scripts
		  make use of perl to do their work. If you have a version of perl as a result 
		  of an existing cygwin installation, do <emphasis>not</emphasis> use this version
		  unless you plan to completely build from the cygwin prompt and create a GCC
		  based version of the library. These instructions are for building a version of 
		  the library using Microsoft's VC++.
		  </para>
		  <para>
		  With that in mind, get the latest perl from ActiveState at 
		  http://www.activestate.com/Products/ActivePerl/. They have an excellent
		  installer that will install Perl in a jiffy with no hassle.
		  </para>
		  <para>
		  OpenSSL has some parts of the library that are coded using optimized assembler,
		  but to make use of this, you'll need Microsoft's MASM tool installed. This may 
		  or may not already be on your machine, look for an executable called "ml.exe"
		  in the "bin" directory of the main VC++ directory. If this is not there, you can
		  download it here:
		  http://msdn.microsoft.com/vstudio/downloads/tools/ppack/default.aspx
		  for free. If that link is not working, you may be able to find more information 
		  here http://users.easystreet.com/jkirwan/new/pctools.html that provides links
		  to versions of MASM. Please note that you do <emphasis>not</emphasis> have to
		  get MASM, you can build OpenSLL just without it, but the performance may be slightly
		  slower than if you used the assembly version of the some of the routines.
		  </para>
		  <para>
		  Once you have your tools installed, open a command prompt, and navigate to the 
		  bin directory fo your version of VC++. For example, if you installed to the default
		  location and you're using VC6, then this would be 
		  "C:\Program Files\Visual Studio\VC98\Bin". For Visual C++ 7.1, it might be
		  "C:\Program Files\Microsoft Visual Studio .NET 2003\Vc7\bin" and so forth. Once 
		  there run the the vcvars32.bat file to initialize your path to point to the
		  right place for the compiler, linker, etc tools.
		  </para>
		  <para>
		  In the same shell, cd to the directory that you installed OpenSSL to, for example
		  "c:\openssl-0.9.8a\". Now configure it for VC++ by typing:
		  <programlisting>
		  <![CDATA[
perl Configure VC-WIN32
		  ]]>
		  </programlisting>
		  You should see something like this when its done:
		  <programlisting>
		  <![CDATA[
Configuring for VC-WIN32
    no-gmp          [default]  OPENSSL_NO_GMP (skip dir)
    no-krb5         [krb5-flavor not specified] OPENSSL_NO_KRB5
    no-mdc2         [default]  OPENSSL_NO_MDC2 (skip dir)
    no-rc5          [default]  OPENSSL_NO_RC5 (skip dir)
    no-shared       [default]
    no-zlib         [default]
    no-zlib-dynamic [default]
IsMK1MF=1
CC            =cl
CFLAG         =-DOPENSSL_THREADS  -DDSO_WIN32
EX_LIBS       =
CPUID_OBJ     =
BN_ASM        =bn_asm.o
DES_ENC       =des_enc.o fcrypt_b.o
AES_ASM_OBJ   =aes_core.o aes_cbc.o
BF_ENC        =bf_enc.o
CAST_ENC      =c_enc.o
RC4_ENC       =rc4_enc.o
RC5_ENC       =rc5_enc.o
MD5_OBJ_ASM   =
SHA1_OBJ_ASM  =
RMD160_OBJ_ASM=
PROCESSOR     =
RANLIB        =true
ARFLAGS       =
PERL          =perl
THIRTY_TWO_BIT mode
BN_LLONG mode
RC4_INDEX mode
RC4_CHUNK is undefined

Configured for VC-WIN32.
			]]>
		  </programlisting>
		  At this point you can choose to either build the ASM files or not. If you have MASM, then 
		  type:
		  <programlisting>
ms\do_masm
		  </programlisting>
		  If you don't have MASM, then simply type:
		  <programlisting>
ms\do_ms
		  </programlisting>
		  The MASM version should generate something like this:
		  <programlisting>
		  <![CDATA[
Generating x86 for MASM assember
Bignum
DES
"crypt(3)"
Blowfish
CAST5
RC4
MD5
SHA1
RIPEMD160
RC5\32

C:\openssl-0.9.8a>perl util\mkfiles.pl  1>MINFO

C:\openssl-0.9.8a>perl util\mk1mf.pl VC-WIN32  1>ms\nt.mak

C:\openssl-0.9.8a>perl util\mk1mf.pl dll VC-WIN32  1>ms\ntdll.mak

C:\openssl-0.9.8a>perl util\mkdef.pl 32 libeay  1>ms\libeay32.def

C:\openssl-0.9.8a>perl util\mkdef.pl 32 ssleay  1>ms\ssleay32.def		  
]]>
		  </programlisting>
		  You're now ready to start the actual makefile based build process. You 
		  can choose to build a static or DLL version of the libraries. For a 
		  static build (i.e. a build that you'll statically link to) you'll
		  use the ms\nt.mak file, and for a DLL build you'll use the ms\ntdll.mak
		  file.
		  </para>
		  <para>
		  To begin a static lib build, type:
		  <programlisting>
nmake -f ms\nt.mak
		  </programlisting>
		  You should see a whole bunch of output stream by. You'll find the final 
		  binaries in .\out32\. Repeat the above step with the DLL Makefile for 
		  building the DLL version of the library. If you do this, the DLL
		  binaries will be in .\out32dll\.
		  </para>
		  <para>
		  To make use of the library you'll need to link to it. The libraries
		  are obviously in the out32 directory, and the include files are in 
		  the .\inc32\ directory.
		  </para>
		  <para>
		  If you want to build for a different version of VC++ make
		  <emphasis>sure</emphasis> to clean the old object code/binaries out
		  first! Otherwise you'll get all sorts of compiler errors
		  </para>
		</section>
		</section>
	</section>

	<section><title>Building the VCF</title>
		<para>
		Building the VCF is easy. This assumes that you have downloaded it and, if necessary, 
		set up any environment variables. The following sections will discuss building the 
		VCF on specific platforms.
		</para>
		<section><title>VCF Tools</title>
			<section><title>Microsoft Visual C++ 6</title>				
				<para>
				The first thing you'll want to do is build the various add-ins for 
				Developer Studio. Open the main workspace found in vcf/build/vc60/add-ins/all.dsw. 
				Build the "Win32 Release" configuration, making sure that the "all" 
				project is the current active project. This should build the 
				VCF New Class add-in, plus project wizards VCFLibraryAppWizard, 
				VPLAppWiz, VCFConsoleWiz, and VCFAppWiz. To verify that these were 
				correctly built go to "File | New..." and click on the "Projects" 
				tab and you should see something like the following:
				</para>
				<screenshot>
					<graphic fileref="gfx/addins_verify.png"></graphic>
				</screenshot>
				<para>
				The red circle indicates the various new Application Wizards that you should see.
				</para>
			</section>		
			<section><title>Microsoft Visual C++ 7/7.1</title>				
				<para>
				The first thing you'll want to do is install the various wizards for 
				Developer Studio. To install, navigate to the directory	vcf/build/vc70/add-ins (for 
				Visual Studio.NET) OR vcf/build/vc71/add-ins (for Visual Studio.NET2003), and run 
				(double click) Setup.js.  This will install the	various wizards for use in the IDE. 
				To verify that these were installed correctly,	go to "File | New | Projects" and 
				click on the "Visual C++ Projects" directory icon and you should see something like 
				the	following:
				</para>				
				<screenshot>
					<graphic fileref="gfx/addins_vc71_verify.png"></graphic>
				</screenshot>
				<para>
				The red circle indicates the various new Application Wizards that you should see.
				</para>
			</section>
			
			<section><title>Microsoft Visual C++ 2005 8.0 (including Express edition)</title>				
				<para>
				Till Novemeber of 2006 Microsoft is giving away it's Express edition of 
				Visual C++ 2005. This is a superb IDE for the Windows environment, and I'd 
				urge anyone on a budget to look into it. While it does not come with either
				ATL or MFC support this is OK, because the VCF gives you everything you'll
				need for GUI development on Windows, and VC 2005 gives you a great IDE! 
				The following section will address how to get it, and how to set it up
				for Windows GUI development, as there are a few special files you need 
				to adjust by hand.
				</para>
				<para>
					You can currently download the Visual C++ Express edition from the 
					<ulink url="http://msdn.microsoft.com/vstudio/express/visualc/download/">
						Visual C++ Express Edition Download site
					</ulink>.
					Follow the instructions there to install the software. Once VC 2005 is 
					installed you will need to install a recent version of the <ulink 
						url="http://www.microsoft.com/downloads/details.aspx?FamilyId=A55B6B43-E24F-4EA3-A93E-40C0EC4F68E5&amp;displaylang=en"> 
					Win32 Platform SDK</ulink>. Older versions as far back as the November 2001
					SDK work just fine if you have an older copy and don't want or need the 
					absolute latest and greatest from Microsoft.					
				</para>
				<para>
					Once you've installed the SDK, you need to adjust your settings in VC 2005
					to reflect this, so it knows to use the SDK files. You <emphasis>must</emphasis>
					follow these instructions, or things will not work correctly. You can read them at
					<ulink url="http://msdn.microsoft.com/vstudio/express/visualc/usingpsdk/">Using 
					Visual C++ 2005 Express Edition with the Microsoft Platform SDK</ulink>. In case
					this link ever goes away or changes I'll summarize below:
					<itemizedlist>
						<listitem>
							Go to Tools > Options. Select the "VC++ Directories" section under
							"Projects and Solutions". In the "Show Directories for" drop down,
							select the following:
							<itemizedlist>
								<listitem>
									For "Executable files", add the [Path to SDK]\Bin directory.
								</listitem>
								<listitem>
									For "Include files", add the [Path to SDK]\Include directory.
								</listitem>
								<listitem>
									For "Library files", add the [Path to SDK]\Lib directory.
								</listitem>
							</itemizedlist>	
							These probably need to be the first items, but it seems to work OK if 
							they are not. Older version of VC++ required the SDK files to be included
							first, but VC2005 doesn't seem as picky.
						</listitem>
						<listitem>
							Find the file "corewin_express.vsprops". This should be in a directory
							like "C:\Program Files\Microsoft Visual Studio 8\VC\VCProjectDefaults",
							or wherever you installed VC 2005 to. Edit this file so that
							<programlisting>
AdditionalDependencies="kernel32.lib"
							</programlisting>
							becomes 
							<programlisting>
AdditionalDependencies="kernel32.lib user32.lib gdi32.lib winspool.lib 
comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib"
							</programlisting>
						</listitem>
						<listitem>
							Edit the "AppSettings.htm" file. You should be able to find this
							in a directory like this "C:\Program Files\Microsoft Visual Studio 8\
							VC\VCWizards\AppWiz\Generic\Application\html\1033\". Comment out lines 
							441-444. 
						</listitem>	
					</itemizedlist>
					I'd like to thank Brian Johnson for writing the original instructions explaining
					how to do this.
				</para>
				<para>
				Once Yo uhave VC 2005, the first thing you'll want to do is install the various 
				wizards for it. To install them, navigate to the directory	vcf/build/vc80/add-ins 
				and run (double click) Setup-vcexpress.js.  This will install the	various wizards 
				for use in the Express IDE. To verify that these were installed correctly,	go to 
				"File | New | Projects" and click on the "Visual C++ Projects" directory icon and 
				you should see something like the following:
				<screenshot>
					<graphic fileref="gfx/addins_vc80_verify.png"></graphic>
				</screenshot>
				</para>
			</section>
			
			
			
			<section><title>Apple XCode 1.x</title>
				<para>
				This will explain how to install the project templates that come 
				with the VCF so	that you can create VCF enabled applications easily 
				from within XCode.
				</para>
				<para>
				Create a "VCF" directory in your 
				/Library/Application Support/Apple/Developer Tools/Project Templates/ 
				directory. Then copy all the directories in the 
				vcf/build/xcode/Project Templates/ directory to the new VCF directory 
				you created. Yous should end up with something like this:
				<graphic fileref="gfx/vcf-xcode-templates.png"></graphic>
				
				Now when you select the "File > New Project..." menu item in XCode, 
				you should see the new project templates in the New Project dialog:
				<graphic fileref="gfx/vcf-xcode-proj-templates.png"></graphic>
				</para>
			</section>
			<section>
				<title>Apple XCode 2.x</title>
				<para>
					Use the same instructions for XCode 1.x.
				</para>				
			</section>
		</section>		
		<section><title>Building the VCF Libraries</title>
			<section><title>Win32</title>
				<section><title>Microsoft Visual C++ 6</title>
					<para>
						The following section deals with building the VCF libraries using the Microsoft
						Visual C++ 6 IDE.
					</para>
					<para>
						To build the VCF open the vcf/build/vc60/vcfAllProjects.dsw workspace.
						This workspace has all the various framework projects, both as
						static .lib files and DLL projects. To build all the VCF libraries select
						the "vcfAllLibs" project and make it the active project. Building this
						project will automatically build the FoundationKit, GraphicsKit,
						ApplicationKit, NetworkKit, and RemoteObjectKit. The libraries
						will be built as both static <emphasis>and</emphasis> DLL binaries. To build
						just the static libraries, build the "vcfAllStaticLibs" project. To
						build all the libraries as DLL's, build the "vcfAllDynamicLibs" project.
					</para>
					<para>
						There are several additional projects you can build as well for additional
						features.
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<para>
									The ImageFormats project, which adds support for a wide variety of
									image formats by using the <ulink url="http://freeimage.sourceforge.net/">
										FreeImage
										library
									</ulink>. Build this if you would like to add this support to your
									project.
								</para>
							</para>
						</listitem>
						<listitem>
							<para>
								<para>
									The Win32HTMLBrowser (and Win32HTMLBrowser_StaticLib) project, for an
									HTML browser peer (currently implemented using the Internet Explorer
									IWebBrowser COM interface, though experiments have been done
									using the Gecko component from mozilla).
								</para>
							</para>
						</listitem>
					</itemizedlist>
					<para>
						The build will take a bit, so now would be a good time for coffee, tea, or
						perhaps reading some Dostoevsky...
					</para>
					<para>
						Once the build is finished you are ready to go ! All binaries will be put
						in the vcf/bin directory when built.
					</para>
				</section>
				<section><title>Microsoft Visual C++ 7.0</title>
					<para>
						The following section deals with building the VCF libraries using the Microsoft
						Visual C++ 7.0 IDE.
					</para>
					<para>
				To build the VCF open the vcf/build/vc70/vcfAllProjects_vc70.dsw workspace. 
				This workspace has all the various framework projects, both as 
				static .lib files and DLL projects. Visual Studio should prompt
				you to convert the Visual C++ 6 projects into the new Visual Studio 7 
				format. Click the "Yes to All" option, and all the projects should then
				get converted. To build all the VCF libraries select 
				the "vcfAllLibs" project and make it the active project. Building this 
				project will automatically build the FoundationKit, GraphicsKit, 
				ApplicationKit, NetworkKit, and RemoteObjectKit. The libraries
				will be built as both static <emphasis>and</emphasis> DLL binaries. 
				To build just the static libraries, build the "vcfAllStaticLibs" 
				project. To build all the libraries as DLL's, build the 
				"vcfAllDynamicLibs" project.				
				</para>
				</section>

				<section><title>Microsoft Visual C++ 7.1</title>
					<para>
						The following section deals with building the VCF libraries using the Microsoft
						Visual C++ 7.1 IDE.
					</para>			
				<para>
				To build the VCF open the vcf/build/vc71/vcfAllProjects_vc71.dsw workspace. 
				This workspace has all the various framework projects, both as 
				static .lib files and DLL projects. Visual Studio should prompt
				you to convert the Visual C++ 6 projects into the new Visual Studio 7.1 
				format. Click the "Yes to All" option, and all the projects should then 
				get converted. 
				<graphic fileref="gfx/vc71-open.png"></graphic>
				</para>
				
				<para>
				To build all the VCF libraries select the "vcfAllLibs" project and make 
				it the active project. 
				<graphic fileref="gfx/vc71-build-all.png"></graphic>
				Building this project will automatically build the FoundationKit, GraphicsKit, 
				ApplicationKit, NetworkKit, and RemoteObjectKit. The libraries
				will be built as both static <emphasis>and</emphasis> DLL binaries. To build
				just the static libraries, build the "vcfAllStaticLibs" project. To
				build all the libraries as DLL's, build the "vcfAllDynamicLibs" project. 
				After having built the VCF for the first time, you can
				typically open the vcf/build/vc71/vcfAllProjects_vc71.sln solution file 
				instead of the workspace file should you decide to rebuild any of the projects at 
				a later time.			
				</para>
				</section>

				<section><title>Microsoft Visual C++ 2005 8.0</title>
					<para>
						The following section deals with building the VCF libraries using the Microsoft
						Visual C++ 2005 (including the Express Edition) IDE.
					</para>				
				<para>
					To build the VCF open the vcf/build/vc80/vcfAllProjects_vc80.sln workspace.
					This workspace has all the various framework projects, both as
					static .lib files and DLL projects. Visual Studio should prompt
					you to convert the Visual C++ 6 projects into the new Visual Studio 7.1
					format. Click the "Yes to All" option, and all the projects should then
					get converted.
					<graphic fileref="gfx/vc80-open.png"></graphic>
				</para>

				<para>
					To build all the VCF libraries open the vcf/build/vc80/vcfAllLibs.sln
					solution file, select the "vcfAllLibs" project, and make it the active project.
					<graphic fileref="gfx/vc80-build-all.png"></graphic>
					Building this project will automatically build the FoundationKit, GraphicsKit,
					ApplicationKit, NetworkKit, and RemoteObjectKit. The libraries
					will be built as both static <emphasis>and</emphasis> DLL binaries. To build
					just the static libraries, build the "vcfAllStaticLibs" project. To
					build all the libraries as DLL's, build the "vcfAllDynamicLibs" project.				
				</para>
				</section>
				<section><title>Microsoft Visual C++ 6 using the Intel C/C++ compiler</title>
					<para>
						The following section deals with building the VCF libraries using the Microsoft
						Visual C++ 7.0 IDE with the Intel C/C++ compiler installed.
					</para>				
				<para>
				To build the VCF open the vcf/build/icl7/vcfAllProjects_icl7.dsw workspace. 
				This workspace has all the various framework projects, both as 
				static .lib files and DLL projects. To build all the VCF libraries select 
				the "vcfAllLibs" project and make it the active project. Building this 
				project will automatically build the FoundationKit, GraphicsKit, 
				ApplicationKit, NetworkKit, and RemoteObjectKit. The libraries
				will be built as both static <emphasis>and</emphasis> DLL binaries. To build
				just the static libraries, build the "vcfAllStaticLibs" project. To
				build all the libraries as DLL's, build the "vcfAllDynamicLibs" project.
				</para>
				</section>

				<section>
					<title>Borland C++ Compiler</title>
					<para>
						The following section deals with building the VCF libraries using Borland's
						C++ compiler/linker. This includes the free commandline version.
						<note>
							Due to restrictions on the free commandline compiler, there is no support
							for the HTMLBrowser control due to dependencies on Microsoft's ATL
							library. This is being addressed so that in the near future this will
							no longer be an issue.
						</note>
						For more information regarding the build instructions for Borland compilers,
						see the notes in the readme.txt file in vcf/build/bcc/readme.txt.
					</para>				
				<para>
				There are some missing libs that did not get distributed with the Borland 
				compiler install. These are found in the vcf/build/bcc/missing_libs directory.
				Copy them either to your &lt;PATH_TO_BCB_INST&gt;\Lib directory  or the vcf/lib 
				directory.
				</para>
				<para>
				Make sure that the bcc32.cfg file is correctly set up. You should have some 
				thing like this (assuming you have installed you compiler in "c:\bcb6", if 
				not replace as neccessary):
				<programlisting>
				<![CDATA[
-I"C:\bcb6\Include";"C:\bcb6\Include\vcl";"C:\bcb6\Include\Atl"
-L"C:\bcb6\lib\PSDK";"C:\bcb6\lib";"C:\bcb6\lib\obj";"C:\bcb6\lib\release"
]]>
				</programlisting>
				The order of the folders is important. Especially for linker folders. So 
				copy them as shown here.
				</para>
				For the Borland Free compiler the bcc32.cfg file should look like this:
				<programlisting>
				<![CDATA[
-I"C:\Borland\BCC55\Include"
-L"C:\Borland\BCC55\lib\PSDK";"C:\Borland\BCC55\lib"
]]>
				</programlisting>
				Of course replace the "C:\bcb6\" or "C:\Borland\BCC55" part with the 
				appropriate path where you installed the Borland Free compiler.
				<para>
				Make sure you setup environment variables for VCF_BIN, VCF_INCLUDE 
				and VCF_LIB. Without that you can not build and use them. See "Installing 
				the VCF" for more information about how to do this.
				</para>
				<para>
				Once this is done, you're ready to start issuing make commands. Open 
				up a command prompt and and issue a make command like so:
				<programlisting>
<![CDATA[
cd <PATH_TO_VCF>\build\bcc
make -fvcfAllLibs.mak
]]>
				</programlisting>
				This will build all dynamic and static libs. If for some reason name of your 
				make util is not make.exe open vcfAllLibs.mak and change MK variable to 
				the name of your make util. Do the same thing in vcfAllDynStatLibs.mak.
				</para>
				<para>
				It's possible to build specific libraries if you don't want (or need) to build everything. 
				To build more specific library or set of libraries you have these options:
				<itemizedlist>
					<listitem><para>		
					All static libraries (both debug and release)
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs
]]>
					</screen>
					</para></listitem>
					
					
					
					<listitem><para>
					All dynamic libraries (both debug and release)	
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs
]]>
					</screen>					
					</para></listitem>
					
					<listitem><para>
					All static release libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs_rel
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All static debug libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs_dbg
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All dynamic debug libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs_dbg
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All dynamic release libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs_rel
]]>
					</screen>
					</para></listitem>
				</itemizedlist>
				To delete the binaries created during the build process you can use the following commands:
				<itemizedlist>
					<listitem><para>	
					All libraries (both debug and release and both static and dynamic)
					<screen>
<![CDATA[
make -fvcfAllLibs.mak clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All static libraries (both debug and release)
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs_clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All dynamic libraries (both debug and release)
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs_clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All static release libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs_rel_clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All static debug libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak static_libs_dbg_clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All dynamic debug libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs_dbg_clean
]]>
					</screen>
					</para></listitem>
					
					<listitem><para>
					All dynamic release libraries
					<screen>
<![CDATA[
make -fvcfAllLibs.mak dynamic_libs_rel_clean
]]>
					</screen>
					</para></listitem>
				</itemizedlist>
				
				<note>
				If you are building with the Borland Free compiler issue the same commands 
				stated above but add this : -DFREECOMP=TRUE. For example:
				<screen>
<![CDATA[
make -fvcfAllLibs.mak -DFREECOMP=TRUE make -fvcfAllLibs.mak static_libs 
-DFREECOMP=TRUE
]]>
				</screen>
				This way we avoid dependency on ATL and make complete library 
				available to user except WebBrowser control. If you just wan't to build 
				everything there is a batch file free_compiler.cmd. Execute it and wait a bit :).
				</note>
				
				</para>				
				
				<para>
				Most of the examples can be compiled with Borland compiler. All that fall
				in this category have 2 options for building.
				<itemizedlist>
					<listitem>
					build_bcc.bat . With this batch file you can quickly build any sample. 
					It expects that you have already built the release dll version of the VCF libs.
					</listitem>
					<listitem>					
					You have allso 2 project files for BCB 5 IDE. One is for release dll VCF and 
					another is for debug dll VCF. 
					</listitem>
				</itemizedlist>
				</para>
				<para>
				To use the Borland IDE project files you need to create a subfolder lib_patch
				in your CBuilder root folder. In there copy c0x32.obj from &lt;CBuilder root&gt;\Lib 
				folder and rename it to c0w32.obj. Here is a more detailed explanation why this 
				was needed (from the VCF forum):
				<blockquote>				
					<para>
					After quite some time I managed to create set of IDE project files for building 
					VCF examples in BCB 5. Examples excluded in this release are:
					<itemizedlist>
					<listitem>
					QTPlayer - This example uses QuickTime SDK that only works with visual C++.
					All lib files and headers are only MSVC compatibile. If somebody 
					makes a port of this to BCB than this sample could be ported.
					</listitem>				
					
					<listitem>
					TexLabel - Can not be compiled with BCB 5. Works only with BCB 6.
					</listitem>
					</itemizedlist>
					</para>
					<para>
					Here is one important note about building these samples.
					</para>
					<para>
					Unfortunately in BCB project file it is not possible to specify custom startup object file. 
					That is necessary with VCF because every example has main procedure. Unfortunately 
					BCB project with windows application forces linkage of c0w32.obj that is startup file 
					that requires winmain procedure. What we need instead is c0x32.obj - startup file that 
					uses main procedure.
					</para>
					<para>
					The only way I found to trick BCB to use different object file than standard was to 
					create new folder in BCB root folder and copy there c0x32.obj and rename it to 
					c0w32.obj. After that every IDE project file must have this folder placed first in a 
					list of folders with lib files (Project\Options\Directories/Conditionals - line "Library 
					path").
					</para>
					<para>
					All example project files assume that path of this folder is $(BCB)\lib_patch.
					</para>
				</blockquote>
				</para>
				<para>
				So create folder lib_patch in the root of BCB installation and copy/rename mentioned 
				startup object file. This trick is needed only for windows applications. For console 
				applications it is enough to create standard console project in BCB.
				</para>
				<para>
				In every folder for an example there are two project files - &lt;projectname&gt;_bcb5.bpr 
				and &lt;projectname&gt;_bcb5_d.bpr . The first one is for a release build and 
				the other is for a debug build. In the &lt;VCFROOT&gt;\Examples folder there are 
				project group files Examples_bcb5.bpg (release projects) and Examples_bcb5_debug.bpg 
				(debug projects).
				</para>
				</section>
				
				<section><title>MinGW-GCC compiler with the Code::Blocks IDE</title>
					<para>
						This section describes building the VCF + examples in the Code::Blocks IDE (
						<ulink url="http://www.codeblocks.org/">codeblocks.org</ulink>). The VCF has 
						only been tested with the more recent "Nightly Build" versions of the C::B IDE 
						(download info at their forum page at 
						<ulink url="http://forums.codeblocks.org/index.php">forums.codeblocks.org</ulink>). 
						While version 1.0 RC2 might work, we have had troubles with precompiled header 
						support, and strongly recommend the current	Nightly Builds or newer.  See instruction 
						at the C::B site for using their IDE. The VCF codeblocks projects are known to work 
						versions 3.4.4 and 3.4.5 of the MinGW-GCC compiler. The VCF projects will not work with 3.4.2 or older.
					</para>				
				<para>There are several different Code::Blocks (C::B) workspaces you can use to build the 
				VCF, depending on whether you want to build dynamic libraries, static libraries, or both. 
				Building example VCF apps is also covered. These workspaces are found in the 
				vcf\build\codeblocks directory.
				<itemizedlist>
					<listitem><para>
					Dynamic and static libraries + example VCF applications: open vcfAllProjects.workspace 
					</para></listitem>
					<listitem><para>
					Dynamic libraries only: open vcfAllDynamicLibs.workspace
					</para></listitem>
					<listitem><para>
					Static libraries only: open vcfAllStaticLibs.workspace
					</para></listitem>
					<listitem><para>
					Dynamic and static libraries only: open vcfAllLibs.workspace
					</para></listitem>
					<listitem><para>
					Example VCF applications only: open vcfAllExamples.workspace . Note that you need to 
					build the dynamic libraries before building these examples.
					</para></listitem>
				</itemizedlist>
				</para>
				<para>
				Open the workspace of your choice in the C::B IDE. Available targets include "mingw_Release", 
				"mingw_Debug", or "All" for both Release and Debug versions. Select the targer of your choice 
				(or use the default target of All), make sure that the IDE is set to use the "GCC Compiler" 
				compiler, and choose "Build->Build workspace" to build the libraries (+/- examples). The dynamic 
				libraries (dll's) are placed in vcf\bin, and the dll import libraries and static libraries are placed in 
				vcf\lib. All library names will have the suffix "_mgcc" added to their names to indicate they were built with 
				the MinGW-GCC toolchain. 
				</para>	
				<para>
				Building your own apps: The C::B IDE does not provide a great mechanism/wizard for creating an app skeleton, 
				though it does provide a nice generic template mechanism. To start building your own VCF apps, we recommend 
				opening one of the VCF example projects (such as HellowWorld), and saving it as a new project. This will give 
				you an application outline with compiler options set up correctly, and you can add and remove your source files 
				to the project as desired. You can also save an example project using "Project->Save project as user-template" 
				and then create new projects from that template. This works well, but in both of these cases you have to change 
				the name of the output binary through Project->Properties to your application output name.
				</para>
				</section>
			</section>
			
			<section><title>Building with Bakefiles</title>
				<section><title>The Bakefile utility</title>
				<para>
				Bakefile is a command line tool, so you should feel comfortable
				using a command line to use this tool. Please download and install 
				the latest version of the Bakefile from its site 
				<ulink url="http://bakefile.sf.net">bakefile.sf.net</ulink>.
				</para>
				</section>
				<section><title>Patching of the Bakefile utility</title>
				<para>
				There are some issues with Bakefiles that were not resolved
				by authors of Bakefile till now for some reason. So you may
				need to fix your local Bakefile executable yourself with a patch 
				that can be downloaded separately.
				</para>
				</section>
				<section><title>Environment Variables</title>
				<para>
				What you need to do at the beginning is to set up the VCF_ROOT 
				environment variable. It should point to the root of VCF.
				</para>
				<para>
				If you are going to use MS VS IDE and prefer to generate VS6
				projects then you need to update the IDE's LIB, INCLUDE and PATH
				variables (executable directories) with directories appropriate to 
				the VCF.
				</para>

				<para>
				We will use a Windows specific syntax of the command line in
				examples below. This does not prevent you from using a Unix
				specific syntax. For example, we will use %VCF_ROOT%, but you can
				use $VCF_ROOT instead, if you're attempting this from a unix like
				command line.
				</para>
				</section>
				<section><title>Baked Make Files</title>
				<para>
				The ready-to-use make files are located at the %VCF_ROOT%\build\bakefiles.gen 
				directory. The directory contains several make files for different compilers 
				that can be used from a command line.
				</para>
				<para>
				To build the whole VCF you need exactly one of the following make files:
				<itemizedlist>
					<listitem>
					GNUmakefile - GNU make + GCC
					</listitem>
					<listitem>
					makefile.bcc - Borland make + BCC
					</listitem>					
					<listitem>
					makefile.gcc - MinGW mingw32-make + GCC
					</listitem>
					<listitem>
					makefile.vc - MS nmake + MSVC
					</listitem>
				</itemizedlist>
				</para>
				<para>
				So, to compile VCF you just need to make the %VCF_ROOT%\build\bakefiles.gen 
				directory current and run one of the following commands:
				<itemizedlist>
					<listitem>
					GNU make
					<screen>
make -f GNUmakefile
					</screen>
					</listitem>
					
					<listitem>
					Borland make
					<screen>
make -f makefile.bcc
					</screen>
					</listitem>
					
					<listitem>
					MinGW make
					<screen>
mingw32-make -f makefile.gcc
					</screen>
					</listitem>
					
					<listitem>
					MS nmake
					<screen>
nmake -f makefile.vc
					</screen>

					</listitem>
				</itemizedlist>
				</para>
				<para>
				Each make file has its own config file with the same extension. There 
				is an exception: GNUmakefile's config file is config.gnu. The config 
				files are located in the same directory.
				</para>
				<para>
				You can tune your build by modifying options in an appropriate config 
				file. There dependencies between some options are mentioned in a config 
				file. Here are brief descriptions of the options. The most option 
				values may be equal to 1 or 0 only that means on/yes/true or 
				off/no/false.
				<itemizedlist>
					<listitem>
					OPTION_SHARED - The result libraries will be static or dynamic. 
					Default: 1.
					</listitem>
					
					<listitem>
					OPTION_DEBUG - The libraries will include debug info or will be 
					optimized for speed. Default: 1.
					</listitem>
					
					<listitem>
					OPTION_PRECOMPILED - Precompiled header files will be created 
					and used where it is possible.
					</listitem>
					
					<listitem>
					OPTION_ALLIN1 - All VCF as a single library, static or dynamic 
					depends on OPTION_SHARED. Default: 0.
					</listitem>					
				</itemizedlist>
				</para>
				<para>
				The following options show should the appropriate static or dynamic 
				libraries be built. Note, if OPTION_ALLIN1 is 1, that is, all the 
				enabled kits will be linked as a single library, and all the following 
				options that are equal to 0 will not be included into the result 
				library.
				</para>
				<para>
				The following options are assigned to libraries that can be built 
				as static ones only.
				<itemizedlist>
					<listitem>	
					OPTION_ZLIB - Compile the zip? Default: 1.					
					</listitem>
					
					<listitem>
					OPTION_AGG - Compile AGG? Default: 1.
					</listitem>
					
					<listitem>
					OPTION_LIBJPEG - Compile AGG? Default: 1.
					</listitem>
					
					<listitem>
					OPTION_LIBPNG - Compile PNG? Default: 1.
					</listitem>
					
					<listitem>
					OPTION_LIBMNG - Compile MNG? Default: 0.
					</listitem>
					
					<listitem>
					OPTION_LIBTIFF - Compile TIFF? Default: 0.
					</listitem>
					
					<listitem>
					OPTION_FREEIMAGE - Compile FreeImage? Default: 0.
					</listitem>
					
					<listitem>
					OPTION_REGEXX - Compile PCRE? Default: 0.
					</listitem>
				</itemizedlist>	
				</para>
				<para>
				The following options are assigned to libraries that can be 
				built as both static and dynamic ones.
				<itemizedlist>	
					<listitem>
					OPTION_FOUNDATIONKIT - Default: 1.
					</listitem>
					
					<listitem>
					OPTION_GRAPHICSKIT - Default: 1.
					</listitem>
					
					<listitem>
					OPTION_APPLICATIONKIT - Default: 1.
					</listitem>
					
					<listitem>
					OPTION_HTMLKIT - Default: 1 if the compiler is MSVC. Otherwise 0.
					</listitem>
					
					<listitem>
					OPTION_OPENGLKIT - Default: 0.
					</listitem>
					
					<listitem>
					OPTION_NETWORKKIT - Default: 0.
					</listitem>
					
					<listitem>
					OPTION_REMOTEOBJECTKIT - Default: 0.
					</listitem>
					
					<listitem>
					OPTION_INTERNETKIT - Default: 0.
					</listitem>
					
					<listitem>
					OPTION_IMAGEFORMATS - Default: 0.
					</listitem>
					
					<listitem>
					</listitem>
					
					<listitem>
					</listitem>
				</itemizedlist>	
				</para>
				
				<para>
				The following option allows us to define a string that will be a 
				part of the result libraries names.
				<itemizedlist>	
					<listitem>
					OPTION_SELECTLIB
					</listitem>
				</itemizedlist>	
				The value of this option might be some meaningful string that, 
				once set, will be added to the names of the target files. Any 
				string is possible. For example, if the value is _vc6, then 
				the name of, say, the foundation kit debug DLL will be 
				FoundationKit_vc6_d.dll.
				</para>
				<para>
				You may use the following values to be compatible with the 
				default MSVS projects, that are based on the in-code linking 
				using the preprocessor pragma "comment":   _icl6, _icl7, _vc6, 
				_vc70, _vc71, _vc80.
				<note>
				The default value is an empty string.
				</note>
				</para>
				<para>
				The other way to build VCF is to pass the option values in a 
				command line like this:
				<screen>
nmake -f makefile.vc OPTION_SELECTLIB=_vc71 OPTION_DEBUG=0
				</screen>
				</para>
				<para>
				There are the following make targets that can be built independently:
				<itemizedlist>	
					<listitem>ZLib</listitem>					
					<listitem>AGG</listitem>					
					<listitem>LibJPEG</listitem>					
					<listitem>LibPNG</listitem>					
					<listitem>LibMNG</listitem>					
					<listitem>LibTIFF</listitem>					
					<listitem>FreeImage</listitem>					
					<listitem>RegExx</listitem>					
					<listitem>FoundationKit</listitem>					
					<listitem>GraphicsKit</listitem>					
					<listitem>ApplicationKit</listitem>
					<listitem>HTMLKit</listitem>
					<listitem>OpenGLKit</listitem>
					<listitem>NetworkKit</listitem>
					<listitem>RemoteObjectKit</listitem>
					<listitem>InternetKit</listitem>
					<listitem>ImageFormats</listitem>
				</itemizedlist>	
				</para>
				</section>				
				
				<section><title>Baked Project Files</title>
				<para>
				The ready-to-use VS6 project files are located at the 
				%VCF_ROOT%\build\bakefiles.gen directory. This project does not 
				use the described above config file at all.				
				</para>
				<para>
				Please note, the project contains several configurations that 
				allow us to choose the name of the result libraries:
				<itemizedlist>
					<listitem>vc80 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc80 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc80 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>vc80 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>vc71 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc71 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc71 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>vc71 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>vc70 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc70 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc70 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>vc70 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>vc60 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc60 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>vc60 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>vc60 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>icl7 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>icl7 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>icl7 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>icl7 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>icl6 DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>icl6 DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>icl6 Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>icl6 Release (based on "Win32 (x86) Static Library")</listitem>
					
					<listitem>DLL Debug (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>DLL Release (based on "Win32 (x86) Dynamic-Link Library")</listitem>
					<listitem>Debug (based on "Win32 (x86) Static Library")</listitem>
					<listitem>Release (based on "Win32 (x86) Static Library")</listitem>
				</itemizedlist>
				You need to choose a preferred configuration before you start to 
				build VCF.
				</para>
				<para>
				If you want to build VCF under your VS7.0, VS7.1 or VS8.0 you just 
				need to convert all files of this project into the actual format 
				as your VS IDE will suggest.
				</para>
				<para>
				There is no the ready-to-use all-in-one project. However, you are 
				able to generate it if you really need it. How to do this you can 
				find in the section that describes bakefiles.
				</para>
				</section>
				
				<section><title>Building Examples</title>
				<para>
				Each example has its own baked make file, a name of which is the 
				same as the main make file name. A command to build an example 
				has to be the same as to build VCF. Run a make utility in example's 
				directory to build the example separately. Run a make utility in 
				the "examples" directory to build all the examples.
				</para>
				<para>
				Note, an example will be built only if a kit that this example uses 
				enabled by setting an appropriate option.
				</para>
				<para>
				The VS6 project files for examples are not generated, so use non-baked 
				VS projects.				
				</para>
				</section>

				<section><title>Using bakefiles in your own project</title>
					<para>
					The easiest approach to create a make file or a VS6 project for 
					your own project using the VCF offers is to use bakefiles. Lets look 
					at the simplest way to start your own VCF project from scratch using 
					your favorite editor.
					</para>

					<para>
					Say, you created your own helloworld.cpp:
					<programlisting>
#include "vcf/FoundationKit/FoundationKit.h"

using namespace VCF;

int main( int argc, char** argv )
{
	FoundationKit::init( argc, argv );

	System::println( "Hello world!" );

	FoundationKit::terminate();
	return 0;
}
					</programlisting>
					</para>

					<para>
					You would like to test it and want to create a make file as easy
					and as quickly as possible. Create a text file helloworld.bkl as
					follows:
					<programlisting>
			<![CDATA[
<?xml version="1.0" ?>

<makefile>
	<include file="VCFHelper.bkl"/>

	<exe id="helloworld" template="vcf_exe_console">
		<sources>helloworld.cpp</sources>
		<vcf-use-FoundationKit/>
	</exe>
</makefile>
			]]>
					</programlisting>
					</para>

					<para>
					That is all. You are ready to generate a make file or a VS6
					project. Suppose you want to generate a VS6 project. You just
					need to run the following command from a command line:
					<screen>
bakefile -I"%VCF_ROOT%\build\bakefiles" -f msvc6prj helloworld.bkl
					</screen>
					This command will generate helloworld.dsp and helloworld.dsw.
					</para>

					<para>
					If you prefer to generate a make file just run one of the
					following commands. Which of them is yours depends on what the
					compiler you prefer.
					</para>

					<para>
					This command will generate makefile.vc.
					<screen>
bakefile -I"%VCF_ROOT%\build\bakefiles" -f msvc helloworld.bkl
					</screen>
					</para>

					<para>
					This command will generate makefile.gcc.
					<screen>
bakefile -I"%VCF_ROOT%\build\bakefiles" -f mingw helloworld.bkl
					</screen>
					</para>

					<para>
					This command will generate makefile.bcc.
					<screen>
bakefile -I"%VCF_ROOT%\build\bakefiles" -f borland helloworld.bkl
					</screen>
					</para>

					<para>
					This command will generate GNUmakefile.
					<screen>
bakefile -I"%VCF_ROOT%\build\bakefiles" -f gnu helloworld.bkl
					</screen>
					</para>

					<para>
					As you can see there are different formats (-f parameter) only.
					There are the following assignments between formats and
					compilers.
					<itemizedlist>
						<listitem>
						msvc - MS VC
						</listitem>
						<listitem>
						mingw - MinGW/GCC
						</listitem>
						<listitem>
						borland - Borland C++ compiler
						</listitem>
						<listitem>
						gnu - GCC
						</listitem>
					</itemizedlist>
					The first three are Windows specific. The last one means a
					unix-style make file that can be used on Linux, Cygwin and Mac OS
					X.
					</para>

					<para>
					Once you execute the bakefile utility as it is described above
					you will get a make file. Or you will get several make files, if
					you generate them for different formats. Anyway, one of the
					following command will build an executable for you:
					<itemizedlist>
						<listitem>
						GNU make
						<screen>
make -f GNUmakefile
						</screen>
						</listitem>
						
						<listitem>
						Borland make
						<screen>
make -f makefile.bcc
						</screen>
						</listitem>
						
						<listitem>
						MinGW make
						<screen>
mingw32-make -f makefile.gcc
						</screen>
						</listitem>
						
						<listitem>
						MS nmake
						<screen>
nmake -f makefile.vc
						</screen>
						</listitem>
					</itemizedlist>
					</para>

					<para>
					Let us look at the helloworld.bkl closer. It is an XML file.
					There are two tags &lt;include&gt; and &lt;exe&gt;. The first one includes
					the VCFHelper.bkl file that has to be included by any user
					project:
					<programlisting>
			<![CDATA[
<include file="VCFHelper.bkl"/>
			]]>
					</programlisting>
					</para>

					<para>
					The &lt;exe&gt; tag defines an executable. It is a console VCF
					application that has the only source file helloworld.cpp and uses
					the FoundationKit:
					<programlisting>
			<![CDATA[
<exe id="helloworld" template="vcf_exe_console">
	<sources>helloworld.cpp</sources>
	<vcf-use-FoundationKit/>
</exe>
			]]>
					</programlisting>
					</para>

					<para>
					Suppose you created a GUI application that uses the ApplicationKit like this.
					<programlisting>
#include "vcf/ApplicationKit/ApplicationKit.h"

using namespace VCF;

int main( int argc, char** argv )
{
	Application* app = new Application(argc,argv);

	Window* mainWindow = new Window();
	app->setMainWindow( mainWindow );
	mainWindow->setCaption( "Hello World" );
	mainWindow->show();

	Application::main();

	return 0;
}
					</programlisting>
					</para>

					<para>
					Of course, you need to modify your bakefile as follows.
					<programlisting>
			<![CDATA[
<?xml version="1.0" ?>

<makefile>
	<include file="VCFHelper.bkl"/>

	<exe id="helloworld" template="vcf_exe_gui">
		<sources>helloworld.cpp</sources>
		<vcf-use-ApplicationKit/>
	</exe>
</makefile>
			]]>
					</programlisting>
					</para>

					<para>
					Please refer to the VCF examples to see how you can prepare a
					bakefile appropriate to your project. Each example directory
					contains a bakefile which can be used to learn the bakefiles
					features that are VCF specific. Please note, all the VCF examples
					include VCFCommon.bkl instead of VCFHelper.bkl. VCFCommon.bkl and
					VCFHelper.bkl are similar to each other. However, there is one
					difference. VCFCommon.bkl defines the bakefile variables that use
					the relative paths and can be used inside the VCF source tree
					only. VCFHelper.bkl defines the bakefile variables that use the
					system environment variable VCF_ROOT and can be used outside of
					the VCF source tree. In other words, these are two different
					entry points: VCFCommon.bkl is for the internal use only;
					VCFHelper.bkl is to use in external custom projects.
					</para>

					<para>
					As you can see the first bakefile has the &lt;vcf-use-FoundationKit&gt;
					tag. The second bakefile has the &lt;vcf-use-ApplicationKit&gt; tag.
					For every kit there is a certain tag.
					<itemizedlist>
						<listitem>
						&lt;vcf-use-FoundationKit&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-GraphicsKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-ApplicationKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-HTMLKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-OpenGLKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-NetworkKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-RemoteObjectKit&gt;
						</listitem>
						
						<listitem>
						&lt;vcf-use-InternetKit&gt;
						</listitem>
					</itemizedlist>
					</para>

					<para>
					The VCF contains some thirdparty libraries. You can use them in your
					project, so you might want to include an appropriate tag in your bakefile.
					For every library there is a certain tag.
					<itemizedlist>
						<listitem>
						&lt;vcf-use-AGG&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-ZLib&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-LibJPEG&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-LibPNG&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-LibMNG&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-LibTIFF&gt;
						</listitem>

						<listitem>
						&lt;vcf-use-FreeImage&gt;
						</listitem>
					</itemizedlist>
					</para>

					<para>
					You can just add an include path of a thirdparty library in your project.
					Here is a list of the appropriate tags.
					<itemizedlist>
						<listitem>
						&lt;vcf-include-thirdparty&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-boost&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-AGG&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-ZLib&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-LibJPEG&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-LibPNG&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-LibMNG&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-LibTIFF&gt;
						</listitem>

						<listitem>
						&lt;vcf-include-FreeImage&gt;
						</listitem>
					</itemizedlist>
					</para>
				</section>

				<section><title>Regenerating makefiles and VS6 project files</title>
					<note>
					Please note, you can only run the bakefile_gen executable from 
					the %VCF_ROOT%\build\bakefiles directory.
					</note>

					<para>
					If you want to regenerate the baked makefiles you need to use 
					the bakefile_gen executable of the Bakefile utility.
					The following command will regenerate all the baked makefiles
					of the VCF.
					<screen>
			bakefile_gen -f msvc,borland,msvc6prj,mingw,gnu
					</screen>
					There are several formats of the result makefiles that are separated 
					by comma. Note, this command executes long time for the first time.
					</para>

					<para>
					You can regenerate makefiles of a certain format only like this.
					<screen>
			bakefile_gen -f msvc
					</screen>
					</para>
				</section>
	
				<section><title>All-in-1 VS6 project</title>
					<note>
					Please note, you can only run the bakefile_gen executable from 
					the %VCF_ROOT%\build\bakefiles directory.
					</note>

					<para>
					There is no all-in-1 VS6 project by default. However, you can
					generate it yourself. Before you begin you need to delete existing
					*.dsw and *.dsp files. You can do this by hand file by file; or you 
					can execute the following command that does this job for you. 
					<screen>
bakefile_gen -f msvc6prj -c
					</screen>
					</para>

					<para>
					Run the following command to generate the all-in-1 VS6 project.
					<screen>
bakefile_gen -f msvc6prj -DOPTION_ALLIN1=1
					</screen>
					</para>
				</section>
			</section>
			
			<section><title>MacOSX</title>
				<para>
				The VCF currently requires OSX 10.2 or better, preferably 10.3. 
				There are projects supplied for XCode. The Project Builder projects
				have been disconrtinued and are currently not supported as PB has 
				been dropped by Apple, and will not run on newer versions of OS X 
				later than 10.2. You can download the VCF from SourceForge via cvs 
				(see the instructions getting the VCF via CVS). 
				</para>
				<para>
				Once you have downloaded the code you need to make a few environment 
				configurations. Currently the projects depend on having the 
				environment	variables VCF_INCLUDE, VCF_BIN, and VCF_LIB defined. This 
				will go away in the near future but for now please define them. To 
				define environment variables in OSX create a ".MacOSX" directory under 
				you home directory. Create a file called "environment.plist" under the 
				.MacOSX directory like so:
				<programlisting>
cd ~
mkdir .MacOSX
touch .MacOSX/environment.plist
open .MacOSX/environment.plist
				</programlisting>
				This will open the environment.plist in the Property List Editor. Add 
				the variables VCF_INCLUDE, VCF_BIN, and VCF_LIB, with VCF_INCLUDE set 
				to "&lt;vcf root&gt;/include", VCF_BIN set to "&lt;vcf root&gt;/bin", 
				and VCF_LIB set to "&lt;vcf root&gt;/lib". You can see an example 
				below:
				<graphic fileref="gfx/mac-env-vars.png"> 
				</graphic>
				You may have to logout and log back in to get the environment variables 
				to take effect.
				</para>
				<para>
				Now you should be ready to open the VCF in XCode or Project Builder. For 
				Xcode open the vcf/build/xcode/vcfAllProjects.pbproj project. For Project
				Builder open the vcf/build/osx-pb/vcfAllProjects.pbproj project. There are
				"release" and "debug" targets provided. This was done because we had 
				problems understanding how to work with the whole development/deployment 
				builds. In the future this will almost certainly change.
				</para>
				<para>
				Each of the "kits" of the VCF are built as Frameworks under Mac OSX. Thus
				if you have an application you'd like to add VCF support to, you just need to
				add the appropriate VCF framework kit, such as FoundationKit.framework, 
				GraphicsKit.framework, or ApplicationKit.framework.
				</para>
			</section>
			
			<section><title>Linux</title>
				<para>
				Currently the Linux port is in progress and these instructions may change,
				but here are the current steps to build, as of November 3, 2003.
				</para>
				<para>For Linux systemsFor Linux systems
				First make sure you have GTK (at least version 2.2). Most recent linux 
				distributions include this by default, so you probably have it. An easy 
				test would be to try the following:
	<programlisting>
echo `pkg-config gtk+-2.0 --cflags`
	</programlisting>
				You should see some sort of GCC compiler flags - if you get back error messages 
				like:
	<programlisting>
pkg-config: command not found
	</programlisting>
				Then you don't have the pkg-config system installed (and almost certainly not 
				GTK which depends on pkg-config). If you see something like:
	<programlisting>
Package gtk+-2.0 was not found in the pkg-config search path.
Perhaps you should add the directory containing `gtk+-2.0.pc'
to the PKG_CONFIG_PATH environment variable
No package 'gtk+-2.0' found
	</programlisting>
				Then you have the pkg-config tool, but probably not gtk installed (or not 
				installed correctly).
				</para>
				<para>For more information about GTK and installing it go 
				<ulink url="http://developer.gnome.org/doc/API/2.2/gtk/gtk-building.html"> 
				here</ulink>.
				</para>
				<para>
				Once you have confirmed you have (or installed) GTK, go to the 
				vcf/build/make directory. Type 
				<programlisting>
make debug
				</programlisting>
				for a debug version of the libraries, or 
				<programlisting>
make release</programlisting>
				for an optimized, release version of the libraries. To build both release
				and debug targets, type:
				<programlisting>
make all</programlisting>
				</para>
				<para>
				The .a library files will be output to the vcf/lib directory, while the 
				.so shared libraries will be output to the vcf/bin directory. To ensure 
				programs can load these up you may need to add the vcf/bin path to your 
				LD_LIBRARY_PATH. In the future this may change to correctly using the -rpath
				option to ld when linking.
				</para>
				<para>
				There is currently no install target. This needs to be addressed in the 
				very near future! Presumably, you can just copy the .so's in the vcf/bin 
				directory into /usr/local/lib.
				</para>
			</section>
			
		</section>
		<section><title>Library Support by Compiler</title>
			<para>
				The libraries that constitute the VCF and support by various compilers 
				are given in the table below. The VCF is modular by nature, and some 
				parts of the framework are not supported by all compilers. The OSX and 
				Linux ports are in progress, and we welcome support from new developers 
				to help finish these ports (as well as on the Win32 side). 
			</para>
			<table frame="none" pgwide="1">
				<tgroup cols="7" align="left" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>Library</entry>
							<entry>MS VC 6,7,8</entry>	
							<entry>BCB5 and free</entry>
							<entry>BCB6 and BDS '06</entry>
							<entry>MinGW(GCC)</entry>
							<entry>OSX-GCC</entry>
							<entry>Linux-GCC</entry>					
						</row>							
					</thead>
					<tbody>
						<row>
							<entry>FoundationKit</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>GraphicsKit</entry>	
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>ApplicationKit</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
	
						<row>
							<entry>OpenGLKit</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
	
						<row>
							<entry>RemoteObjectKit</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>NetworkKit</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>InternetKit</entry>	
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>No</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>HTMLKit</entry>
							<entry>Yes</entry>
							<entry>No</entry>
							<entry>Yes</entry>							
							<entry>No</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>AGG</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>ZLib</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>LibPNG</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>LibMNG</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
						<row>
							<entry>LibJPEG</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
						</row>
						<row>
							<entry>LibTIFF</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>No</entry>
						</row>
						<row>						
							<entry>FreeImageLib</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>
							<entry>Yes</entry>							
							<entry>No</entry>
							<entry>No</entry>
							<entry>No</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>				
	</section>			
	
	<section><title>Contributing</title>
		<section><title>Registering at SF</title>
		<para>
		Interested in contributing to the VCF project ? Great ! First you need to become a 
		member of Source Forge. SourceForge membership is free, and only takes a minute to 
		fill out the web form. It is a requirement for participating in any 
		Source Forge sponsored project, like the VCF. You can join at the Source Forge 
			<ulink url="http://sourceforge.net/account/register.php">New User page</ulink>.
		</para>
		<para>
		Next, you need to email me, and let me know to add you to the project. It usually 
		takes a day or so for your Source Forge account to become activated,  so keep that 
		in mind. If your a developer, you'll be added with read/write privileges to the CVS 
		source tree. 
		</para>
		</section>
		<section><title>Setting up CVS</title>
			<para>
			Once all of this is done, all you have to do is setup your machine to use CVS 
			and SSH. CVS and SSH are must have tools, without these you'll not be able to 
			check source code in or out from CVS, which is the standard version control 
			program used by all Source Forge projects. You can get both of these tools 
			from a variety of places, including the VCF Installer, as well as 
			a smaller installer on the project that only installs CVS and SSH, 
			and also configures your system to use them ( you can get this installer 
			here). For documentation on how to use SSH on your Win32 system, SourceForge 
			has some great articles, as well as some specific stuff just for Win32 
			(here, and here). There are some things you'll need to check for to make 
			sure CVS and SSH will work together correctly so please verify the following: 
			<itemizedlist>
				<listitem><para>
				You'll need a CVSROOT variable that equals 
				<synopsis>
:ext:&lt;your username&gt;@cvs.sourceforge.net:/cvsroot/vcf
				</synopsis>
				</para></listitem>
				<listitem><para>
				You'll need a CVS_RSH that equals "ssh" 
				</para></listitem>				
			</itemizedlist>
			</para>				
		</section>
		
		<section><title>Developing in the main VCF source tree</title>
			<para>
			When developing in the VCF proper you need to be aware that there are
			at least two branches in CVS at any given time. There will be a dev 
			branch for adding new features etc. Until this new set of features is 
			tested and ready it will stay separate from the main branch, which should 
			contain relatively stable code. When you are working on implementing these 
			new features you should be working in this development branch, NOT the 
			main branch. The main branch is only for checking in bug fixes for reported 
			bugs on it. This allows people to download a stable branch, rather than 
			pulling something down that is in a continuous state of flux.
			</para>
			<para>
			As a developer you need to be aware of this and make sure that you 
			are checking out the correct version. Please see this for instructions 
			on how to access branches in CVS trees. For further help look at the 
			<ulink url="http://www.cvshome.org/docs/manual/cvs.html">cvshome.org</ulink> 
			pages for more detailed information on using cvs.
			</para>
			<para>
			The recommended procedure is the following:
			</para>
			<para>
			Create two directories, perhaps something like this:
			<screen>
&lt;rootdir&gt;
vcfcode/
	dev/
		vcf/
		    src/...
	stable/
		vcf/
		    src/...
			</screen>
			</para>
			<para>
			This gives you a stable release directory to work on for bug fixing, 
			and another directory to work on for new development code that may be 
			unstable or untested and is not yet ready to go into the main branch.
			</para>
		</section>
	</section>
	<section><title>Standards</title>
			<para>
			Please read the naming standards documentation before you start changing 
			all sorts of things. These standards must be followed for any code 
			that gets entered into the main VCF development tree. 
			</para>
			<para>
			To get familiar with things build the VCF if you haven't already done so, 
			and then check out some of the example code in the vcf/examples 
			directory.  
			</para>
			<para>
			If you're unsure where to go next, try taking a look at the 
			<ulink url="http://sourceforge.net/tracker/?group_id=6796&amp;atid=106796">bug list</ulink> 
			or <ulink url="http://sourceforge.net/pm/?group_id=6796">tasks list</ulink> 
			at the project page. Also feel free to contact anyone on the project or
			stop by the project <ulink url="http://vcf.sourceforge.net/forums">forums</ulink>
			for more information.  
			</para>
		<section><title>Coding and Naming Standards</title>
			<para>
			The following <indexterm><primary>standards</primary></indexterm> are 
			setup here to attempt to increase the readability of the VCF source code.  
			Developers interested working on the framework proper, must adhere to 
			these guidelines. Any questions regarding this, please email me. 
			<note>
			Much of this is rehashed from naming standards used on other projects, so 
			there is nothing new here, and tries to use as much common sense as possible.  
			Folks who are familiar with Borland's Delphi, Sun's Java, or (gasp...) 
			Microsoft's .NET naming conventions will probably recognize a great deal here. 
			</note>
			</para>
			
			<para>
			Do <emphasis>not</emphasis> use Hungarian notation at all in any code that 
			is in the main VCF development tree. Code submitted like this will be removed
			or ignored (if submitted as a patch).
			</para>
			<formalpara><title>Capitalization Styles</title>					
			</formalpara>
			<para>
			There are two main capitalization schemes the VCF uses:
			</para>
			<formalpara><title>Camel casing:</title>
			</formalpara>
			<para>
			Capitalizes the first character of each word except the first word. For example:
			<programlisting>
fileStream
			</programlisting>
			</para>
			
			<formalpara><title>Pascal casing:</title>
			</formalpara>
			<para>
			Capitalizes the first character of each word. For example:
			<programlisting>
FileStream
			</programlisting>
			</para>
			<para>
			The following table indicates which styles are used for the various 
			types/identifiers.
			<table frame="none" pgwide="1">
				<tgroup cols="3" align="left" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>Type</entry>
							<entry>Case</entry>
							<entry>Comments</entry>
						</row>							
					</thead>
					<tbody>
						<row>
							<entry>Class</entry>
							<entry>Pascal casing</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>enumerated values</entry>
							<entry>Camel casing</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>enumerated type</entry>
							<entry>Pascal</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>Member function, regular functions</entry>
							<entry>Camel casing</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>Namespaces</entry>
							<entry>Pascal casing</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>RTTI property name</entry>
							<entry>Camel casing</entry>
							<entry></entry>
						</row>
						
						<row>
							<entry>Function arguments</entry>
							<entry>Camel casing</entry>
							<entry></entry>
						</row>
						<row>
							<entry>Member variables</entry>
							<entry>Camel casing</entry>
							<entry>uses "_" suffix </entry>
						</row>
						
						<row>
							<entry>regular variables</entry>
							<entry>Camel casing</entry>
							<entry></entry>
						</row>				
						
					</tbody>
				</tgroup>
			</table>					
			</para>
			
			<formalpara><title>Class naming</title></formalpara>					
			<para>
			Classes should be named with nouns or noun phrases, with more or less 
			abstraction in the name depending on it's usage. For example, a common 
			base class for describing objects that represent bananas, apples and 
			oranges might be Fruit, with a class called Banana deriving from Fruit. 
			<itemizedlist>
				<listitem><para>
				Pascal casing
				</para></listitem>
				
				<listitem><para>
				No prefixes, like "C", or "vcf" or whatever. If you really need a 
				prefix then you probably need the class inside of a namespace. 
				</para></listitem>
				
				<listitem><para>
				Keep away from abbreviations if at all possible. Common ones like 
				IO, or UI are OK, but please use sparingly.
				</para></listitem>
				
				<listitem><para>
				No underscores.
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Examples:
			<programlisting>
FileStream

ClassRegistry

Control					
			</programlisting>
			</para>
			<formalpara><title>Enumerated values</title></formalpara>
			<para>
			Enumerated values should have a descriptive name of what the value 
			represents. The value names should use a prefix that is an acronym 
			of the upper case characters of the enumeration type.
			<itemizedlist>
				<listitem><para>
				Camel casing
				</para></listitem>
				
				<listitem><para>
				Prefixes are OK, but must follow the rules above, see example
				</para></listitem>
				
				<listitem><para>
				Keep away from abbreviations if at all possible. Common ones like 
				IO, or UI are OK, but please use sparingly
				</para></listitem>
				
				<listitem><para>
				No underscores 
				</para></listitem>
			</itemizedlist>					
			</para>
			<para>
			Examples:
			<programlisting>
enum FruitBaskets {
fbLittleBasket = 0,
fbMediumBasket,
fbElGrandeBasket  
};

enum MessageStyle {
msDefault = 0,
msError,
msInfo,
msWarning
};
			</programlisting>
			</para>
			
			<formalpara><title>Enumerated types</title></formalpara>
			<para>
			Names should be clearly descriptive of the type and what it represents. 
			When appropriate please nest the enum type inside of the class it is 
			associated with (don't forget to place it at public scope so others 
			may use, assuming that is the intent).
			<itemizedlist>
				<listitem><para>
				Pascal casing
				</para></listitem>
				
				<listitem><para>
				No prefixes
				</para></listitem>
				
				<listitem><para>
				Keep away from abbreviations if at all possible
				</para></listitem>
				
				<listitem><para>
				No underscores 
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example
			<programlisting>
Dialog::MessageStyle

AlignmentType
			</programlisting>
			</para>
			<para>
			<emphasis>Always</emphasis> refer to enum types that are part of a 
			class with the class name. 
			</para>
			<para>
			Example
			<programlisting>
Dialog::MessageStyle, 

//as opposed to
MessageStyle
			</programlisting>
			</para>
			
			<formalpara><title>Class member function naming</title>
			</formalpara>
			<para>
			Use names that have verbs or verb phrases that clearly express what the 
			function will do. Functions that return a true or false value should 
			try and use the "is" or "has" in front of the name, i.e. 
			<function>isEmpty()</function> or <function>hasData()</function>.

			<itemizedlist>
				<listitem><para>
				Camel casing 
				</para></listitem>

				<listitem><para>
				Keep away from abbreviations if at all possible
				</para></listitem>
				
				<listitem><para>
				No underscores, unless the function's scope is forced to be public 
				but is not meant for general usage(for whatever reason). In this 
				case a "internal_" should be prefixed to the name of the function.
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example:
			<programlisting>
class Foo : public VCF::Object {
public:

String getName();

void internal_doSomething( int someValue );
};
			</programlisting>
			</para>
			
			<formalpara>
				<title>Class member variable naming</title>
			</formalpara>
			<para>
			Use adjectives that clearly describe what the member is and how it 
			should be used. All member names must use the "_" suffix convention.
			<itemizedlist>
				<listitem><para>
				camel casing
				</para></listitem>

				<listitem><para>
				Keep away from abbreviations if at all possible
				</para></listitem>
				
				<listitem><para>
				a single underscore suffix only, no underscores in the actual name 
				</para></listitem>
				
				<listitem><para>
				no Hungarian notation
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example:
			<programlisting>
class Foo {
public:
protected:
int countOfBarObjects_;
String name_;
};
			</programlisting>
			</para>
			
			<formalpara>
				<title>Variable naming</title>
			</formalpara>
			<para>
			Use descriptive names that clearly identify what the variable should 
			do or what it means rather than identifying it's type. Do 
			<emphasis>not</emphasis> use Hungarian notation.
			<itemizedlist>
				<listitem><para>
				Camel casing
				</para></listitem>

				<listitem><para>
				Keep away from abbreviations if at all possible
				</para></listitem>
				
				<listitem><para>
				No underscores
				</para></listitem>
				
				<listitem><para>
				No Hungarian notation
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example:
			<programlisting>
			</programlisting>
			</para>
			
			<formalpara>
				<title>Function naming</title>
			</formalpara>
			<para>
			Use names that have verbs or verb phrases that clearly express what 
			the function will do. 
			<itemizedlist>
				<listitem><para>
				Camel casing 
				</para></listitem>

				<listitem><para>
				Keep away from abbreviations if at all possible. 
				</para></listitem>
				
				<listitem><para>
				No underscores 
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example:
			<programlisting>
			</programlisting>
			</para>
			
			<formalpara>
				<title>Use of Namespaces</title>
			</formalpara>
			<para>
			Use namespaces to group a large collection of classes, typedefs, etc 
			together, to more clearly identify the classes. Use namespaces in 
			place of class prefixes or function prefixes. For example instead of the 
			classes PDQFileDialog,  PDQDumper, and PDQBigStuff, create a namespace 
			called PDQ and rename the classes to FileDialog, Dumper, and BigStuff, 
			and place them inside of the PDQ namespace.
			<itemizedlist>
				<listitem><para>
				Pascal casing
				</para></listitem>

				<listitem><para>
				Abbreviations are OK for namespaces 
				</para></listitem>
				
				<listitem><para>
				No underscores 
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			Example:
			<programlisting>
			</programlisting>
			</para>
			
			
			<formalpara>
				<title>Use of static class methods/members</title>
			</formalpara>
			<para>
			see Function naming and Member function naming above with the following 
			restrictions:
			<itemizedlist>
				<listitem><para>
				<emphasis>No</emphasis> underscores at all  
				</para></listitem>
			</itemizedlist>
			All static members must always be referenced with the class name that they 
			are part of, never just by themselves, or by a class instance.
			</para>
			<para>
			Example:
			<programlisting>
//declaration:
class Foo {
public:
static String commonBarRepository;
};

//initialization:
String Foo::commonBarRepository = "some useful initial value";

//usage:

//OK
String s = Foo::commonBarRepository;

//Unacceptable, even with the scope of class Foo
String s = commonBarRepository;

//Also unacceptable
Foo f;
String s = f.commonBarRepository;					
			</programlisting>
			</para>
			
			<formalpara>
				<title>Comments</title>
			</formalpara>
			<para>
			The standard comment style used in the VCF is comparable to what is 
			used in Java, i.e. the 
			<programlisting>
/**
*/
			</programlisting>
			style.
			</para>
			<para>
			Headers with the following should be documented 
			<itemizedlist>
				<listitem><para>
				Namespaces 
				</para></listitem>

				<listitem><para>
				Structs 
				</para></listitem>
				
				<listitem><para>
				Unions 
				</para></listitem>
				
				<listitem><para>
				Classes 
				</para></listitem>
				
				<listitem><para>
				Class/Struct/Union members (semi optional depending on what it is 
				and how clear the name is) 
				</para></listitem>
				
				<listitem><para>
				Class methods 
				</para></listitem>
				
				<listitem><para>
				Enums 
				</para></listitem>
				
				<listitem><para>
				Functions 
				</para></listitem>
				
				<listitem><para>
				custom #defines 
				</para></listitem>
			</itemizedlist>
			</para>
			<para>
			The rationale for this is to allow for automatic source level 
			documentation by processing all headers through doxygen. Document the 
			headers. Document your classes. More documentation is better that 
			no documentation. Be as clear and concise as possible in explaining 
			what something does. You can and should use html markup tags for further 
			clarity, for example the &lt;B&gt; tag to emphasize some point or word,
			or use the "\em" doxy tag for this. Also where applicable, feel free to put 
			a sample piece of code that illustrates proper usage. Use the &lt;PRE&gt; tags 
			for this. Note that you can 
			also use the doxygen <ulink url="http://www.stack.nl/~dimitri/doxygen/commands.html#cmdcode">
			"\code"</ulink> and <ulink url="http://www.stack.nl/~dimitri/doxygen/commands.html#cmdendcode">
			"\endcode"</ulink> tags as well. 
			</para>
			<para>
			The preferred format for documenting a class is to use the doxygen command
			"\class" to specify the class name and it's proper include file, followed 
			by the first paragraph with <emphasis>no</emphasis> "\par" command. Successive
			paragraphs need to use the "\par" command. Doing so ensures that the doxygen
			properly picks up you first sentence for use in it's "brief" comments section
			for your class. For example:
			<programlisting><![CDATA[
/**
\class FooBar FooBar.h "vcf/FoundationKit/FooBar.h"
Initial paragraph explaining what this class does.
\par
Further paragraphs explaining what this does...
*/
class FooBar {
//rest of code omitted...
};
			]]></programlisting>
			The last part of the "\class" command specifies the directory path of the
			include file. If you are adding a new class to on the VCF kits, then the 
			proper format is "vcf/" plus the kit name, followed by the actual header
			file name. So if you added a new CalendarControl to the ApplicationKit,
			the path would be "vcf/ApplicationKit/CalendarControl.h".
			</para>
			<para>
			Do not pollute the code, particularly the headers, with tons of "//" 
			spacers a-la what Microsoft's Visual C++ generated code for classes does. 
			Keep it clean.
			</para>
			<para>
			For single line comments line comments you can use the "//" but it is 
			still prefered that you use the
			<programlisting>
/**
comment
*/
			</programlisting>
			style.
			</para>
			<para>
			Use the @param, @return, @author, and @version to further clarify what 
			paramaters/arguments and return values do, as well as the author and 
			version of the item in question.The @version should be the current cvs 
			version that you are working under. If you are not entirely sure what 
			these do, look them up in JavaDoc (which is where they are from). 
			</para>
			<para>
			Example:
			<programlisting>
/**
This is what the method does...
@param void* this parameter is for....
@param bool this parameter indicates....
@param String the name of.....
@return int the return value is...
@author Jim Bob Snake
@version 0.5.9
*/
int myCoolMethod( void* d, bool b, String s );					
			</programlisting>
			</para>
			<para>
			In addition to the javadoc style tags, since we use doxygen, you can also use the 
			doxygen <ulink url="http://www.stack.nl/~dimitri/doxygen/commands.html">special tags</ulink>
			for further control of formatting. Not all of the header docs use these yet, but for 
			examples that do, see the following files:
			  <itemizedlist>
			    <listitem><para>
				vcf/src/vcf/FoundationKit/Locales.h
				</para></listitem>
			  
				<listitem><para>
				vcf/src/vcf/GraphicsKit/Image.h
				</para></listitem>
				
				<listitem><para>
				vcf/src/vcf/GraphicsKit/PrintSession.h
				</para></listitem>
			  </itemizedlist>
			</para>
			
			<formalpara><title>Code Blocks</title>
			</formalpara>
			<para>
			While I am sure this is mildly controversial, bordering on hysterical, or perhaps 
			even blasphemous, I am going to set down some rules for code blocks, i.e. the famed
			"{" and "}". For consistencies sake please use the following guidelines for code that
			is in the VCF core source tree (i.e. anything under the vcf/src/vcf directory). Example
			code is free to diverge from this (though I would encourage it usage there too).
			</para>
			<para>
			For function blocks do not write them on a single line, even for something as simple as 
			a get method that just returns a member variable. The problem is that, at least on
			Microsoft compilers/debuggers (and almost certainly GCC/GDB as well), it becomes really
			difficult to step through code, or examine the variable(s). Beleive it or not, not all of
			us are <ulink url="http://weblogs.asp.net/oldnewthing/archive/2004/11/11/255800.aspx">
			assembly level debuggers</ulink>!.
			<programlisting>
//Unacceptable			
class Foo {
public:
	int val_;
	
	int foo() { return val_; }
};

//OK
class Foo {
public:
	int val_;
	
	int foo() { 
		return val_; 
	}
};
			</programlisting>
			</para>
			<para>
			For "if..then" blocks use the following:
			<programlisting>
if ( condition ) {
	//code
}
			</programlisting>
			Please don't use 
			<programlisting>
if ( condition ) 
	//single line of code

			</programlisting>
			Use the "{}" brackets even with the one line. Please avoid using the following constructs:
			<programlisting>
//BAD!
if ( condition ) {
	//code
} else {

}

//OK
if ( condition ) {
	//code
} 
else {

}			</programlisting>
			</para>
		</section>
			
			<section><title>Documentation Standards and Generation</title>
			<formalpara><title>Introduction</title>
			The VCF uses DocBook for all documentation that is not generated from 
			source code. For source code generated documentation, we use doxygen. 
			This section will concentrate on explaining how to edit	and work with 
			the VCF DocBook documentation. If you have never used DocBook before, 
			take a glance at this 
			<ulink url="http://www.codeproject.com/winhelp/docbook_howto.asp">CodeProject article</ulink> 
			that thoroughly explains how to get set up and running with DocBook on 
			Win32 systems.
			</formalpara>
			<formalpara><title>Generating the VCF DocBook files</title>
			To generate the VCF documentation on a Win32 system, you have to have 
			a few things set up:
			<itemizedlist>
			<listitem><para>
			You'll need cygwin and xlst_proc
			</para></listitem>
			<listitem><para>
			You'll need the DocBook xsl stylesheets
			</para></listitem>
			<listitem><para>
			If you want to generate HTML Help then you'll need Microsoft's HTML 
			Help. You can get it from:
			<ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/htmlhelp/html/hwMicrosoftHTMLHelpDownloads.asp">
			http://msdn.microsoft.com/library/default.asp?url=/library/en-us/htmlhelp/html/hwMicrosoftHTMLHelpDownloads.asp
			</ulink>. Download it from <ulink url="http://go.microsoft.com/fwlink/?LinkId=14188">http://go.microsoft.com/fwlink/?LinkId=14188</ulink>
			</para></listitem>
			</itemizedlist>
			</formalpara>
			<para>			
			Currently certain files used to build the VCF DocBook documentation 
			require hard coded absolute paths to make sure that things work right. 
			To generate the documentation on your own system, you'll need to edit 
			a few files to make sure the paths are pointing to the right directories.   
			</para>
			<para>
			To start with edit vcf/docs/Makefile in your favourite editor. Make sure 
			the HTMLHELP_COMPILER variable points to the correct directory on your 
			machine. Keep the directories in quotes or make will barf. Make sure 
			XSL_DOCBOOK_DIR points to where you have your DocBook xsl stylesheets installed.
			</para>
			<para>
			Next edit vcf/docs/vcf.xsl. Make sure the line:
			<programlisting>
			<![CDATA[
<xsl:import href="d:/code/docbook-xsl-1.68.1/htmlhelp/htmlhelp.xsl"/>
			]]>
			</programlisting>
			Points to the right doc book directory on your system where your DocBook 
			XSL Stylesheets are found. 
			</para>
			<para>			
			Once you've completed this, open a command line (if you are doing this 
			on a Win32 system you'll need cygwin for this) and cd to vcf/docs. Type: 
			<programlisting>
make coredocs_hh
			</programlisting>
			This should generate the VCF documentation for you in HTML Help chm 
			format (including all tutorials). Look for a file called 
			"VCFDocs.0.6.8.chm" (or whatever the current version is set at).
			</para>
			<formalpara><title>Editing the VCF DocBook Documentation</title>
			To edit the docs open and edit the various .xml files in the vcf/docs 
			directory in your favorite text	or xml editor. The main ones are :
			<itemizedlist>
			<listitem><para>
			corelib_applicationKit.xml - application Kit stuff
			</para></listitem>
			<listitem><para>
			corelib_componentAuthoring.xml - component authoring
			</para></listitem>
			<listitem><para>
			corelib_foundationKit.xml - FoundationKit docs
			</para></listitem>
			<listitem><para>
			corelib_graphicsKit.xml - graphics kit docs
			</para></listitem>
			<listitem><para>
			getting_started.xml - using the vcf and getting around the framework
			</para></listitem>
			<listitem><para>
			general.xml - general vcf docs
			</para></listitem>
			</itemizedlist>			
			</formalpara>
			
			<formalpara><title>Generating Tutorials</title>
			To generate tutorials, open a command line, cd to vcf/docs and type 
			<programlisting>
make tutorials
			</programlisting>	
			This will generate separate "articles" in each tutorial directory 
			(with the top level directory being vcf/examples). 
			</formalpara>
			
			<formalpara><title>Editing and Adding Tutorials</title>
			To add a tutorial article you have to edit/create several files to 
			ensure that the tutorial documentation is added to the full VCF 
			DocBook documentation, and that seperate articles 
			can be created.
			</formalpara>
			<para>
			To start, edit vcf/docs/vcf_docbook.xml. At the top there are a number 
			of ENTITY declarations, each of which point to specific file that 
			contains further documentation. This is done to break the documentation 
			into smaller, more manageable sections. To add a tutorial, you'll need to 
			add a new entity for each tutorial. Let's say we had a tutorial for "FooBar", 
			we'd add an entity for your tutorial(after the last ENTITY), like so:
			<programlisting>
<![CDATA[
<!ENTITY foobar SYSTEM "../examples/FooBar/FooBar.xml">
]]>
			</programlisting>
			Now edit the vcf/docs/tutorials.xml file. This is organized first by kit 
			(or library) and then by section for each tutorial. Find a section or 
			create a new one and insert your entity that you created earlier. For our 
			FooBar example we'll create a new one under the FoundationKit. Our 
			example would look like this:
			
			<programlisting>
<![CDATA[
<section><title>FooBar</title>
	&foobar;
</section>
]]>		
			</programlisting>
			Note that the entity name is the same as you declared it in the 
			vcf/docs/vcf_docbook.xml file.
			</para>
			<para>
			Now you need to create the actual content itself. 
			You <emphasis>must</emphasis> follow this format or things will 
			break. cd to your examples directory
			<programlisting>
cd vcf/examples/FooBar
			</programlisting>
			Create two files named like so:
			<itemizedlist>
			<listitem><para>
			&lt;tutorial name-case sensitive&gt;.xml
			</para></listitem>
			<listitem><para>
			&lt;tutorial name-case sensitive&gt;Article.xml
			</para></listitem>
			</itemizedlist>
			For our example we'd create FooBar.xml and FooBarArticle.xml. Edit the 
			FooBarArticle.xml file and add the following (this must go right at 
			the begining of the file):
			<programlisting>
<![CDATA[
<?xml version="1.0" standalone="no"?>
<!DOCTYPE  book  PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                    "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [	
	<!ENTITY foobar SYSTEM "FooBar.xml">	
]>


<article>	
  &foobar;	
</article>

]]>
			</programlisting>
			This will allow your content in FooBar.xml to either be used in the 
			larger VCF DocBook documentation or allow it to be generated as a 
			standalone article, suitable for posting on websites such as 
			<ulink url="http://www.codeproject.com">CodeProject.com</ulink>.	
			</para>
			<para>
			Now add your actual documentation (following DocBook rules) to Foobar.xml.
			</para>
			<para>
			Finally, to be able to actually generate the tutorials in a standalone 
			manner, we need to make one more change to the vcf/docs/Makefile. Edit 
			vcf/docs/Makefile and add your tutorial to the TUTORIAL_ARTICLES variable. 
			For our example, we'd add:
			<programlisting>
<![CDATA[
TUTORIAL_ARTICLES = ../examples/HelloWorld/HelloWorldArticle.xml\
../examples/FooBar/FooBarArticle.xml
]]>
			</programlisting>
			Save the makefile and your're done! cd to vcf/docs and type
			<programlisting>			
make tutorials
			</programlisting>
			You should end up with a FooBarArticle.html in your tutorials directory.
			</para>
			</section>			
		</section>
	
	
	<section><title>Bugs</title>
	<para>
	Bugs, bugs, bugs - the bane of every developer and project. Naturally the VCF 
	has no bugs so we have nothing to worry about. And if you believe that, I have 
	some real estate in Florida I'd like to show you...
	</para>
	<para>
	Seriously bugs do exist in the VCF and should be reported to the 
	<ulink url="http://sourceforge.net/tracker/?group_id=6796&amp;atid=106796">VCF bug tracker</ulink> 
	on Source Forge.
	</para>
	<para>
	Please submit as much information as possible. If you don't do this, it slows 
	the process down, and the sooner the bug is fixed the happier you'll be ! 
	</para>
	<para>
	As a general rule please submit the following information: 
	<itemizedlist>
		<listitem><para>
		Operating System (and service pack, patch, etc if known). Please indicate 
		if you are using non-english version, as well as if you're language requires 
		special input (for example Arabic, Hebrew, and several other languages are 
		read and input differently than English or Romance/Latin based languages).
		</para></listitem>
		
		<listitem><para>
		System RAM 
		</para></listitem>
		
		<listitem><para>
		System CPU - make ( i.e. Intel, AMD ) &amp; speed ( 550 mhz)
		</para></listitem>
		
		<listitem><para>
		Hard drive size 
		</para></listitem>
		
		<listitem><para>
		General Computer make if applicable ( Dell, Compaq, etc) 
		</para></listitem>
		
		<listitem><para>
		What where you doing (if you remember) when the bug occured? In other words, 
		how do we recreate this ?
		</para></listitem>
		
		<listitem><para>
		Please try and rate the bug (in your opinion). Is it cosmetic, does it affect 
		usability, does it cause your computer to ignite in flames (this one tends to 
		be a serious bug).
		</para></listitem>
		
		<listitem><para>
		Is there an email address we can use to contact you if we need more information? 
		Note this is <emphasis>totally</emphasis> optional, the emails will not be used 
		for spam or anything else.
		</para></listitem>			
	</itemizedlist>
	</para>

	</section>
	
	<section><title>Mailing lists</title>
		<para>
		There is a <ulink url="http://lists.sourceforge.net/lists/listinfo/vcf-development">development 
		mailing list</ulink> that can be subscribed to. Do not use them. Use the 
		<ulink url="http://vcf-online.org/forums/">forums</ulink> instead.
		</para>
	</section>
	
	<section><title>Forums</title>
		<para>
			There are <ulink url="http://vcf-online.org/forums/">forums</ulink> 
			covering a wide range of topics that everyone is encouraged to visit 
			and participate in. There is also a private developer forum, 
			for VCF registered developers only.
		</para>
	</section>		
</chapter>

<!--
$Id$
-->
