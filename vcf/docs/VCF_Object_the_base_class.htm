<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:color("21","333333","Custom #3","0") -->
  <!-- $MVD$:color("22","ee4444","Custom #4","0") -->
  <!-- $MVD$:color("23","ffcc99","Custom #5","0") -->
  <!-- $MVD$:color("24","ff6600","Custom #6","0") -->
  <!-- $MVD$:color("25","eeeeee","Custom #7","0") -->
  <!-- $MVD$:color("26","204060","Custom #8","0") -->
  <!-- $MVD$:color("27","80e0","Custom #9","0") -->
  <!-- $MVD$:color("28","206080","Custom #10","0") -->
  <!-- $MVD$:color("29","802000","Custom #11","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>VCF::Object - the base class</TITLE>
  <META NAME="generator" CONTENT="Microsoft FrontPage 4.0">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK
  REL="StyleSheet" HREF="default.css">
 <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <H1>
   VCF::Object - The base class</H1>
  <P>
   The VCF is, by and large, a single rooted object hierarchy, the base 
   class of which is <CODE>VCF::Object</CODE>. This class provides 
   several common functions for us, as well as providing several method 
   that can be overridden by derived classes.</P>
  <P>
   The core methods are the following:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="21%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="79%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClassName()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a String that identifies the class name of the object.</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClass()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a pointer to a Class object that identifies the Object's 
       runtime class information.</TD>
    </TR>
   </TABLE></P>
  <P>
   The core methods that can be overridden are:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="17%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="83%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       hash()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns an unsigned long that represents the object's hash value. Can 
       be overridden to provide any number of hashing algorithms that return 
       some valid hash number</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       toString()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns a String that represents the object. The default behavior 
       simply returns the pointer for the object's instance. Other 
       implementations may return state information, such as <CODE>VCF::Rect</CODE>,
        which returns the bounds of the rectangle. Used primarily as a 
       debugging tool.</TD>
    </TR>
   </TABLE></P>
  <P>
   In addition, Object also supports reference counting for those who 
   need this kind of support. There are several places in the 
   ApplicationKit that will need to make use of this fairly soon.&nbsp;</P>
  <P>
   Destroying the memory can now happen in two ways:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    The first is the equivalent of the operator <CODE>delete()</CODE> 
    call. This involves calling the objects <CODE>free()</CODE> method, 
    which will call the virtual <CODE>destroy()</CODE> method before 
    calling operator delete() on itself.</P>
   <LI CLASS="mvd-P">
   <P>
    The second way an object can be destroyed is if it's refcount drops 
    to 0, at which point the object's <CODE>free()</CODE> method will be 
    invoked. Calling the object's <CODE>release()</CODE> method 
    decrements the reference count on the object. <CODE>destroy() </CODE>is
     a virtual method, where common shared cleanup may take place, again 
    due to the restrictions of C++, virtual methods are not allowed in 
    destructors, but we get around this with the free()/destroy() pattern.</P>
   </UL>
  <P>
   Semantics for the usage of the <CODE>addRef()/release()</CODE> method 
   usage are as follows:</P>
  <P>
   An object's reference count indicates &quot;ownership &quot; of the 
   object. In other words, the &quot;owner&quot; of the object is 
   responsible for releasing it's hold on the object, thus decrementing 
   the objects reference count, which, when reduced to 0, causes the 
   object to be deleted. This is also known as a <B><I>strong</I></B> 
   reference to an object, as opposed to a <B><I>weak</I></B> reference 
   where the &quot;owner&quot; doesn't claim any responsibility over the object.&nbsp;</P>
  <P>
   An example might look like this:</P><PRE>class Bar : public Object {<BR>public:<BR>    ...//declarations    <BR>};<BR><BR><BR>class FooBar : public Object {<BR>public:<BR>    ...//rest of class declaration<BR><BR>    void setBarObj( Bar* bar ) {<BR>        m_barObj = bar;<BR>    }<BR>    <BR>    Bar* getBarObj() {<BR>        return m_barObj;<BR>    }<BR>protected:<BR>    Bar* m_barObj;  <BR>};</PRE><P>
   In our <CODE>FooBar</CODE> class we have a member <CODE>m_barObj</CODE> 
   which is a pointer to some instance of class <CODE>Bar</CODE>.&nbsp; 
   In this class we have a strong reference to the Bar instance, and 
   want to make sure that whatever else happens to the instance, it 
   stays valid until we no longer care about it. So lets modify our <CODE>setBarObj()</CODE> 
   method to reflect this:</P><PRE><B>void</B> setBarObj( Bar* bar ) {<BR>    if ( <B>NULL</B> != m_barObj ) {<BR>        m_barObj-&gt;release(); <I>//release() our hold on the object - we don't care about it anymore</I><BR>    }<BR>    m_barObj = bar;<BR>    if ( <B>NULL</B> != m_barObj ) {<BR>        m_barObj-&gt;addRef();  <I>//addref() to prevent the object from being deleted should someone else release() it</I><BR>    }<BR>}</PRE><P>
   So in the <CODE>setBarObj()</CODE> method we <CODE>release()</CODE> 
   our old instance that we no longer care about, assign the new value 
   to our member variable, and if it is a valid instance (non null), 
   then we take &quot;ownership&quot; of it by calling <CODE>addRef()</CODE> 
   on the instance.</P>
  <P>
   <SPAN STYLE="font-style : italic;font-weight : bold;font-size : 12.0pt;">Note</SPAN><SPAN STYLE="font-size : 12.0pt;">:</SPAN> 
   that this whole scheme is aimed at heap based objects. Many objects 
   that are created on the stack do not need this.</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;
 </BODY>
</HTML>