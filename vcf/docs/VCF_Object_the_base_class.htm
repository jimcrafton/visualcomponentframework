<HTML>
 <HEAD>
  <!-- $MVD$:app("RoboHELP HTML Edition by Blue Sky Software, portions by MicroVision Dev. Inc.","769") -->
  <!-- $MVD$:template("","0","0") -->
  <!-- $MVD$:color("18","b5edfb","Code Orange","1") -->
  <!-- $MVD$:color("19","ffefce","Custom #1","0") -->
  <!-- $MVD$:color("20","b58800","Custom #2","0") -->
  <!-- $MVD$:fontset("Trebuchet MS","Trebuchet MS") -->
  <TITLE>VCF::Object - the base class</TITLE>
  <META NAME="generator" CONTENT="RoboHELP by Blue Sky Software www.blue-sky.com HTML Edition">
  <SCRIPT LANGUAGE="javascript" TITLE="BSSC Special Effects" SRC="BSSCDHTM.js">
 </SCRIPT><LINK
  REL="StyleSheet" HREF="default.css"></HEAD>
  <BODY ONLOAD="BSSCOnLoad();" ONCLICK="BSSCOnClick();" ONUNLOAD="BSSCOnUnload();">
  <H1>
   <IMG SRC="vcflogo.gif" WIDTH="230" HEIGHT="172" VSPACE="0" HSPACE="0" BORDER="0"></H1>
  <H1>
   VCF::Object - the base class</H1>
  <P>
   The VCF is, by and large, a single rooted object hierarchy, the base 
   class of which is VCF::Object. This class provides several common 
   functions for us, as well as providing several method that can be 
   overridden by derived classes.</P>
  <P>
   The core methods are the following:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="21%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="79%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClassName()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a String that identifies the class name of the object.</TD>
    </TR>
    <TR>
     <TD WIDTH="21%" VALIGN=TOP>
      <P>
       getClass()</TD>
     <TD WIDTH="79%" VALIGN=TOP>
      <P>
       Returns a pointer to a Class object that identifies the Object's 
       runtime class information.</TD>
    </TR>
   </TABLE></P>
  <P>
   The core methods that can be overriden are:</P>
  <P>
   <TABLE WIDTH="100%" CELLPADDING="2" CELLSPACING="0" BORDER="0">
    <TR>
     <TD WIDTH="17%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Method</TD>
     <TD WIDTH="83%" BGCOLOR="GRAY" VALIGN=TOP>
      <P>
       Duty</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       hash()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns an unsigned long that represents the object's hash value. Can 
       be overriden to provide any number of hashing algorithms that return 
       some valid hash number</TD>
    </TR>
    <TR>
     <TD WIDTH="17%" VALIGN=TOP>
      <P>
       toString()</TD>
     <TD WIDTH="83%" VALIGN=TOP>
      <P>
       returns a String that represents the object. The default behavior 
       simply returns the pointer for the object's instance. Other 
       implementations may return state information, such as VCF::Rect, 
       which returns the bounds of the rectangle. Used primarily as a 
       debugging tool.</TD>
    </TR>
   </TABLE></P>
  <P>
   In addition, Object will also support refcounting for those who need 
   this kind of support. There are several places in the ApplicationKit 
   that will need to make use of this fairly soon. Also Object supports 
   a new technique for instantiating and destroying Object derived instances.</P>
  <P>
   In general, in C++, when creating a new instance on the heap 
   (free-store) you would use the operator <CODE>new()</CODE> function. 
   This is being phased out of the VCF for a variety of reasons, in 
   favor of a new (no pun intended) scheme. New classes should hide 
   their constructor's and destructor's, making them private or 
   protected. Proper object instantiation will now look like this:</P><PRE>FooObject* f = FooObject::create();<BR>//or if we needed to have a constructor that took an int...<BR><BR>FooObject* f = FooObject::create(12);<BR></PRE><P>
   <CODE>create()</CODE> is a static method that will need to put on 
   every class, and will be paired with each constructor of the class. 
   So if the class only needs a default constructor, then <CODE>create()</CODE> 
   is OK, if the class has a default constructor, a copy constructor, 
   and a constructor that takes a <CODE>String</CODE>, then there need 
   to be 3 <CODE>create()</CODE> methods, <CODE>create()</CODE>, <CODE>create(
    const class&amp; )</CODE>, and <CODE>create( String )</CODE>, and so forth.</P>
  <P>
   The pattern for implementing <CODE>create() </CODE>is as follows:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    create the object on the heap via the operator <CODE>new()</CODE> call</P>
   <LI CLASS="mvd-P">
   <P>
    call the new created object's <CODE>init()</CODE> method, which is virtual</P>
   <LI CLASS="mvd-P">
   <P>
    return the object to the caller.</P>
   </UL>
  <P>
   The <CODE>init() </CODE>method is intended to place common shared 
   startup code. Because of the desire to make it virtual it cannot be 
   called in the constructor, thus the use of the <CODE>create()</CODE> call.</P>
  <P>
   <CODE>init()</CODE> does not have to be implemented.</P>
  <P>
   To facilitate this there will be macros that do just this declared in <CODE>ClassInfo.h</CODE>.
    These macros will allow for <CODE>create()</CODE> methods with up to 
   six(6) arguments passed in. The macros will <SPAN STYLE="font-style : italic;font-weight : bold;">NOT</SPAN> 
   make the constructors for you, this is something that needs to be 
   done by hand, and should be visible so that you can see what is going 
   on. Using the Macros is optional.</P>
  <P>
   Destroying the memory can now happen in two ways:</P>
  <UL>
   <LI CLASS="mvd-P">
   <P>
    The first is the equivalent of the operator delete() call. This 
    involves calling the objects free() method, which will call the 
    virtual destroy() method before calling operator delete() on itself.</P>
   <LI CLASS="mvd-P">
   <P>
    The second way an object can be destroyed is if it's refcount drops 
    to 0, at which point the object's free() method will be invoked. 
    Calling the object's release() method decrements the reference count 
    on the object. Like init(), destroy() is a virtual method, where 
    common shared cleanup may take place, again due to the restrictions 
    of C++, virtual methods are not allowed in destructors, but we get 
    around this with the free()/destroy() pattern.</P>
   </UL>
  <P>
   Semantics for the usage of the <CODE>addRef()/release()</CODE> method 
   usage are as follows:</P>
  <H3>
   &lt;&lt;Documentation missing&gt;&gt;</H3>
  <P>
   <SPAN STYLE="font-style : italic;font-weight : bold;font-size : 12.0pt;">Note</SPAN><SPAN STYLE="font-size : 12.0pt;">:</SPAN> 
   that this whole scheme is aimed at heap based objects. Many objects 
   that are created on the stack do not need this, though if they have 
   code in their init() method, this will have to be called.</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;</P>
  <P>
   <!-- $MVD$:spaceretainer() -->&nbsp;
 </BODY>
</HTML>