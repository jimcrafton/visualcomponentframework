#ifndef _VCF_RECT_H__
#define _VCF_RECT_H__
//Rect.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */


namespace VCF{

#define RECT_CLASSID		"ED88C096-26AB-11d4-B539-00C04F0196DA"

/*
\class Rect Rect.h "vcf/GraphicsKit/Rect.h"
*a Rect class represents the four coordinates of a
*2 dimensional rectangle (left, top, right, and bottom). The
*values are stored as double for maximum precision.
*/
class GRAPHICSKIT_API Rect : public Object, public Persistable {
public:
	double bottom_;
	double right_;
	double top_;
	double left_;

public:

	Rect( const double & left, const double & top, const double & right, const double & bottom );

	Rect( const Rect& rect );

	Rect();

	double getLeft() const {
		return left_;
	};

	void setLeft( const double& left ){
		left_ = left;
	};

	double getTop() const {
		return top_;
	};

	void setTop( const double& top ){
		top_ = top;
	};

	double getRight() const {
		return right_;
	};

	void setRight( const double& right ){
		right_ = right;
	};

	double getBottom() const {
		return bottom_;
	};

	void setBottom( const double& bottom ){
		bottom_ = bottom;
	};

	/**
	*the width of the rectangle, or the value
	*returned from abs(right - left)
	*/
	double getWidth() const ;

	/**
	*the height of the rectangle, or the value
	*returned from abs(bottom - top)
	*/
	double getHeight() const ;

	/**
	*sets the left, top, right, and bottom all at once
	*/
	void setRect( const double & left, const double & top, const double & right, const double & bottom );
	void setRect( const Rect & rect );

	/**
	*sets the left, top, right, and bottom all at once using the two opposite corners
	*/
	void setRect ( const Point& topleft, const Point& bottomright );

	/**
	* gets a reference to this Rect instance itself.
	*to be used as conversion operator without introducing ambiguity between operators
	*/
	Rect& getRect(void);

	/**
	*changes the origin of a rectangle, i.e. its top left corner,
	*but not its size.
	*/
	void setOrigin(  const double& left, const double& top );
	void setOrigin( const Point& topleft );

	/**
	*changes the size of a rectangle, i.e. its width and its height,
	*but not its origin.
	*/
	void setSize(  const double& width, const double& height );
	void setWidth( const double& width );
	void setHeight( const double& height );

	/**
	*normalizes the rectangles coordinates so that
	*/
	void normalize();

	/**
	*tells if the rect is mormalized, i.e. if the top is
	*less than the bottom, and the left is less than the right.
	*/
	bool isNormalized() const;

	/**
	*tells if the rect is mormalized, i.e. if the top is
	*less than the bottom, and the left is less than the right.
	*/
	bool isEmpty() const;
	void setEmpty();

	bool isNull() const;
	void setNull();


	void offset( const double& dx, const double& dy );
	void offset( const Point& _offsetPt );

	/**
	*inflates the rectangle
	*@param double the amount to increase (or decrease if the value is negative)
	*the left and right coordinates
	*@param double the amount to increase (or decrease if the value is negative)
	*the top and bottom coordinates
	*/
	void inflate(const double & x, const double & y);

	/**
	*inflates the rectangle
	*@param double the amount to increase (or decrease if the value is negative)
	*for all the four edges
	*/
	void inflate( const double & left, const double & top, const double & right, const double & bottom );

	/**
	*inflates the rectangle
	*@param double the amount to increase (or decrease if the value is negative)
	*for all the four edges as given by a rectangle
	*/
	void inflate( const Rect& rect );

	void add( const Rect* rect );

	void subtract( const Rect* rect );

	/**
	*creates the Rect intersection of this instance with another rectangle
	*/
	Rect makeIntersection( const Rect* rect );

	/**
	*not implemented yet
	*/
	Rect makeUnion( const Rect* rect );

	Point getTopLeft(void) const;
	Point getTopRight(void) const;
	Point getBottomLeft(void) const;
	Point getBottomRight(void) const;

	Point getCenter(void) const;
	Point getCenterLeft(void) const;
	Point getCenterTop(void) const;
	Point getCenterRight(void) const;
	Point getCenterBottom(void) const;

	/**
	*tells if the point lay within this rectangle's coordinates
	*Any point on the top or on the left border of the rectangle 
	*is considered inside the rectangle.
	*@return bool, true if the point is within the rectangle's coordinates,
	*otherwise false
	*/
	bool containsPt( Point* point ) const;

	/**
	*tells if the point lay within this rectangle's coordinates
	*a given tolerance is admitted in order to consider the point inside the rectangle.
	*Again any point on the top or on the left border of the rectangle 
	*within the given tolerance is considered inside the rectangle.
	*/
	bool containsPtCloseTo( Point* point, const double& tolerance ) const;

	/**
	*tells if the point lay within this rectangle's coordinates
	*Any point on the border of the rectangle is <b>not</b> considered inside the rectangle.
	*/
	bool containsPtOpen( Point* point ) const;

	/**
	*tells if the point lay within this rectangle's coordinates
	*Any point on the border of the rectangle <b>is</b> considered inside the rectangle.
	*/
	bool containsPtClose( Point* point ) const;

	/**
	*tells if the specified rectangle fall inside the bound of this Rect instance.
	*/
	bool containsRect( Rect* rect ) const ;

	/**
	*tells if the specified rectangle fall inside the bound of this Rect instance.
	*This is always false though if a border of one rectangle is part of a border 
	*of the other rectangle.
	*/
	bool containsRectOpen( Rect* rect ) const ;

	/**
	*tells if the specified rectangle fall inside the bound of this Rect instance.
	*This is true even if a border of one rectangle is part of a border
	*of the other rectangle.
	*/
	bool containsRectClose( Rect* rect ) const ;

	// assignment operator
	Rect& operator= ( const Rect& rect );

	// comparison operators
	bool operator == ( const Rect& rectToCompare ) const;
	bool operator != ( const Rect& rectToCompare ) const;

	// unary operators
	Rect operator+ () const;
	Rect operator- () const;

	Rect& operator+= (const Rect& rc);
	Rect& operator-= (const Rect& rc);
	Rect& operator*= (const Rect& rc);
	Rect& operator/= (const Rect& rc);

	// binary operators
	Rect operator+ (const Rect& rc) const;
	Rect operator- (const Rect& rc) const;
	Rect operator* (const Rect& rc) const;
	Rect operator/ (const Rect& rc) const;

	// unary scalar operators
	Rect& operator+= (const double d);
	Rect& operator-= (const double d);
	Rect& operator*= (const double d);
	Rect& operator/= (const double d);

	// binary scalar operators
	Rect operator+ (const double d) const;
	Rect operator- (const double d) const;
	Rect operator* (const double d) const;
	Rect operator/ (const double d) const;


	/**
	*returns a String giving the infos about this Rect instance.
	*/
	virtual String toString() const;

	/**
	*writes the object to the specified output stream
	*/
	virtual void saveToStream( OutputStream * stream );

	/**
	*reads the object from the specified input stream
	*/
	virtual void loadFromStream( InputStream * stream );


	/**
	*This is only here because the RTTI functions are not "const safe" - kind of
	* stupid - will fix later.
	*/
	double _getLeft()   { return left_; };
	double _getTop()    { return top_; };
	double _getRight()  { return right_; };
	double _getBottom() { return bottom_; };
	double _getWidth()  { return fabs( right_ - left_ ); }
	double _getHeight() { return fabs( bottom_ - top_ ); };
};



///////////////////////////////////////////////////////////////////////////////
// inline implementation for Rect class

inline Rect::Rect( const double & left, const double & top, const double & right, const double & bottom ) {
	setRect( left, top, right, bottom );
}

inline Rect::Rect() {
	setRect( 0.0, 0.0, 0.0, 0.0 );
}

inline double Rect::getWidth() const {
	return fabs( right_ - left_ );
}

inline double Rect::getHeight() const {
	return fabs( bottom_ - top_ );
}

inline void Rect::setRect ( const Rect& rect ) {
	setRect( rect.left_, rect.top_, rect.right_, rect.bottom_ );
}

inline void Rect::setRect( const double & left, const double & top, const double & right, const double & bottom ) {
	left_   = left;
	right_  = right;
	top_    = top;
	bottom_ = bottom;
}

inline void Rect::setRect ( const Point& topleft, const Point& bottomright ) {
	setRect( topleft.x_, topleft.y_, bottomright.x_, bottomright.y_ );
}

inline Rect& Rect::getRect(void) {
	// conversion operator
	return ( *this );
}

inline void Rect::setNull() {
	setRect( 0.0, 0.0, 0.0, 0.0 );
}

inline bool Rect::isNull() const {
	return ( (left_ == 0.0) && (top_ == 0.0) && (right_ == 0.0) && (bottom_ == 0.0) );
}

inline void Rect::setEmpty() {
	setRect( left_, top_, left_, top_ );
}

inline bool Rect::isEmpty() const {
	return ( (getWidth() <= 0.0) || (getHeight() <= 0.0) );
}

inline bool Rect::isNormalized() const {
	return ( left_ <= right_ && top_ <= bottom_ );
}

inline void Rect::setOrigin(  const double& left, const double& top ){
	right_  += left - left_;
	bottom_ += top - top_;
	left_   = left;
	top_    = top;
};

inline void Rect::setOrigin( const Point& topleft ){
	right_  += topleft.x_ - left_;
	bottom_ += topleft.y_ - top_;
	left_   = topleft.x_;
	top_    = topleft.y_;
};

inline void Rect::setSize(  const double& width, const double& height ){
	right_  = left_ + width;
	bottom_ = top_ + height;
};

inline void Rect::setWidth( const double& width ){
	right_ = left_ + width;
};

inline void Rect::setHeight( const double& height ){
	bottom_ = top_ + height;
};

inline void Rect::offset( const double& dx, const double& dy ) {
	left_   += dx;
	right_  += dx;

	top_    += dy;
	bottom_ += dy;
}

inline void Rect::offset( const Point& _offsetPt ) {
	offset(_offsetPt.x_, _offsetPt.y_);
};

// assignment operator
inline Rect& Rect::operator= ( const Rect& rect ) {
	setRect( rect );
	return *this;
}

inline void Rect::inflate( const double & x, const double & y ) {
	left_   += (-x);
	right_  += x;

	top_    += (-y);
	bottom_ += y;
}

inline void Rect::inflate( const double & left, const double & top, const double & right, const double & bottom ) {
	left_   += (-left);
	right_  += right;
	top_    += (-top);
	bottom_ += bottom;
}

inline void Rect::inflate( const Rect& rect ) {
	left_   += (-rect.left_);
	right_  += rect.right_;
	top_    += (-rect.top_);
	bottom_ += rect.bottom_;
}

inline Point Rect::getTopLeft(void) const {
	return Point ( left_, top_ );
}

inline Point Rect::getTopRight(void) const {
	return Point ( right_, top_ );
}

inline Point Rect::getBottomLeft(void) const {
	return Point ( left_, bottom_ );
}

inline Point Rect::getBottomRight(void) const {
	return Point ( right_, bottom_ );
}

inline Point Rect::getCenter(void) const {
	return Point ( (left_ + right_) / 2 , (top_ + bottom_) / 2 );
}

inline Point Rect::getCenterLeft(void) const {
	return Point ( left_ , (top_ + bottom_) / 2 );
}

inline Point Rect::getCenterTop(void) const {
	return Point ( (left_ + right_) / 2 , top_ );
}

inline Point Rect::getCenterRight(void) const {
	return Point ( right_ , (top_ + bottom_) / 2 );
}

inline Point Rect::getCenterBottom(void) const {
	return Point ( (left_ + right_) / 2 , bottom_ );
}

// comparison operators
inline bool Rect::operator == ( const Rect& rectToCompare ) const {
	return ( (bottom_ == rectToCompare.bottom_) &&
		       (right_  == rectToCompare.right_) &&
		       (top_    == rectToCompare.top_) &&
		       (left_   == rectToCompare.left_) );
}

inline bool Rect::operator != ( const Rect& rectToCompare ) const {
	return ( ! operator ==( rectToCompare ) );
}

// unary operators
inline Rect Rect::operator+ () const {
	return *this;
}

inline Rect Rect::operator- () const {
	Rect rc (-left_, -top_, -right_, -bottom_);
	return rc;
}

inline Rect& Rect::operator+= (const Rect& rc) {
	left_ += rc.left_;
	top_ += rc.top_;
	right_ += rc.right_;
	bottom_ += rc.bottom_;
	return *this;
}

inline Rect& Rect::operator-= (const Rect& rc) {
	left_ -= rc.left_;
	top_ -= rc.top_;
	right_ -= rc.right_;
	bottom_ -= rc.bottom_;
	return *this;
}

inline Rect& Rect::operator*= (const Rect& rc) {
	left_ *= rc.left_;
	top_ *= rc.top_;
	right_ *= rc.right_;
	bottom_ *= rc.bottom_;
	return *this;
}

inline Rect& Rect::operator/= (const Rect& rc) {
	left_ /= rc.left_;
	top_ /= rc.top_;
	right_ /= rc.right_;
	bottom_ /= rc.bottom_;
	return *this;
}


// binary operators
inline Rect Rect::operator+ (const Rect& rc) const {
	Rect rs = *this;
	rs += rc;
	return rs;
}

inline Rect Rect::operator- (const Rect& rc) const {
	Rect rs = *this;
	rs -= rc;
	return rs;
}

inline Rect Rect::operator* (const Rect& rc) const {
	Rect rs = *this;
	rs *= rc;
	return rs;
}

inline Rect Rect::operator/ (const Rect& rc) const {
	Rect rs = *this;
	rs /= rc;
	return rs;
}


// unary scalar operators
inline Rect& Rect::operator+= (const double d) {
	left_ += d;
	top_ += d;
	right_ += d;
	bottom_ += d;
	return *this;
}

inline Rect& Rect::operator-= (const double d) {
	left_ -= d;
	top_ -= d;
	right_ -= d;
	bottom_ -= d;
	return *this;
}

inline Rect& Rect::operator*= (const double d) {
	left_ *= d;
	top_ *= d;
	right_ *= d;
	bottom_ *= d;
	return *this;
}

inline Rect& Rect::operator/= (const double d) {
	left_ /= d;
	top_ /= d;
	right_ /= d;
	bottom_ /= d;
	return *this;
}

// binary scalar operators
inline Rect Rect::operator+ (const double d) const {
	Rect rs = *this;
	rs += d;
	return rs;
}

inline Rect Rect::operator- (const double d) const {
	Rect rs = *this;
	rs -= d;
	return rs;
}

inline Rect Rect::operator* (const double d) const {
	Rect rs = *this;
	rs *= d;
	return rs;
}

inline Rect Rect::operator/ (const double d) const {
	Rect rs = *this;
	rs /= d;
	return rs;
}


}; // namespace VCF


#endif // _VCF_RECT_H__

/**
$Id$
*/
