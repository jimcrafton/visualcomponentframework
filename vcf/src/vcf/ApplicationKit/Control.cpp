//Control.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/Action.h"
#include "vcf/ApplicationKit/ActionEvent.h"


using namespace VCF;

Control* Control::capturedMouseControl = NULL;
Control* Control::currentFocusedControl = NULL;
Control* Control::previousMouseOverControl = NULL;

Control::Control():
	peer_(NULL),
	context_(NULL),
    parent_(NULL),
    aligment_(AlignNone),
	anchor_(AnchorNone),
    bounds_(NULL),
	clientBounds_(NULL),
	border_(NULL),
	color_(NULL),
	font_(NULL),
	view_(NULL),
	useParentFont_(false),
	doubleBuffered_(true),
	hasMouseCapture_(false),
	autoStartDragDrop_(false),
	popupMenu_(NULL),
	scrollable_(NULL),
	cursorID_(0),
	cursor_(NULL),
	tabStop_(true),
	tabOrder_(-1),
	useRenderBuffer_(false),
	container_(NULL)
{
	font_ = new Font( UIToolkit::getUIMetricsManager()->getDefaultFontFor( UIMetricsManager::ftControlFont ) );	//the cast is to  avoid internal compiler error on some vc6 versions

	context_ = new ControlGraphicsContext( this );

	bounds_ = new Rect();
	clientBounds_ = new Rect();
	color_ = new Color;

	setCursorID( (long)Cursor::SCT_DEFAULT );

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_FACE ) );

	viewControl_ = this;

	anchorDeltas_[ANCHOR_DTOP] = 0.0f;
	anchorDeltas_[ANCHOR_DLEFT] = 0.0f;
	anchorDeltas_[ANCHOR_DBOTTOM] = 0.0f;
	anchorDeltas_[ANCHOR_DRIGHT] = 0.0f;
}

Control::~Control()
{

}

void Control::destroy()
{

	if ( this->isLightWeight() ) {
		//have to handle a Component::COMPONENT_DELETED event manually
		//as they will NOT recv notification from the underlying windowing system
		VCF::ComponentEvent event( this, Component::COMPONENT_DELETED );
		handleEvent( &event );
	}


	if ( NULL != peer_ ) {
		UIToolkit::removeAcceleratorKeysForControl( this );
	}

	if ( this == Control::previousMouseOverControl ) {
		Control::previousMouseOverControl = NULL;
	}

	delete bounds_;
	bounds_ = NULL;
	delete clientBounds_;
	clientBounds_ = NULL;
	delete color_;
	color_ = NULL;

	delete context_;
	context_ = NULL;

	if ( NULL != peer_ ) {
		peer_->destroyControl();
		delete peer_;
		peer_ = NULL;
	}
	if ( NULL != border_ ){
		border_->release();
		border_ = NULL;
	}

	if ( NULL != font_ ){
		font_->free();
		font_ = NULL;
	}

	if ( this == Control::currentFocusedControl ) {
		Control::currentFocusedControl = NULL;
	}

	if ( NULL != view_ ) {
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->release();
		}
		else {
			delete view_;
		}
	}
	view_ = NULL;

	if ( NULL != container_ ) {
		Object* obj = dynamic_cast<Object*>(container_);
		if ( NULL != obj ) {
			obj->release();
		}
		else {
			delete container_;
		}
	}
	container_ = NULL;

	Component::destroy();
}

Border* Control::getBorder()
{
	return border_;
}

void Control::setBorder( Border* border )
{
	if ( NULL != border_ ){
		border_->release();
		border_ = NULL;
	}
	border_ = border;
	if ( NULL != border_ ){
		border_->addRef();
	}

	peer_->setBorder( border_ );
}

Rect Control::getBounds()/**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}




	Control* parent = getParent();
	bool lightweightParent = false;
	if ( NULL != parent ) {
		lightweightParent = parent->isLightWeight();
	}

	if ( lightweightParent && !isLightWeight() ) {
		*bounds_ = peer_->getBounds();

		Rect tmpBounds = *bounds_;

		tmpBounds.offset( -tmpBounds.left_, -tmpBounds.top_ );

		translateToScreenCoords( &tmpBounds );

		parent->translateFromScreenCoords( &tmpBounds );

		*bounds_ =  tmpBounds;
	}
	else {
		*bounds_ = peer_->getBounds();
		//peer_->setBounds( bounds_ );
	}
	return *bounds_;
}




Rect Control::getClientBounds( const bool& includeBorder ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	Rect r = peer_->getBounds();
	clientBounds_->setRect( 0.0, 0.0, r.getWidth(), r.getHeight() );

	if ( (true == includeBorder) && (NULL != border_) ){
		r = *clientBounds_;
		*clientBounds_ = border_->getClientRect( &r, this );
	}

	return *clientBounds_;
}

double Control::getLeft() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	//*bounds_ = peer_->getBounds();
	getBounds();

	return bounds_->left_;
}

double Control::getRight()
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->right_;
}

double Control::getBottom() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->bottom_;
}

double Control::getWidth() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->getWidth();
}

double Control::getTop() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->top_;
}

double Control::getHeight() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	//double result = 0.0;

	getBounds();
	//*bounds_ = peer_->getBounds();
	//result = bounds_->getHeight();


	return bounds_->getHeight();
}

bool Control::getVisible() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	return peer_->getVisible();
}

AlignmentType Control::getAlignment()
{
	return aligment_;
}

void Control::setBounds( const double& x, const double& y, const double& width, const double& height )
{
	setBounds( &Rect( x, y, x+width, y+height ) );
}

void Control::setBounds( Rect* rect, const bool& anchorDeltasNeedUpdating ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};


	*bounds_ = *rect;

	/**
	Adjust the bounds to take into account a
	potentially lightweight parent
	*/
	Control* parent = getParent();
	bool lightweightParent = false;
	if ( NULL != parent ) {
		lightweightParent = parent->isLightWeight();
	}

	if ( lightweightParent && !isLightWeight() ) {
		Control* realParent = parent;
		while ( NULL != realParent ) {
			if ( !realParent->isLightWeight() ) {
				break;
			}
			realParent = realParent->getParent();
		}

		if ( NULL != realParent ) {


			Rect tmp = *bounds_;
			Rect tmp2 = *bounds_;

			tmp.offset( -tmp.left_, -tmp.top_ );

			parent->translateToScreenCoords( &tmp );

			realParent->translateFromScreenCoords( &tmp );

			tmp2.offset( tmp.left_, tmp.top_ );

			*bounds_ = tmp2;

			peer_->setBounds( &tmp2 );
		}
		else {
			peer_->setBounds( bounds_ );
		}
	}
	else {
		peer_->setBounds( bounds_ );
	}

	if ( true == anchorDeltasNeedUpdating ) {
		updateAnchorDeltas();
	}
}

void Control::setAlignment( const AlignmentType& alignment )
{
	aligment_ = alignment;
	/**
	Fix submitted by Marcello - see bug [ 789945 ] Control::setAlignment() does not allow only one align style
	*/
	if ( aligment_ != AlignNone ) {
		anchor_ = AnchorNone;
	}

	Control* parent = getParent();
	if ( NULL != parent ){
		Container* container = parent->getContainer();
		if ( NULL != container ){
			container->resizeChildren(NULL);//this);
		}
	}

	updateAnchorDeltas();
}

void Control::setLeft( const double& left ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};


	double dx = bounds_->getWidth();
	bounds_->left_ = left;
	bounds_->right_ = left + dx;
	setBounds( bounds_ );
}

void Control::setRight( const double& right ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	bounds_->right_ = right;
	setBounds( bounds_ );
}

void Control::setWidth( const double& width ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};


	bounds_->right_ = bounds_->left_ + width;
	setBounds( bounds_ );
}

void Control::setTop( const double& top ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	double dy = bounds_->getHeight();
	bounds_->top_ = top;
	bounds_->bottom_ = top + dy;
	setBounds( bounds_ );
}

void Control::setBottom( const double& bottom ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	bounds_->bottom_ = bottom;
	setBounds( bounds_ );
}

void Control::setHeight( const double& height ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	if ( NULL != peer_ ){
		bounds_->bottom_ = bounds_->top_ + height;
		setBounds( bounds_ );
	};
}

void Control::setVisible( const bool& visible ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	bool oldVisible = peer_->getVisible();

	if ( oldVisible != visible ) {
		peer_->setVisible( visible );
		Control* parent = getParent();
		if ( NULL != parent ) {
			Container* container = parent->getContainer();
			if ( NULL != container ) {
				if ( visible ) { //(oldVisible == false) && (true == visible) ) {
					container->resizeChildren(NULL);//this);
				}
				else {
					container->resizeChildren(NULL);
				}
			}
		}
	}
}

void Control::handleEventAndForwardToChildren( Event* event )
{
	handleEvent( event );
	Container* container = getContainer();
	if ( NULL != container && (!event->isConsumed())) {
		Enumerator<Control*>* children = container->getChildren();
		while ( children->hasMoreElements() )  {
			Control* child = children->nextElement();
			child->handleEventAndForwardToChildren( event );
			if ( event->isConsumed() ) {
				break;
			}
		}
	}

}

void Control::handleEvent( Event* event )
{
	Component::handleEvent( event );
	if ( NULL != event ){
		unsigned long eventType = event->getType();

		switch ( eventType ){
			case Action::UpdateEvent : {
				ActionEvent* actionEvent = (ActionEvent*)event;

				setEnabled( actionEvent->isEnabled() );
			}
			break;

			case CONTROL_SIZED:{
				ControlEvent* controlEvent = (ControlEvent*)event;

				//bounds_->right_ = bounds_->left_ + controlEvent->getNewSize().width_;
				//bounds_->bottom_ = bounds_->top_ + controlEvent->getNewSize().height_;
				ControlSized.fireEvent( (ControlEvent*)event );

				if ( useRenderBuffer_ ) {
					Rect bounds = getClientBounds();

					context_->setDrawingArea( bounds );
				}
			}
			break;

			case CONTROL_POSITIONED:{
				ControlEvent* controlEvent = (ControlEvent*)event;
				//double w = bounds_->getWidth();
				//double h = bounds_->getHeight();

				//bounds_->left_ = controlEvent->getNewPosition().x_;
				//bounds_->top_ = controlEvent->getNewPosition().y_;
				//bounds_->right_ = bounds_->left_ + w;
				//bounds_->bottom_ = bounds_->top_ + h;

				ControlPositioned.fireEvent( controlEvent );
			}
			break;

			case CONTROL_PARENT_CHANGED:{
				ControlParentChanged.fireEvent( (ControlEvent*)event );
			}
			break;

			case MOUSE_ENTERED:{
				MouseEvent* mouseEvent = (MouseEvent*)event;


				MouseEnter.fireEvent( mouseEvent );
				if (!event->isConsumed()) {
					mouseEnter( mouseEvent );
				}
			}
			break;

			case MOUSE_DOWN:{
				MouseEvent* mouseEvent = (MouseEvent*)event;

				clickPt_ = *mouseEvent->getPoint();
				

				MouseDown.fireEvent( mouseEvent );
				if (!event->isConsumed()) {
					mouseDown( mouseEvent );
				}
			}
			break;

			case MOUSE_MOVE:{
				MouseEvent* mouseEvent = (MouseEvent*)event;

				if (mouseEvent->hasLeftButton() || mouseEvent->hasRightButton() || mouseEvent->hasMiddleButton() ) {
					if ( (true == autoStartDragDrop_) ) { //&& (false == dragDropStarted_) ) {
						if ( true == canBeginDragDrop( mouseEvent->getPoint() ) ) {
							//dragDropStarted_ = true;

							if ( beginDragDrop ( mouseEvent ) ) {
								return;
							}
						}
					}
				}
				
				peer_->setCursor( cursor_ );
				MouseMove.fireEvent( mouseEvent );
				if (!event->isConsumed()) {
					mouseMove( mouseEvent );
				}
			}
			break;

			case MOUSE_UP:{

				MouseEvent*  mouseEvent = (MouseEvent*)event;

				Point tmpPt = *mouseEvent->getPoint();


				bool rightBtn = mouseEvent->hasRightButton();
				MouseUp.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed()) {
					mouseUp( mouseEvent );
				}
				if ( (NULL != popupMenu_) && (true == rightBtn) ){
					Point tmpPt = *mouseEvent->getPoint();
					if ( NULL != scrollable_ ) {
						tmpPt.x_ -= scrollable_->getHorizontalPosition();
						tmpPt.y_ -= scrollable_->getVerticalPosition();
					}

					
					popupMenu_->popup( &tmpPt );
				}


				if ( clickPt_.closeTo( tmpPt.x_, tmpPt.y_, 2 ) ){

					
					MouseEvent clickEvent( this,
											MOUSE_CLICK,
											mouseEvent->getButtonMask(),
											mouseEvent->getKeyMask(),
											mouseEvent->getPoint() );


					handleEvent( &clickEvent );
				}

			}
			break;

			case MOUSE_LEAVE:{
				MouseEvent*  mouseEvent = (MouseEvent*)event;


				MouseLeave.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed()) {
					mouseLeave( mouseEvent );
				}
			}
			break;

			case MOUSE_CLICK:{
				
				MouseEvent*  mouseEvent = (MouseEvent*)event;
				MouseClicked.fireEvent( mouseEvent );
				mouseClick( mouseEvent );
			}
			break;

			case MOUSE_DBLCLICK:{
				MouseEvent*  mouseEvent = (MouseEvent*)event;

				MouseDoubleClicked.fireEvent( mouseEvent );
				mouseDblClick( mouseEvent );
			}
			break;

			case KEYBOARD_DOWN:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				keyDown( kbEvent );
				KeyDown.fireEvent( kbEvent );
			}
			break;

			case KEYBOARD_PRESSED:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				keyPressed( kbEvent );
				KeyPressed.fireEvent( kbEvent );
			}
			break;

			case KEYBOARD_UP:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				keyUp ( kbEvent );
				KeyUp.fireEvent( kbEvent );
			}
			break;

			case FOCUS_LOST:{
				FocusEvent* focusEvent = (FocusEvent*)event;

				//StringUtils::traceWithArgs( "Control::FOCUS_LOST, this[%s]@ %p\n",
				//					getClassName().c_str(), this );

				FocusLost.fireEvent( focusEvent );

			}
			break;

			case FOCUS_GAINED:{
				FocusEvent* focusEvent = (FocusEvent*)event;

				//StringUtils::traceWithArgs( "Control::FOCUS_GAINED, this[%s]@ %p\n",
				//					getClassName().c_str(), this );

				FocusGained.fireEvent( focusEvent );

			}
			break;
		}
		//if ( !mouseEvent->isConsumed() )
			//mouseEvent->setConsumed(true);
	}
}


bool Control::canBeginDragDrop( Point* point )
{
	bool result = false;

	Size dragDropDelta = UIToolkit::getDragDropDelta();

	//clickPt_ gets set on a mousedown
	//so make a rect around it
	Rect r( clickPt_.x_ - dragDropDelta.width_ /2.0,
			clickPt_.y_ - dragDropDelta.height_ /2.0,
			clickPt_.x_ + dragDropDelta.width_ /2.0,
			clickPt_.y_ + dragDropDelta.height_ /2.0 );

	//we are only ready to to begin a drag drop operation
	//if the point is NOT, I repeat, NOT, within the bounds of the
	//drag-drop rect. This prevents us from starting too early.
	//changing the dragDropDelta value allows us to control the 
	//sensitivity of how we reacto to drag-drop starts
	result = !r.containsPt( point );

	return result;
}

void Control::setAutoStartDragDrop(const bool& canAutoStartDragDrop)
{
	autoStartDragDrop_ = canAutoStartDragDrop;
}

bool Control::getAutoStartDragDrop()
{
	return autoStartDragDrop_;
}

bool Control::beginDragDrop( MouseEvent* event )
{
	return false;
}

ControlPeer* Control::getPeer()
{
	return peer_;
}

void Control::setParent( Control* parent ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	if ( parent != parent_ ) {
		ControlEvent event( this, parent );
		ControlParentChanged.fireEvent( &event );
	}

	parent_ = parent;
	peer_->setParent( parent );


	if ( NULL != parent_ ) {

		parent->addComponent( this );

		if ( parent_->isLightWeight() && !isLightWeight() ) {

			Rect tmp = peer_->getBounds();
			Rect tmp2 = tmp;
			tmp.offset( -tmp.left_, -tmp.top_ );

			translateToScreenCoords( &tmp );
			parent->translateFromScreenCoords( &tmp );

			tmp2.offset( tmp2.left_ - tmp.left_, tmp2.top_ - tmp.top_ );

			*bounds_ = tmp2;
			peer_->setBounds( &tmp2 );
		}
	}

	updateAnchorDeltas();
}

Control* Control::getParent() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	return parent_;
}

bool Control::isFocused()
{
	bool result = (this == currentFocusedControl);

	return result;//peer_->isFocused();
}

Control* Control::setFocused()
{
	Control* result = NULL;

	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	}

	if ( isNormal() || isCreated() || isDesigning() ) {	//JC added this so that a control recv's focus
														//only under these conditions

			if ( NULL != currentFocusedControl ) {
				if ( this != currentFocusedControl ) {
					//currentFocusedControl->setFocus( false ); //is this neccessary ?

					// do this to get the non focused control to repaint it's state
					currentFocusedControl->repaint();
				}
			}

		result = currentFocusedControl;
		currentFocusedControl = this;

		peer_->setFocused();
	}

	repaint();

	return result;
}

bool Control::isEnabled()
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	return peer_->isEnabled();
}

void Control::setEnabled( const bool& enabled )
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	peer_->setEnabled( enabled );
}

void Control::mouseEnter( MouseEvent* event )
{

}

void Control::mouseDown( MouseEvent* event )
{
	setFocused();
}

void Control::mouseMove( MouseEvent* event )
{
	//probably want to put a modifier here for the scrollable to modify the coords ?

}

void Control::mouseUp( MouseEvent* event )
{

}

void Control::mouseLeave( MouseEvent* event )
{

}

void Control::keyDown( KeyboardEvent* event )
{

}

void Control::mouseClick(  MouseEvent* event )
{

}

void Control::mouseDblClick(  MouseEvent* event )
{

}

void Control::keyPressed( KeyboardEvent* event )
{

}

void Control::keyUp( KeyboardEvent* event )
{

}

void Control::translateToParent( Point* point )
{
	Control* parent = getParent();
	if ( NULL != parent ){
		Rect bounds = parent->getBounds();
		point->x_ += bounds.left_;
		point->y_ += bounds.top_;
	}
	else{
		//throw exception ?
	}
}

void Control::translateToLocal( Point* point )
{
	Control* parent = getParent();
	if ( NULL != parent ){
		Rect bounds = getBounds();
		point->x_ -= bounds.left_;
		point->y_ -= bounds.top_;
	}
	else{
		//throw exception ?
	}
}

void Control::beforeDestroy( ComponentEvent* event )
{
	Component::beforeDestroy( event );
}

bool Control::isLightWeight()
{
	return false;
}

Control* Control::getHeavyweightParent()
{
	Control* parent = NULL;
	Control* result = NULL;
	result = getParent();
	if ( result != NULL ) {
		while ( true == result->isLightWeight() ){
			parent = result;
			result = parent->getParent();
		}
	}

	return result;
}

Color* Control::getColor()
{
	return color_;
}

void Control::setColor( Color* color )
{
	color_->copy( color );
}


Font* Control::getFont()
{
	return font_;
}

void Control::setFont( Font* font )
{
	if ( NULL != font ){
		font_->copy( font );
	}
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	peer_->setFont( font_ );

}

bool Control::useParentFont()
{
	return useParentFont_;
}

void Control::setUseParentFont( const bool& useParentFont )
{
	useParentFont_ = useParentFont;
}

void Control::afterCreate( ComponentEvent* event )
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	peer_->setFont( font_ );
}

void Control::repaint( Rect* repaintRect )
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	peer_->repaint( repaintRect );
	if ( useRenderBuffer_ ) {
		context_->markRenderAreaDirty();
	}
}

bool Control::isDoubleBuffered()
{
	return doubleBuffered_;
}

void Control::setDoubleBuffered( const bool& doubleBuffered )
{
	doubleBuffered_ = doubleBuffered;
}

void Control::keepMouseEvents()
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	hasMouseCapture_ = true;
	Control::setCapturedMouseControl( this );
	peer_->keepMouseEvents();
}

void Control::releaseMouseEvents()
{
	if ( NULL == peer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};
	hasMouseCapture_ = false;
	Control::setCapturedMouseControl( NULL );
	peer_->releaseMouseEvents();
}

Control* Control::getCapturedMouseControl()
{
	return Control::capturedMouseControl;
}

void Control::setCapturedMouseControl( Control* control )
{
	Control::capturedMouseControl = control;
}

GraphicsContext* Control::getContext()
{
	return context_;
}

PopupMenu* Control::getPopupMenu()
{
	return popupMenu_;
}

void Control::setPopupMenu( PopupMenu* popupMenu )
{
	if ( NULL != popupMenu_ ){
		popupMenu_->setControl( NULL );
	}

	popupMenu_ = popupMenu;

	if ( NULL != popupMenu_ ){
		popupMenu_->setControl( this );
	}
}

View* Control::getView()
{
	return view_;
}

void Control::setView( View* view )
{
	if ( NULL != view_ ) {
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->release();
		}
	}

	view_ = view;

	if ( NULL != view_ ) {
		view_->setViewControl( this );
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->addRef();
		}
	}
}

void Control::setScrollable( Scrollable* scrollable )
{
	scrollable_ = scrollable;
	if ( NULL != scrollable_ ) {
		scrollable_->setScrollableControl( this );
		scrollable_->recalcScrollPositions();
	}
}

void Control::processWhatsThisHelpEvent()
{
	WhatsThisHelpEvent event( this, whatThisHelpString_ );
	ControlHelpRequested.fireEvent( &event );
}

void Control::setToolTipText( const String& tooltip )
{
	toolTip_ = tooltip;
}

void Control::setCursorID( const long& cursorID )
{
	cursor_ = CursorManager::getCursorManager()->getCursor( cursorID );
}

void Control::setAnchor( const unsigned long& anchor )
{
	anchor_ = anchor;
	aligment_ = AlignNone;
	updateAnchorDeltas();

	Control* parent = getParent();
	if ( NULL != parent ){
		Container* container = parent->getContainer();
		if ( NULL != container ){
			container->resizeChildren(NULL);//this);
		}
	}
}

void Control::updateAnchorDeltas() {
	if ( AnchorNone == anchor_ ) {
		anchorDeltas_[ANCHOR_DTOP] = 0.0f;
		anchorDeltas_[ANCHOR_DLEFT] = 0.0f;
		anchorDeltas_[ANCHOR_DBOTTOM] = 0.0f;
		anchorDeltas_[ANCHOR_DRIGHT] = 0.0f;
	}
	else {
		Control* parent = getParent();
		if ( NULL != parent ) {
			Rect parentBounds = parent->getClientBounds();
			Rect bounds = getBounds();
			anchorDeltas_[ANCHOR_DTOP] = (float) bounds.top_;
			anchorDeltas_[ANCHOR_DLEFT] = (float) bounds.left_;
			anchorDeltas_[ANCHOR_DBOTTOM] = (float) parentBounds.bottom_ -  bounds.bottom_;
			anchorDeltas_[ANCHOR_DRIGHT] = (float) parentBounds.right_ -  bounds.right_;
		}
	}
}

AcceleratorKey* Control::getAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask )
{
	return UIToolkit::getAccelerator( keyCode, modifierMask );
}

void Control::addAcceleratorKey( const VirtualKeyCode& keyCode, const ulong32& modifierMask, EventHandler* eventHandler )
{
	if ( NULL == eventHandler ) {
		throw InvalidPointerException( MAKE_ERROR_MSG_2("The Event handler passed in is NULL!") );
	}

	AcceleratorKey* newAccelKey = new AcceleratorKey( this, keyCode, modifierMask, eventHandler );

	addAcceleratorKey( newAccelKey );
}

void Control::addAcceleratorKey( AcceleratorKey* accelerator )
{
	UIToolkit::registerAccelerator( accelerator );
}

void Control::setTabStop( const bool& tabStop )
{
	tabStop_ = tabStop;
}

void Control::setTabOrder( const long& tabOrder )
{
	if ( tabOrder_ == tabOrder ) {
		return ;
	}

	Control* parent = getParent();
	if ( NULL != parent ) {
		Container* container = parent->getContainer();
		if ( NULL != container ) {
			ulong32 tmp = tabOrder;
			container->updateTabOrder( this, tmp );

			tabOrder_ = tmp;
		}
	}
}


Control* Control::getCurrentFocusedControl()
{
	return Control::currentFocusedControl;
}

void Control::mnemonicActivate()
{
	setFocused();
}

Control* Control::getPreviousMouseOverControl()
{
	return Control::previousMouseOverControl;
}

void Control::setPreviousMouseOverControl( Control* control )
{
	Control::previousMouseOverControl = control;
}


void Control::translateToScreenCoords( Point* pt )
{
	peer_->translateToScreenCoords( pt );
}

void Control::translateToScreenCoords( Rect* rect )
{
	Point pt ( rect->left_, rect->top_ );

	peer_->translateToScreenCoords( &pt );
	rect->left_ = pt.x_;
	rect->top_ = pt.y_;

	pt.x_ = rect->right_;
	pt.y_ = rect->bottom_;

	peer_->translateToScreenCoords( &pt );

	rect->right_ = pt.x_;
	rect->bottom_ = pt.y_;
}

void Control::translateFromScreenCoords( Point* pt )
{
	peer_->translateFromScreenCoords( pt );
}

void Control::translateFromScreenCoords( Rect* rect )
{
	Point pt ( rect->left_, rect->top_ );

	peer_->translateFromScreenCoords( &pt );
	rect->left_ = pt.x_;
	rect->top_ = pt.y_;

	pt.x_ = rect->right_;
	pt.y_ = rect->bottom_;

	peer_->translateFromScreenCoords( &pt );

	rect->right_ = pt.x_;
	rect->bottom_ = pt.y_;
}

void Control::setContainer( Container* container )
{
	if ( NULL != container_ ) {
		Object* obj = dynamic_cast<Object*>(container_);
		if ( NULL != obj ) {
			obj->release();
		}
	}
	container_ = container;

	if ( NULL != container_ ) {
		Object* obj = dynamic_cast<Object*>(container_);
		if ( NULL != obj ) {
			obj->addRef();
		}

		container_->setContainerControl( this );
	}

}

void Control::buildTabList( Control* control, std::vector<Control*>& tabList )
{
	tabList.push_back( control );

	Container* container = control->getContainer();
	if ( NULL != container ) {
		container->getTabList( tabList );
	}
}

Frame* Control::getParentFrame()
{
	Control* result = NULL;

	Control* parent = getParent();
	while ( parent != NULL ) {
		result = parent;
		parent = result->getParent();
	}

	if ( NULL == result ) {
		result = this;
	}

	return (Frame*)result;
}

bool Control::canAcceptFocus()
{
	bool result = true;

	if ( isEnabled() ) {
		Control* parent = getParent();
		while ( parent != NULL ) {
			if ( !parent->isEnabled() ) {
				result = false;
				break;
			}
			parent = parent->getParent();
		}
	}
	else {
		result = false;
	}

	return result;
}

void Control::adjustViewableBoundsAndOriginForScrollable( GraphicsContext* context, Rect& viewBounds, Point& origin )
{
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		Rect innerBounds = getClientBounds(true);

		Point scrollPos;
		scrollPos.x_ = scrollable->getHorizontalPosition();
		scrollPos.y_ = scrollable->getVerticalPosition();

		//clip for border
		viewBounds.left_ = maxVal<>( innerBounds.left_+1,viewBounds.left_ );
		viewBounds.top_ = maxVal<>( innerBounds.top_+1,viewBounds.top_ );

		viewBounds.right_ = minVal<>( innerBounds.right_-1.0,viewBounds.right_ );
		viewBounds.bottom_ = minVal<>( innerBounds.bottom_-1.0,viewBounds.bottom_ );

		UIMetricsManager* mgr = UIToolkit::getUIMetricsManager();

		double dx = scrollable->getVirtualViewWidth() - innerBounds.getWidth();
		double dy = scrollable->getVirtualViewHeight() - innerBounds.getHeight();

		origin.x_ -= scrollPos.x_;
		origin.y_ -= scrollPos.y_;

		//offset the viewBounds by the scrollable's offset
		viewBounds.offset( scrollPos.x_, scrollPos.y_ );

		if ( scrollable->hasHorizontalScrollBar() && (scrollable->getVirtualViewWidth() > innerBounds.getWidth()) ) {
			Size horzSize = mgr->getDefaultHorizontalScrollButtonDimensions();

			//viewBounds.bottom_ = minVal<>( viewBounds.bottom_-horzSize.height_,viewBounds.bottom_ );

			if ( dx < scrollPos.x_ ) {
				origin.x_ -= ( dx - scrollPos.x_ );

				viewBounds.offset( dx - scrollPos.x_, 0 );
			}
		}
		else {
			Size horzSize = mgr->getDefaultHorizontalScrollButtonDimensions();

			//viewBounds.bottom_ = minVal<>( viewBounds.bottom_-horzSize.height_,viewBounds.bottom_ );

			origin.x_ += scrollPos.x_;
			viewBounds.offset( scrollPos.x_, 0 );

			if ( scrollPos.x_ > 0 ) {
				scrollable->setHorizontalPosition( 0 );
			}
		}


		if ( scrollable->hasVerticalScrollBar() && (scrollable->getVirtualViewHeight() > innerBounds.getHeight()) ) {
			Size vertSize = mgr->getDefaultVerticalScrollButtonDimensions();

			//viewBounds.right_ = minVal<>( viewBounds.right_-vertSize.width_,viewBounds.right_ );

			if ( dy < scrollPos.y_ ) {
				origin.y_ -= ( dy - scrollPos.y_ );
				viewBounds.offset( 0, dy - scrollPos.y_ );
			}
		}
		else {
			Size vertSize = mgr->getDefaultVerticalScrollButtonDimensions();

			//viewBounds.right_ = minVal<>( viewBounds.right_-vertSize.width_,viewBounds.right_ );

			origin.y_ += scrollPos.y_;
			viewBounds.offset( 0, scrollPos.y_ );


			if ( scrollPos.y_ > 0 ) {
				scrollable->setVerticalPosition( 0 );
			}
		}


	}
}


bool Control::isActive()
{
	Frame* parentFrame = getParentFrame();
	return (parentFrame == Frame::getActiveFrame()) && (parentFrame->isActiveFrame());
}

void Control::setViewModel( Model* viewModel )
{
	AbstractView::setViewModel( viewModel );
	ControlEvent event( this, Control::CONTROL_MODELCHANGED );
	ControlModelChanged.fireEvent(&event);
}


/**
*CVS Log info
*$Log$
*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*
*Revision 1.2  2004/08/07 02:49:06  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.8  2004/07/23 04:20:56  ddiego
*more checkins
*
*Revision 1.1.2.7  2004/07/22 04:18:58  ddiego
*fixed bug 995642 delete LoalePeer in Locale, and added some miscellaneous changes to the QTPlayer. Also fixing (not finished yet) a bug that
*prevents the TreePeer from being properly notified when the tree model's
*item is deleted.
*
*Revision 1.1.2.6  2004/07/17 17:56:24  ddiego
*minor mods to the TableControl and the TabbedPages control
*so that drawing updates get drawn better, and we don't have weird missing
*artifacts.
*
*Revision 1.1.2.5  2004/07/14 21:54:41  ddiego
*attempts to fix problem with borders and drawing on common controls.
*Sort of works on editor control. There is a subtle repaint problem in painting
*damaged portions of the control.
*
*Revision 1.1.2.4  2004/07/12 02:05:45  ddiego
*fixed a subtle bug (that only showed up when using a lightweight
*control) that happened with MouseClick events being handled twice.
*
*Revision 1.1.2.3  2004/07/09 03:39:28  ddiego
*merged in changes from the OSX branch for new theming API. Added
*support for controlling the use of locale translated strings in components.
*
*Revision 1.1.2.2.2.1  2004/07/06 03:27:12  ddiego
*more osx updates that add proper support
*for lightweight controls, some fixes to text layout, and some window painting issues. Also a fix
*so that controls and windows paint either their default theme background or their background
*color.
*
*Revision 1.1.2.2  2004/04/29 03:43:13  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:15  ddiego
*migration towards new directory structure
*
*Revision 1.60.2.1  2004/04/09 06:08:21  ddiego
*nybbles and bytes
*
*Revision 1.60  2004/04/03 15:48:44  ddiego
*Merged over code from the 0-6-3 branch.
*
*Revision 1.59  2004/01/20 01:54:56  ddiego
*merged some more changes from dev branch, primarily changes to
*teh RTTI API so that we now process enum sets correctly (i.e. a long
*that is a mask made of enum values).
*
*Revision 1.57.2.8  2004/03/21 20:25:40  marcelloptr
*Scrollable automatically calculates the scroll given the line where to go
*
*Revision 1.57.2.7  2004/03/21 00:39:23  ddiego
*merged vc7.1 changes into dev branch
*
*Revision 1.57.2.6  2004/03/19 21:25:57  ddiego
*just some minor noodlin
*
*Revision 1.57.2.5  2004/03/17 03:22:27  ddiego
*fixed a glitch in setting focus
*
*Revision 1.57.2.4  2004/03/01 05:59:19  ddiego
*and even MORE updates to the TableControl. Most of the core functionality
from Chris Maunder's CGridCtrl has been migrated over, and is functional.
Item editing and item dragging is still not done. Had to make a minor change
to the AbstractScroallable class to allow it have vertical and/or horizontal
delegate's set in order to notify them of position changes. This was needed
by the TableControl to properly update the top left non fixed cell calculation.
The performance is kind of slow ( :) ) in debug mode, but quite snappy in release.

*Revision 1.57.2.3  2004/01/18 04:52:46  ddiego
*Added a new EnumSet class that handles manipulating unsigned longs
*as a mask of bits. Adds support for reading in the enum value names and
*ORing them together to form the complete mask value. Also made
*mods to the VFFOutput and VFFInput stream classes so that that the []
*property is correctly read and written
*
*Revision 1.57.2.2  2004/01/16 04:30:46  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.57.2.1  2004/01/15 05:35:04  ddiego
*making some minor changes so that nested menu components get handled
*correctly and added from a VFF file
*
*Revision 1.57.2.3  2004/01/18 04:52:46  ddiego
*Added a new EnumSet class that handles manipulating unsigned longs
*as a mask of bits. Adds support for reading in the enum value names and
*ORing them together to form the complete mask value. Also made
*mods to the VFFOutput and VFFInput stream classes so that that the []
*property is correctly read and written
*
*Revision 1.57.2.2  2004/01/16 04:30:46  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.57.2.1  2004/01/15 05:35:04  ddiego
*making some minor changes so that nested menu components get handled
*correctly and added from a VFF file
*

*Revision 1.57  2003/12/18 05:16:00  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.56.2.19  2003/12/02 05:50:05  ddiego
*added preliminary support for teh Action class. This will make it easier
*to hook up complimentary UI elements (such as a "copy" menu item, and a
*"copy" toolbar item) and have tehm respond to update and actions via a
*single source.
*Got rid of the old toolbar button and separator class. Merged in Marcellos
*new fixes for the Container and Splitter classes.
*Some misc fixes to the Toolbar, groups and checks now work correctly.
*
*Revision 1.56.2.18  2003/11/10 01:57:43  ddiego
*add a fromString methods to StingUtils
*added some minor fixes to list box control and added a SelectionChanged
*Delegate to it
*add some minor fixes ot ComboBoxControl
*added an unknownColor() method to ColorNames class
*
*Revision 1.56.2.17  2003/10/28 20:23:26  ddiego
*minor header changes
*
*Revision 1.56.2.16  2003/10/20 03:40:13  ddiego
* made some minor changes fixed a bug in color where we forget to actually
*assign hls/hsv values.
*
*Revision 1.56.2.15  2003/10/14 21:32:49  ddiego
*little change ?
*
*Revision 1.56.2.14  2003/10/14 04:31:07  ddiego
*some more adjustments to hack on getting the alignments to wrok better
*
*Revision 1.56.2.13  2003/10/13 04:02:51  ddiego
*fixed some issues with calculating the view bounds if scrollbar
*are present as well as adding some functions to get teh bounds of
*left/right and top/bottom spaces that can surround a scrollbar.
*
*Revision 1.56.2.12  2003/10/12 06:34:13  ddiego
*added some fixes to standard container layout algorithms - thisstill needs
*to be tested, but it looks like it may fix some outstanding issues
*with the layout logic
*
*Revision 1.56.2.11  2003/09/12 00:09:18  ddiego
*added better tabbing behaviour - fixed an earlier bug.
*Code is easier to understand and it simplified the implementation
*a bit as well
*Moved around the RTTI definitions for various Appkit classes to a
*single inline and stripped them from the various class headers
*
*Revision 1.56.2.10  2003/09/06 19:45:15  ddiego
*changes to ensure that the destroy() is properly called.
*Destructors were moved back to pbulic scope in case that was causing a bug.
*Moving them all(all teh component derived classes) to private scope causes
*a complete failure in hte VC6 compiler. Alas...
*So destructors are present, and modal dialogs can still be created on the
*stack, but almost any other component should be created on the heap, and
*gotten rid of via free() NOT using operator delete directly.
*also moved the vcs info to the end of the file for some of the headers
*This will be an ongoing process.
*
*Revision 1.56.2.9  2003/09/05 21:03:21  ddiego
*moved the various control destructor's to protected scope
*migrated code into destroy() overridden methods
*----------------------------------------------------------------------
*
*Revision 1.56.2.8  2003/09/02 02:11:13  ddiego
*fixed some glitches in drag drop. also cleaned up the drag drop event
*classes. Began some fixes to the html browser implementation on Win32
*
*Revision 1.56.2.7  2003/08/27 03:53:40  ddiego
*view model bug fix and image file name extension bug fix
*
*Revision 1.56.2.6  2003/08/26 03:16:49  ddiego
*added a syntax fix cause VC6 is too stupid to compile code correctly.
*Thanks to Marcello for pointing it out.
*
*Revision 1.56.2.5  2003/08/22 01:19:11  ddiego
*finally fixed the it so that lightweight controls can now host containers
*and and act as a parent for heavyweight controls
*
*Revision 1.56.2.4  2003/08/19 04:43:40  ddiego
*further code to support lightweight container implementation. Not quite
*finished
*
*Revision 1.56.2.3  2003/08/18 19:52:37  ddiego
*changed the Container from being a class you derive from to a separate
*intance that is created and assigned dynamically to any Control.
*
*Revision 1.56.2.2  2003/08/18 02:55:41  ddiego
*added fix for bug [ 789902 ] EnumeratorContainer::prevElement() points to container_->end, also added an example
*
*Revision 1.56.2.1  2003/08/12 02:52:55  ddiego
*added properties getBottom/getRight/setBottom/setRight to Control
*
*Revision 1.56  2003/08/09 02:56:45  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.55.2.9  2003/08/02 00:41:12  marcelloptr
*fixes for vc6;  improved dependencies
*
*Revision 1.55.2.8  2003/08/01 00:49:26  ddiego
*added a fix for popup windows that also fixed a problem with the
*ComboBoxControl drop down list disapearing.
*
*Revision 1.55.2.7  2003/07/24 04:10:43  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.55.2.6  2003/06/28 04:43:20  ddiego
*cleaned up the vcf/include/events directory and got rid of files, moving
*some of the various event handler template classes into the same header
*that the event handler's event is associated with
*also made some changes to properly take advantage of a Control's View, if it
*is set.
*
*Revision 1.55.2.5  2003/06/20 04:36:46  ddiego
*further AGG integration
*moved files over to renamed directories
*
*Revision 1.55.2.4  2003/06/17 03:54:26  ddiego
*further agg integration - took out the getImage/putImage from GraphicsContext -
*this was too slow. now have an alternate solution that seems to work OK
*
*Revision 1.55.2.3  2003/06/13 03:06:40  ddiego
*bug fixes for
*585238:	Modal dialog which makes a modal Dialog
*585239:	Painting weirdness in a modal dialog
*also some clean up of miscellaneous debug trace statements
*and implemented task
*79266 - change DebugInfo to be stack based
*
*Revision 1.55.2.2  2003/06/13 00:03:19  ddiego
*more xmake fixes for the new version
*bug fixes for bugs
*509004	Opening a modal Dialog causes flicker
*also have tooltips working again
*
*Revision 1.55.2.1  2003/05/27 04:45:39  ddiego
*doing some code cleanup to fix some bugs in the way dialogs and popups
*work in Win32 port. Cleaned up the ControlPeer and DialogPeer interfaces
*a bit.
*
*Revision 1.55  2003/05/17 20:37:47  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.54.2.3  2003/04/17 04:29:52  ddiego
*updated scintilla, added gtk support for the application kit, with stubs
*for the basic peers.
*
*Revision 1.54.2.2  2003/03/23 03:24:00  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.54.2.1  2003/03/12 03:13:04  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.54  2003/02/26 04:30:55  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.53.2.5  2003/02/24 05:42:19  ddiego
*moved the code for the VariantData calss into it's own header
*migrated to the new event style using Delegates instead of relying on
*the ugly macros that we were using before - same functionality though
*made sure everything still works and compiles, including neccessary
*changes in the VCF Builder so that it creates code in the new style
*This changes to teh new style of using Delegates completes task 58837
*
*Revision 1.53.2.4  2003/01/08 00:19:59  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.53.2.3  2002/12/27 23:04:59  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.53.2.2  2002/12/25 22:06:34  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.53.2.1  2002/12/02 00:38:36  ddiego
*more fixes to get the ApplicationKit to compile under mingw. Everything now
*compiles OK at this point.
*
*Revision 1.53  2002/11/18 00:46:09  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.52.4.3  2002/10/07 05:02:56  ddiego
*addeds some more gui work to teh TemplateNewClassDlg.
*
*Revision 1.52.4.2  2002/10/01 20:34:59  ddiego
*borders
*
*Revision 1.52.4.1  2002/09/27 23:38:36  ddiego
*added support for geting various layout information
*added support for drawing various graphics UI primitives like scroll buttons
*tabs, tab pages, etc, partially to have this support in place for use
*in MacOSX.
*Also added scrolling buttons to TabbedPages, this fixes task 56652 in the
*ApplicationKit list
*
*Revision 1.52  2002/09/12 03:26:06  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.51.6.4  2002/09/10 04:07:51  ddiego
*misc fixes plus now posting the TableControl::finishEditing as a event
*
*Revision 1.51.6.3  2002/09/06 05:24:52  ddiego
*fixed bug in TableControl where it does not proeprly finished the ItemEditor
*correctly on loss of focus for the editor's control
*
*Revision 1.51.6.2  2002/07/14 05:40:02  ddiego
**** empty log message ***
*
*Revision 1.51.6.1  2002/06/28 17:45:30  ddiego
*migrated over lucki's changes (from his branch) for drag drop
*compiles OK, made chages to control and UIToolkit as neccessary
*still testing though.
*
*Revision 1.51  2002/05/09 03:10:45  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.50  2002/03/31 19:54:33  ddiego
*fixed a release bug in the TreeListControl
*made sure that saving the state of a Frame works correctly
*
*Revision 1.49  2002/03/22 04:30:18  ddiego
*bug fixes for weird resizing of win32 common controls (it figures) with the
*new code I put in yesterday. Put back the old code and it seems to work OK.
*Sigh...
*
*Revision 1.48  2002/03/21 04:01:22  ddiego
*fixed [ 532894 ] bug using the Frame::setClientBounds()
*
*Revision 1.47  2002/03/21 01:36:36  ddiego
*fix [ 532623 ] alignment problem & [ 525214 ] alignment loss after resize JEC 20-03-2002
*there was an incorrect comparison being done in AbstractContainer::insertBefore() that
*was resulting in controls being respositioned in the incorrect order. Should be cool now.
*
*Revision 1.46.4.3  2002/05/01 00:28:42  ddiego
*put back a mod made to the Control::setFocus() method were the previous focus control would get a
*setFocus(false) call - this was causing an issue with sertain popup windows
*
*Revision 1.46.4.2  2002/04/27 15:52:41  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.46.4.1  2002/04/08 20:55:31  zzack
*changed include style
*
*Revision 1.46  2002/03/05 04:44:14  ddiego
*fixed 525664 TreeList enum bug
*fixed popup menus not appearing right when scrolled to a position beyond 0,0
*fixed multi select problems with double entries
*
*Revision 1.45  2002/02/20 04:07:59  ddiego
*consolidated event handling code a bit
*introduced a virtual handleEvent() method to Component
*clean up some of the event constants, so they are now localized in the
*appropriate control classes.
*
*Revision 1.44  2002/02/07 04:38:55  ddiego
*fixes to Win32Edit, which include problems with setting text, and a bug that
*caused it to crash in Win 98. All textControls now default to the "EDIT"
*window class unles they are multiline, in which case an attempt is made to
*load the richedit control, and if that fails then the EDIT class is used
*Removed responding to WM_COMMAND messages
*in the default parent in the Win32Toolkit, also to fix the Win32Edit crash in 9.x
*
*Revision 1.43  2002/01/24 01:46:50  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


