//Control.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/Action.h"
#include "vcf/ApplicationKit/ActionEvent.h"


using namespace VCF;

Control* Control::capturedMouseControl = NULL;
Control* Control::currentFocusedControl = NULL;
Control* Control::previousMouseOverControl = NULL;

Control::Control():
	peer_(NULL),
	context_(NULL),
	parent_(NULL),
	aligment_(AlignNone),
	anchor_(AnchorNone),
	bounds_(NULL),
	clientBounds_(NULL),
	border_(NULL),
	color_(NULL),
	font_(NULL),
	view_(NULL),
	useParentFont_(false),
	doubleBuffered_(true),
	hasMouseCapture_(false),
	autoStartDragDrop_(false),
	popupMenu_(NULL),
	scrollable_(NULL),
	cursorID_(0),
	cursor_(NULL),
	tabStop_(true),
	tabOrder_(-1),
	useRenderBuffer_(false),
	container_(NULL),
	ignoredForLayout_(false),
	repaintOnSize_(true)
{
	//this (Font) cast is to avoid an internal compiler error on some vc6 versions
	font_ = new Font( (Font) UIToolkit::getUIMetricsManager()->getDefaultFontFor( UIMetricsManager::ftControlFont ) );

	context_ = new ControlGraphicsContext( this );

	bounds_ = new Rect();
	clientBounds_ = new Rect();
	color_ = new Color;

	setCursorID( (long)Cursor::SCT_DEFAULT );

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_FACE ) );

	viewControl_ = this;

	anchorDeltas_[ANCHOR_DTOP] = 0.0f;
	anchorDeltas_[ANCHOR_DLEFT] = 0.0f;
	anchorDeltas_[ANCHOR_DBOTTOM] = 0.0f;
	anchorDeltas_[ANCHOR_DRIGHT] = 0.0f;
}

Control::~Control()
{
	componentState_ = Component::csDestroying;
	/**
	this shouldn't happen, but it's
	possible if an exception is thrown in a constructor
	and not handled. In this case the Control::destroy
	method will not be called, but rather the destructor
	will be called directly.
	So we double check here and delete the control peer
	*/
	if ( NULL != peer_ ) {
		peer_->setControl( NULL );
		peer_->destroyControl();
		delete peer_;
		peer_ = NULL;
	}
}

void Control::destroy()
{
	
	if ( this->isLightWeight() ) {
		//have to handle a Component::COMPONENT_DELETED event manually
		//as they will NOT recv notification from the underlying windowing system
		VCF::ComponentEvent event( this, Component::COMPONENT_DELETED );
		handleEvent( &event );
	}


	if ( NULL != peer_ ) {
		UIToolkit::removeAcceleratorKeysForControl( this );
	}

	if ( this == Control::previousMouseOverControl ) {
		Control::previousMouseOverControl = NULL;
	}

	delete bounds_;
	bounds_ = NULL;
	delete clientBounds_;
	clientBounds_ = NULL;
	delete color_;
	color_ = NULL;

	delete context_;
	context_ = NULL;

	if ( NULL != peer_ ) {
		peer_->destroyControl();
		delete peer_;
		peer_ = NULL;
	}

	if ( NULL != font_ ){
		font_->free();
		font_ = NULL;
	}

	if ( this == Control::currentFocusedControl ) {
		Control::currentFocusedControl = NULL;
	}

	if ( NULL != view_ ) {
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->release();
		}
		else {
			delete view_;
		}
	}
	view_ = NULL;

	
	container_ = NULL;

	Component::destroy();
}

Border* Control::getBorder()
{
	return border_;
}

void Control::setBorder( Border* border )
{	
	border_ = border;

	if ( NULL != border_ ) {
		if ( NULL == border_->getOwner() ) {
			addComponent( border_ );
		}
	}
	
	peer_->setBorder( border_ );
}

Rect Control::getBounds()/**throw( InvalidPeer ); -JEC - FIXME later*/
{	

	Control* parent = getParent();
	bool lightweightParent = false;
	if ( NULL != parent ) {
		lightweightParent = parent->isLightWeight();
	}

	if ( lightweightParent && !isLightWeight() ) {
		*bounds_ = peer_->getBounds();

		Rect tmpBounds = *bounds_;

		tmpBounds.offset( -tmpBounds.left_, -tmpBounds.top_ );

		translateToScreenCoords( &tmpBounds );

		parent->translateFromScreenCoords( &tmpBounds );

		*bounds_ =  tmpBounds;
	}
	else {
		*bounds_ = peer_->getBounds();
		//peer_->setBounds( bounds_ );
	}
	return *bounds_;
}




Rect Control::getClientBounds( const bool& includeBorder ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{	
	Rect r = peer_->getBounds();
	clientBounds_->setRect( 0.0, 0.0, r.getWidth(), r.getHeight() );

	if ( (includeBorder) && (NULL != border_) ){
		r = *clientBounds_;
		*clientBounds_ = border_->getClientRect( &r, this );
	}

	return *clientBounds_;
}

double Control::getLeft() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	
	//*bounds_ = peer_->getBounds();
	getBounds();

	return bounds_->left_;
}

double Control::getRight()
{

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->right_;
}

double Control::getBottom() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->bottom_;
}

double Control::getWidth() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->getWidth();
}

double Control::getTop() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	getBounds();
	//*bounds_ = peer_->getBounds();

	return bounds_->top_;
}

double Control::getHeight() /**throw( InvalidPeer ); -JEC - FIXME later*/
{

	//double result = 0.0;

	getBounds();
	//*bounds_ = peer_->getBounds();
	//result = bounds_->getHeight();


	return bounds_->getHeight();
}

bool Control::getVisible() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	return peer_->getVisible();
}

AlignmentType Control::getAlignment()
{
	return aligment_;
}

bool Control::isIgnoredForLayout()
{
	return ignoredForLayout_;
}

void Control::setIgnoredForLayout( const bool& val )
{
	ignoredForLayout_ = val;

	Control* parent = getParent();
	if ( NULL != parent ) {
		parent->getContainer()->resizeChildren( NULL );
	}
}

void Control::setBounds( const double& x, const double& y, const double& width, const double& height )
{
	setBounds( &Rect( x, y, x+width, y+height ) );
}

void Control::setBounds( Rect* rect, const bool& anchorDeltasNeedUpdating ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	*bounds_ = *rect;

	/**
	Adjust the bounds to take into account a
	potentially lightweight parent
	*/
	Control* parent = getParent();
	bool lightweightParent = false;
	if ( NULL != parent ) {
		lightweightParent = parent->isLightWeight();
	}

	if ( lightweightParent && !isLightWeight() ) {
		Control* realParent = parent;
		while ( NULL != realParent ) {
			if ( !realParent->isLightWeight() ) {
				break;
			}
			realParent = realParent->getParent();
		}

		if ( NULL != realParent ) {


			Rect tmp = *bounds_;
			Rect tmp2 = *bounds_;

			tmp.offset( -tmp.left_, -tmp.top_ );

			parent->translateToScreenCoords( &tmp );

			realParent->translateFromScreenCoords( &tmp );

			tmp2.offset( tmp.left_, tmp.top_ );

			*bounds_ = tmp2;

			peer_->setBounds( &tmp2 );
		}
		else {
			peer_->setBounds( bounds_ );
		}
	}
	else {
		peer_->setBounds( bounds_ );
	}

	if ( useRenderBuffer_ ) {
		if ( NULL == context_->getDrawingArea() ) {
			context_->setDrawingArea( *bounds_ );
		}
	}

	if ( true == anchorDeltasNeedUpdating ) {
		updateAnchorDeltas();
	}
}

void Control::setAlignment( const AlignmentType& alignment )
{
	aligment_ = alignment;
	/**
	Fix submitted by Marcello - see bug [ 789945 ] Control::setAlignment() does not allow only one align style
	*/
	if ( aligment_ != AlignNone ) {
		anchor_ = AnchorNone;
	}

	Control* parent = getParent();
	if ( NULL != parent ){
		Container* container = parent->getContainer();
		if ( NULL != container ){
			container->resizeChildren(NULL);//this);
		}
	}

	updateAnchorDeltas();
}

void Control::setLeft( const double& left ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	double dx = bounds_->getWidth();
	bounds_->left_ = left;
	bounds_->right_ = left + dx;
	setBounds( bounds_ );
}

void Control::setRight( const double& right ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	bounds_->right_ = right;
	setBounds( bounds_ );
}

void Control::setWidth( const double& width ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	bounds_->right_ = bounds_->left_ + width;
	setBounds( bounds_ );
}

void Control::setTop( const double& top ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	double dy = bounds_->getHeight();
	bounds_->top_ = top;
	bounds_->bottom_ = top + dy;
	setBounds( bounds_ );
}

void Control::setBottom( const double& bottom ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	bounds_->bottom_ = bottom;
	setBounds( bounds_ );
}

void Control::setHeight( const double& height ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( NULL != peer_ ){
		bounds_->bottom_ = bounds_->top_ + height;
		setBounds( bounds_ );
	};
}

void Control::setVisible( const bool& visible ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	bool oldVisible = peer_->getVisible();

	if ( oldVisible != visible ) {
		peer_->setVisible( visible );
		Control* parent = getParent();
		if ( NULL != parent ) {
			Container* container = parent->getContainer();
			if ( NULL != container ) {
				if ( visible ) { //(oldVisible == false) && (true == visible) ) {
					container->resizeChildren(NULL);//this);
				}
				else {
					container->resizeChildren(NULL);
				}
			}
		}
	}
}

void Control::handleEventAndForwardToChildren( Event* event )
{
	handleEvent( event );
	Container* container = getContainer();
	if ( NULL != container && (!event->isConsumed())) {
		Enumerator<Control*>* children = container->getChildren();
		while ( children->hasMoreElements() )  {
			Control* child = children->nextElement();
			child->handleEventAndForwardToChildren( event );
			if ( event->isConsumed() ) {
				break;
			}
		}
	}

}

void Control::handleEvent( Event* event )
{
	Component::handleEvent( event );
	if ( NULL != event ){
		unsigned long eventType = event->getType();

		switch ( eventType ){
			case Action::UpdateEvent : {
				ActionEvent* actionEvent = (ActionEvent*)event;

				setEnabled( actionEvent->isEnabled() );
			}
			break;

			case CONTROL_SIZED:{
				ControlEvent* controlEvent = (ControlEvent*)event;

				//bounds_->right_ = bounds_->left_ + controlEvent->getNewSize().width_;
				//bounds_->bottom_ = bounds_->top_ + controlEvent->getNewSize().height_;
				ControlSized.fireEvent( (ControlEvent*)event );

				if ( useRenderBuffer_ ) {
					Rect bounds = getClientBounds(false);
					context_->setDrawingArea( bounds );						
				}
			}
			break;

			case CONTROL_POSITIONED:{
				ControlEvent* controlEvent = (ControlEvent*)event;
				//double w = bounds_->getWidth();
				//double h = bounds_->getHeight();

				//bounds_->left_ = controlEvent->getNewPosition().x_;
				//bounds_->top_ = controlEvent->getNewPosition().y_;
				//bounds_->right_ = bounds_->left_ + w;
				//bounds_->bottom_ = bounds_->top_ + h;

				ControlPositioned.fireEvent( controlEvent );
			}
			break;

			case CONTROL_PARENT_CHANGED:{
				ControlParentChanged.fireEvent( (ControlEvent*)event );
			}
			break;

			case MOUSE_ENTERED:{
				MouseEvent* mouseEvent = (MouseEvent*)event;


				MouseEnter.fireEvent( mouseEvent );
				if (!event->isConsumed() && !isDesigning()) {
					mouseEnter( mouseEvent );
				}
			}
			break;

			case MOUSE_DOWN:{
				MouseEvent* mouseEvent = (MouseEvent*)event;

				clickPt_ = *mouseEvent->getPoint();
				

				MouseDown.fireEvent( mouseEvent );

				//turn off normal mouse behaviour in design mode
				if ( !event->isConsumed() && !isDesigning() ) {
					mouseDown( mouseEvent );
				}
			}
			break;

			case MOUSE_MOVE:{
				MouseEvent* mouseEvent = (MouseEvent*)event;

				if (mouseEvent->hasLeftButton() || mouseEvent->hasRightButton() || mouseEvent->hasMiddleButton() ) {
					if ( (true == autoStartDragDrop_) ) { //&& (false == dragDropStarted_) ) {
						if ( true == canBeginDragDrop( mouseEvent->getPoint() ) ) {
							//dragDropStarted_ = true;							
							if ( beginDragDrop ( mouseEvent ) ) {
								return;
							}
						}
					}
				}
				
				peer_->setCursor( cursor_ );
				MouseMove.fireEvent( mouseEvent );
				if (!event->isConsumed() && !isDesigning()) {
					mouseMove( mouseEvent );
				}
			}
			break;

			case MOUSE_UP:{

				MouseEvent*  mouseEvent = (MouseEvent*)event;

				Point tmpPt = *mouseEvent->getPoint();
				Point origPt = *mouseEvent->getPoint();


				bool rightBtn = mouseEvent->hasRightButton();
				MouseUp.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed() && !isDesigning()) {
					mouseUp( mouseEvent );
				}
				if ( (NULL != popupMenu_) && (true == rightBtn) && !isDesigning() ){
					Point tmpPt = *mouseEvent->getPoint();
					if ( NULL != scrollable_ ) {
						tmpPt.x_ -= scrollable_->getHorizontalPosition();
						tmpPt.y_ -= scrollable_->getVerticalPosition();
					}

					
					popupMenu_->popup( &tmpPt );
				}


				if ( clickPt_.closeTo( tmpPt.x_, tmpPt.y_, 2 ) ){

					
					MouseEvent clickEvent( this,
											MOUSE_CLICK,
											mouseEvent->getButtonMask(),
											mouseEvent->getKeyMask(),
											&origPt );


					handleEvent( &clickEvent );
				}

			}
			break;

			case MOUSE_LEAVE:{
				MouseEvent*  mouseEvent = (MouseEvent*)event;


				MouseLeave.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed() && !isDesigning()) {
					mouseLeave( mouseEvent );
				}
			}
			break;

			case MOUSE_CLICK:{
				
				MouseEvent*  mouseEvent = (MouseEvent*)event;
				MouseClicked.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed() && !isDesigning() ) {
					mouseClick( mouseEvent );
				}
			}
			break;

			case MOUSE_DBLCLICK:{
				MouseEvent*  mouseEvent = (MouseEvent*)event;

				MouseDoubleClicked.fireEvent( mouseEvent );
				if (!mouseEvent->isConsumed() && !isDesigning() ) {
					mouseDblClick( mouseEvent );
				}
			}
			break;

			case KEYBOARD_DOWN:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				
				if ( !isDesigning() || (NULL != getContainer()) ) {
					keyDown( kbEvent );					
				}
				KeyDown.fireEvent( kbEvent );
			}
			break;

			case KEYBOARD_PRESSED:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				if ( !isDesigning() || (NULL != getContainer()) ) {
					keyPressed( kbEvent );
				}
				
				KeyPressed.fireEvent( kbEvent );
			}
			break;

			case KEYBOARD_UP:{
				KeyboardEvent* kbEvent = (KeyboardEvent*)event;
				if ( !isDesigning() || (NULL != getContainer()) ) {
					keyUp ( kbEvent );
				}
				KeyUp.fireEvent( kbEvent );
			}
			break;

			case FOCUS_LOST:{
				FocusEvent* focusEvent = (FocusEvent*)event;

				//StringUtils::traceWithArgs( "Control::FOCUS_LOST, this[%s]@ %p\n",
				//					getClassName().c_str(), this );

				FocusLost.fireEvent( focusEvent );

			}
			break;

			case FOCUS_GAINED:{
				FocusEvent* focusEvent = (FocusEvent*)event;

				//StringUtils::traceWithArgs( "Control::FOCUS_GAINED, this[%s]@ %p\n",
				//					getClassName().c_str(), this );

				FocusGained.fireEvent( focusEvent );

			}
			break;
		}
		//if ( !mouseEvent->isConsumed() )
			//mouseEvent->setConsumed(true);
	}
}


bool Control::canBeginDragDrop( Point* point )
{
	bool result = false;

	Size dragDropDelta = UIToolkit::getDragDropDelta();

	/**
	clickPt_ gets set on a mousedown
	so make a rect around it
	r1 will be the inner  rect
	r2 will be the outer rect
	if the drag is outside the bounds of r1 and within r2
	then we can do a drag, otherwise forget it
	*/
	Rect r1( clickPt_.x_ - dragDropDelta.width_ /2.0,
			clickPt_.y_ - dragDropDelta.height_ /2.0,
			clickPt_.x_ + dragDropDelta.width_ /2.0,
			clickPt_.y_ + dragDropDelta.height_ /2.0 );

	Rect r2 = r1;

	r2.inflate( dragDropDelta.width_, dragDropDelta.height_ );

	//we are only ready to to begin a drag drop operation
	//if the point is NOT, I repeat, NOT, within the bounds of the
	//drag-drop rect. This prevents us from starting too early.
	//changing the dragDropDelta value allows us to control the 
	//sensitivity of how we reacto to drag-drop starts
	result = (!r1.containsPt( point )) && (r2.containsPt( point ));	

	return result;
}

void Control::setAutoStartDragDrop(const bool& canAutoStartDragDrop)
{
	autoStartDragDrop_ = canAutoStartDragDrop;
}

bool Control::getAutoStartDragDrop()
{
	return autoStartDragDrop_;
}

bool Control::beginDragDrop( MouseEvent* event )
{
	return false;
}

ControlPeer* Control::getPeer()
{
	return peer_;
}

void Control::setParent( Control* parent ) /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	if ( parent != parent_ ) {
		ControlEvent event( this, parent );
		ControlParentChanged.fireEvent( &event );
	}

	parent_ = parent;
	peer_->setParent( parent );


	if ( NULL != parent_ ) {

		parent->addComponent( this );

		if ( parent_->isLightWeight() && !isLightWeight() ) {

			Rect tmp = peer_->getBounds();
			Rect tmp2 = tmp;
			tmp.offset( -tmp.left_, -tmp.top_ );

			translateToScreenCoords( &tmp );
			parent->translateFromScreenCoords( &tmp );

			tmp2.offset( tmp2.left_ - tmp.left_, tmp2.top_ - tmp.top_ );

			*bounds_ = tmp2;
			peer_->setBounds( &tmp2 );
		}
	}

	updateAnchorDeltas();
}

Control* Control::getParent() /**throw( InvalidPeer ); -JEC - FIXME later*/
{
	return parent_;
}

void Control::removeFromParent( const bool& freeInstance )
{
	Control* parent = getParent();
	if ( NULL != parent ) {
		Container* container = parent->getContainer();
		VCF_ASSERT( NULL != container );

		container->remove( this );		
	}

	removeFromOwner( freeInstance );
}


bool Control::isFocused()
{
	bool result = (this == currentFocusedControl);

	return result;//peer_->isFocused();
}

Control* Control::setFocused()
{
	Control* result = NULL;

	if ( isNormal() || isCreated() || isDesigning() ) {	//JC added this so that a control recv's focus
														//only under these conditions

			if ( NULL != currentFocusedControl ) {
				if ( this != currentFocusedControl ) {
					//currentFocusedControl->setFocus( false ); //is this neccessary ?

					// do this to get the non focused control to repaint it's state
					currentFocusedControl->repaint();
				}
			}

		result = currentFocusedControl;
		currentFocusedControl = this;

		peer_->setFocused();
	}

	repaint();

	return result;
}

bool Control::isEnabled()
{
	return peer_->isEnabled();
}

bool Control::areParentsEnabled()
{
	if ( !isEnabled() ) {
		return false;
	}

	bool result = true;

	Control* parent = getParent();
	while ( result && (NULL != parent) ) {
		result = parent->isEnabled();
		parent = parent->getParent();
	}

	return result;
}

void Control::setEnabled( const bool& enabled )
{
	peer_->setEnabled( enabled );
	repaint();
}

void Control::mouseEnter( MouseEvent* event )
{

}

void Control::mouseDown( MouseEvent* event )
{
	setFocused();
}

void Control::mouseMove( MouseEvent* event )
{
	//probably want to put a modifier here for the scrollable to modify the coords ?

}

void Control::mouseUp( MouseEvent* event )
{

}

void Control::mouseLeave( MouseEvent* event )
{

}

void Control::keyDown( KeyboardEvent* event )
{

}

void Control::mouseClick(  MouseEvent* event )
{

}

void Control::mouseDblClick(  MouseEvent* event )
{

}

void Control::keyPressed( KeyboardEvent* event )
{

}

void Control::keyUp( KeyboardEvent* event )
{

}

void Control::translateToParent( Point* point )
{
	Control* parent = getParent();
	if ( NULL != parent ){
		Rect bounds = parent->getBounds();
		point->x_ += bounds.left_;
		point->y_ += bounds.top_;
	}
	else{
		//throw exception ?
	}
}

void Control::translateToLocal( Point* point )
{
	Control* parent = getParent();
	if ( NULL != parent ){
		Rect bounds = getBounds();
		point->x_ -= bounds.left_;
		point->y_ -= bounds.top_;
	}
	else{
		//throw exception ?
	}
}

void Control::beforeDestroy( ComponentEvent* event )
{
	Component::beforeDestroy( event );
}

bool Control::isLightWeight()
{
	return false;
}

Control* Control::getHeavyweightParent()
{
	Control* parent = NULL;
	Control* result = NULL;
	result = getParent();
	if ( result != NULL ) {
		while ( true == result->isLightWeight() ){
			parent = result;
			result = parent->getParent();
		}
	}

	return result;
}

Color* Control::getColor()
{
	return color_;
}

void Control::setColor( Color* color )
{
	color_->copy( color );
}


Font* Control::getFont()
{
	return font_;
}

void Control::setFont( Font* font )
{
	if ( NULL != font ){
		font_->copy( font );
	}
	
	peer_->setFont( font_ );

}

bool Control::useParentFont()
{
	return useParentFont_;
}

void Control::setUseParentFont( const bool& useParentFont )
{
	useParentFont_ = useParentFont;
}

void Control::afterCreate( ComponentEvent* event )
{	
	
}

void Control::repaint( Rect* repaintRect )
{
	
	peer_->repaint( repaintRect );
	if ( useRenderBuffer_ ) {
		context_->markRenderAreaDirty();
	}
}

bool Control::isDoubleBuffered()
{
	return doubleBuffered_;
}

void Control::setDoubleBuffered( const bool& doubleBuffered )
{
	doubleBuffered_ = doubleBuffered;
}

void Control::keepMouseEvents()
{
	hasMouseCapture_ = true;
	Control::setCapturedMouseControl( this );
	peer_->keepMouseEvents();
}

void Control::releaseMouseEvents()
{
	hasMouseCapture_ = false;
	Control::setCapturedMouseControl( NULL );
	peer_->releaseMouseEvents();
}

Control* Control::getCapturedMouseControl()
{
	return Control::capturedMouseControl;
}

void Control::setCapturedMouseControl( Control* control )
{
	Control::capturedMouseControl = control;
}

GraphicsContext* Control::getContext()
{
	return context_;
}

PopupMenu* Control::getPopupMenu()
{
	return popupMenu_;
}

void Control::setPopupMenu( PopupMenu* popupMenu )
{
	if ( NULL != popupMenu_ ){
		popupMenu_->setControl( NULL );
	}

	popupMenu_ = popupMenu;

	if ( NULL != popupMenu_ ){
		popupMenu_->setControl( this );
	}
}

View* Control::getView()
{
	return view_;
}

void Control::setView( View* view )
{
	if ( NULL != view_ ) {
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->release();
		}
	}

	view_ = view;

	if ( NULL != view_ ) {
		view_->setViewControl( this );
		Object* obj = dynamic_cast<Object*>( view_ );
		if ( NULL != obj ) {
			obj->addRef();
		}
	}
}

void Control::setScrollable( Scrollable* scrollable )
{
	scrollable_ = scrollable;
	if ( NULL != scrollable_ ) {
		scrollable_->setScrollableControl( this );
		scrollable_->recalcScrollPositions();
	}
}

void Control::processWhatsThisHelpEvent()
{
	WhatsThisHelpEvent event( this, whatThisHelpString_ );
	ControlHelpRequested.fireEvent( &event );
}

void Control::setToolTipText( const String& tooltip )
{
	toolTip_ = tooltip;
}

void Control::setCursorID( const long& cursorID )
{
	cursor_ = CursorManager::getCursorManager()->getCursor( cursorID );
}

void Control::setAnchor( const unsigned long& anchor )
{
	anchor_ = anchor;
	aligment_ = AlignNone;
	updateAnchorDeltas();

	Control* parent = getParent();
	if ( NULL != parent ){
		Container* container = parent->getContainer();
		if ( NULL != container ){
			container->resizeChildren(NULL);//this);
		}
	}
}

void Control::updateAnchorDeltas() {
	if ( AnchorNone == anchor_ ) {
		anchorDeltas_[ANCHOR_DTOP] = 0.0f;
		anchorDeltas_[ANCHOR_DLEFT] = 0.0f;
		anchorDeltas_[ANCHOR_DBOTTOM] = 0.0f;
		anchorDeltas_[ANCHOR_DRIGHT] = 0.0f;
	}
	else {
		Control* parent = getParent();
		if ( NULL != parent ) {
			Rect parentBounds = parent->getClientBounds();
			Rect bounds = getBounds();
			anchorDeltas_[ANCHOR_DTOP] = (float) bounds.top_;
			anchorDeltas_[ANCHOR_DLEFT] = (float) bounds.left_;
			anchorDeltas_[ANCHOR_DBOTTOM] = (float) parentBounds.bottom_ -  bounds.bottom_;
			anchorDeltas_[ANCHOR_DRIGHT] = (float) parentBounds.right_ -  bounds.right_;
		}
	}
}

AcceleratorKey* Control::getAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask )
{
	return UIToolkit::getAccelerator( keyCode, modifierMask, this );
}

void Control::addAcceleratorKey( const VirtualKeyCode& keyCode, const ulong32& modifierMask, EventHandler* eventHandler )
{
	if ( NULL == eventHandler ) {
		throw InvalidPointerException( MAKE_ERROR_MSG_2("The Event handler passed in for the accelerator is NULL!") );
	}

	AcceleratorKey* newAccelKey = new AcceleratorKey( this, keyCode, modifierMask, eventHandler );

	addAcceleratorKey( newAccelKey );
}

void Control::addAcceleratorKey( const VirtualKeyCode& keyCode, const ulong32& modifierMask, Action* action )
{
	if ( NULL == action ) {
		throw InvalidPointerException( MAKE_ERROR_MSG_2("The action instance passed in for the accelerator is NULL!") );
	}

	addAcceleratorKey( keyCode, modifierMask, action->getAcceleratorEventHandler() );
}

void Control::addAcceleratorKey( AcceleratorKey* accelerator )
{
	UIToolkit::registerAccelerator( accelerator );
}

void Control::setTabStop( const bool& tabStop )
{
	tabStop_ = tabStop;
}

void Control::setTabOrder( const long& tabOrder )
{
	if ( tabOrder_ == tabOrder ) {
		return ;
	}

	Control* parent = getParent();
	if ( NULL != parent ) {
		Container* container = parent->getContainer();
		if ( NULL != container ) {
			ulong32 tmp = tabOrder;
			container->updateTabOrder( this, tmp );

			tabOrder_ = tmp;
		}
	}
}


Control* Control::getCurrentFocusedControl()
{
	return Control::currentFocusedControl;
}

void Control::mnemonicActivate()
{
	setFocused();
}

Control* Control::getPreviousMouseOverControl()
{
	return Control::previousMouseOverControl;
}

void Control::setPreviousMouseOverControl( Control* control )
{
	Control::previousMouseOverControl = control;
}


void Control::translateToScreenCoords( Point* pt )
{
	peer_->translateToScreenCoords( pt );
}

void Control::translateToScreenCoords( Rect* rect )
{
	Point pt ( rect->left_, rect->top_ );

	peer_->translateToScreenCoords( &pt );
	rect->left_ = pt.x_;
	rect->top_ = pt.y_;

	pt.x_ = rect->right_;
	pt.y_ = rect->bottom_;

	peer_->translateToScreenCoords( &pt );

	rect->right_ = pt.x_;
	rect->bottom_ = pt.y_;
}

void Control::translateFromScreenCoords( Point* pt )
{
	peer_->translateFromScreenCoords( pt );
}

void Control::translateFromScreenCoords( Rect* rect )
{
	Point pt ( rect->left_, rect->top_ );

	peer_->translateFromScreenCoords( &pt );
	rect->left_ = pt.x_;
	rect->top_ = pt.y_;

	pt.x_ = rect->right_;
	pt.y_ = rect->bottom_;

	peer_->translateFromScreenCoords( &pt );

	rect->right_ = pt.x_;
	rect->bottom_ = pt.y_;
}

void Control::setContainer( Container* container )
{
	Container* oldContainer = container_;

	container_ = container;	

	if ( NULL != container_ ) {
		
		if ( NULL == container_->getOwner() ) {
			addComponent(container_) ;
		}

		container_->setContainerControl( this );
	}

	//transfer over container controls!
	if ( NULL != container_ && NULL != oldContainer ) {
		container_->clear();

		int count = oldContainer->getChildCount();
		for ( int i=0;i<count;i++ ) {
			Control* control = oldContainer->getControlAtIndex( 0 );

			oldContainer->remove( control );

			container_->add( control );
		}

		oldContainer->clear();
	}
}

void Control::buildTabList( Control* control, std::vector<Control*>& tabList )
{
	tabList.push_back( control );

	Container* container = control->getContainer();
	if ( NULL != container ) {
		container->getTabList( tabList );
	}
}

Frame* Control::getParentFrame()
{
	Control* result = NULL;

	Control* parent = getParent();
	while ( parent != NULL ) {
		result = parent;
		parent = result->getParent();
	}

	if ( NULL == result ) {
		result = this;
	}

	return (Frame*)result;
}

bool Control::canAcceptFocus()
{
	bool result = true;

	if ( isEnabled() ) {
		Control* parent = getParent();
		while ( parent != NULL ) {
			if ( !parent->isEnabled() ) {
				result = false;
				break;
			}
			parent = parent->getParent();
		}
	}
	else {
		result = false;
	}

	return result;
}

void Control::adjustViewableBoundsAndOriginForScrollable( GraphicsContext* context, Rect& viewBounds, Point& origin )
{
	Scrollable* scrollable = getScrollable();
	if ( NULL != scrollable ) {
		Rect innerBounds = getClientBounds(true);

		//account for any children that overlap
		if ( NULL != this->container_ ) {
			Enumerator<Control*>* children = container_->getChildren();
			Rect childBounds;
			while ( children->hasMoreElements() ) {
				Control* child = children->nextElement();

				
				if ( child->getAlignment() != AlignNone && child->getVisible() ) {
					childBounds = child->getBounds();
					switch( child->getAlignment() ) {
						case AlignLeft : {
							innerBounds.left_ += childBounds.getWidth();
						}
						break;

						case AlignRight : {
							innerBounds.right_ -= childBounds.getWidth();
						}
						break;

						case AlignTop : {
							innerBounds.top_ += childBounds.getHeight();
						}
						break;

						case AlignBottom : {
							innerBounds.bottom_ -= childBounds.getHeight();
						}
						break;
					}
				}
			}
		}


		Point scrollPos;
		scrollPos.x_ = scrollable->getHorizontalPosition();
		scrollPos.y_ = scrollable->getVerticalPosition();

		//clip for border
		viewBounds.left_ = maxVal<>( innerBounds.left_+1,viewBounds.left_ );
		viewBounds.top_ = maxVal<>( innerBounds.top_+1,viewBounds.top_ );

		viewBounds.right_ = minVal<>( innerBounds.right_-1.0,viewBounds.right_ );
		viewBounds.bottom_ = minVal<>( innerBounds.bottom_-1.0,viewBounds.bottom_ );

		UIMetricsManager* mgr = UIToolkit::getUIMetricsManager();

		double dx = scrollable->getVirtualViewWidth() - innerBounds.getWidth();
		double dy = scrollable->getVirtualViewHeight() - innerBounds.getHeight();
		
		/* 
		* we need to do a comparison of virtualViewWidth and virtualViewHeight with bounds that have
		* accounted for the presence of scrollbars if they exist. We need to do this so that origin and
		* viewable bounds offset are calculated correctly so that when we are scrolled all the way to bottom
		* and right, the very bottom and right of bounds defined by virtualViewWidth and virtualViewHeight 
		* are visible. These 'adjusted' bounds are initially set to innerBounds dimensions, and then modified
		* if scrollbars present. (We alternatively could have increased virtualViewWidth/Height if scrollbars
		* were present, and compared these to actual innerBounds.)
		* NOTE: These adjusted values go hand-in-hand with adjustment to SCROLLINFO::nMax in scrollPeer when
		* both scrollbars present. 
		*/
		double scrollAdjustedWidth  = innerBounds.getWidth();
		double scrollAdjustedHeight = innerBounds.getHeight();	
		
		// can't use hasVerticalScrollbar here, we need to know if they are actually visible.
		bool isVertScrollbarVisible = scrollable->isVerticalScrollbarVisible();
		bool isHorzScrollbarVisible = scrollable->isHorizontalScrollbarVisible();		
		
		/*
		* since we are no longer adjusting virtualViewWidth and Height for presence of both scrollbars,
		* we need to tack on the extra to dx and dy here.
		*/
		if ( isHorzScrollbarVisible ) {
			dy += scrollable->getHorizontalScrollbarHeight();
			scrollAdjustedHeight -= scrollable->getHorizontalScrollbarHeight();
		}
		if ( isVertScrollbarVisible ) {
			dx += scrollable->getVerticalScrollbarWidth();
			scrollAdjustedWidth -= scrollable->getVerticalScrollbarWidth();
		}	
		
		/*
		Just a note: this assumes the scroll position units are same as GraphicsContext units (I think).
		When we implement a user-defined scroll increment, such as by the height of a line of text based
		on current Context, you may need a conversion here depending on how you implement that technique.
		*/
		origin.x_ -= scrollPos.x_;
		origin.y_ -= scrollPos.y_;

		//offset the viewBounds by the scrollable's offset
		viewBounds.offset( scrollPos.x_, scrollPos.y_ );

		if ( isHorzScrollbarVisible && ( scrollable->getVirtualViewWidth() > scrollAdjustedWidth ) ) {		
			Size horzSize = mgr->getDefaultHorizontalScrollButtonDimensions();

			//viewBounds.bottom_ = minVal<>( viewBounds.bottom_-horzSize.height_,viewBounds.bottom_ );
						
			if ( dx < scrollPos.x_ ) {
			
				origin.x_ -= ( dx - scrollPos.x_ );

				viewBounds.offset( dx - scrollPos.x_, 0 );
			}
		}
		else {
			Size horzSize = mgr->getDefaultHorizontalScrollButtonDimensions();

			//viewBounds.bottom_ = minVal<>( viewBounds.bottom_-horzSize.height_,viewBounds.bottom_ );

			origin.x_ += scrollPos.x_;
			viewBounds.offset( scrollPos.x_, 0 );

			if ( scrollPos.x_ > 0 ) {
				scrollable->setHorizontalPosition( 0 );
			}
		}

		
		if ( isVertScrollbarVisible && ( scrollable->getVirtualViewHeight() > scrollAdjustedHeight ) ) {
			Size vertSize = mgr->getDefaultVerticalScrollButtonDimensions();

			//viewBounds.right_ = minVal<>( viewBounds.right_-vertSize.width_,viewBounds.right_ );

			if ( dy < scrollPos.y_ ) {
				origin.y_ -= ( dy - scrollPos.y_ );
				viewBounds.offset( 0, dy - scrollPos.y_ );
			}
		}
		else {
			Size vertSize = mgr->getDefaultVerticalScrollButtonDimensions();

			//viewBounds.right_ = minVal<>( viewBounds.right_-vertSize.width_,viewBounds.right_ );

			origin.y_ += scrollPos.y_;
			viewBounds.offset( 0, scrollPos.y_ );


			if ( scrollPos.y_ > 0 ) {
				scrollable->setVerticalPosition( 0 );
			}
		}


	}
}


bool Control::isActive()
{
	Frame* parentFrame = getParentFrame();
	//printf( "parentFrame: %p, Frame::getActiveFrame(): %p\n",
	//			parentFrame, Frame::getActiveFrame() );
	return (parentFrame == Frame::getActiveFrame()) && (parentFrame->isActiveFrame());
}

void Control::setViewModel( Model* viewModel )
{
	bool modelChanged = (viewModel != getViewModel()) ? true : false;

	AbstractView::setViewModel( viewModel );
	if ( modelChanged ) {
		ControlEvent event( this, Control::CONTROL_MODELCHANGED );
		ControlModelChanged.fireEvent(&event);
	}
}

void Control::paintBorder( GraphicsContext * context )
{
	Border* border = getBorder();
	if ( NULL != border ) {
		border->paint( this, context );
	}
}



/**
*CVS Log info
*$Log$
*Revision 1.8  2005/07/09 23:14:52  ddiego
*merging in changes from devmain-0-6-7 branch.
*
*Revision 1.7  2005/02/26 14:47:38  ddiego
*fixed bug 1152064 with repaint issue on set enabled state.
*
*Revision 1.6  2005/01/02 03:04:20  ddiego
*merged over some of the changes from the dev branch because they're important resoource loading bug fixes. Also fixes a few other bugs as well.
*
*Revision 1.5  2004/12/10 03:32:51  ddiego
*fixed a heap overwrite error in the delegate-event handler code.
*
*Revision 1.4.2.3  2005/01/01 20:31:07  ddiego
*made an adjustment to quitting and event loop, and added some changes to the DefaultTabModel.
*
*Revision 1.4.2.2  2004/12/31 17:41:23  ddiego
*fixes a drag-drop bug, initially listed under the vcfbuilders
*bug list
*
*Revision 1.4.2.1  2004/12/31 17:39:47  ddiego
*fixes a drag-drop bug, initially listed under the vcfbuilders
*bug list
*
*Revision 1.4.2.18  2005/06/29 20:30:15  marcelloptr
*second step to remove flickering when dragging a splitter
*
*Revision 1.4.2.17  2005/05/15 23:17:37  ddiego
*fixes for better accelerator handling, and various fixes in hwo the text model works.
*
*Revision 1.4.2.16  2005/05/06 20:33:37  marcelloptr
*Error message improved.
*
*Revision 1.4.2.14  2005/04/26 04:05:22  ddiego
*the first half of [ 1184432 ] Tables cell edit box follows scroll movement, is fixed. Still need to get the scrollbars to update.
*
*Revision 1.4.2.13  2005/04/20 02:25:59  ddiego
*fixes for single line text and formatting problems in text window creation.
*
*Revision 1.4.2.12  2005/03/29 05:00:16  ddiego
*fixed an issue in drawing borders when the controls render buffer is turned on.
*
*Revision 1.4.2.11  2005/03/29 04:25:37  ddiego
*fixed an issue in drawing borders when the controls render buffer is turned on.
*
*Revision 1.4.2.10  2005/03/20 04:29:21  ddiego
*added ability to set image lists for list box control.
*
*Revision 1.4.2.9  2005/03/15 05:29:00  ddiego
*makes the accelerator check logic a bit smarter and also changes
*teh way menu items test to check whether or not they are enabled.
*
*Revision 1.4.2.8  2005/03/14 04:17:22  ddiego
*adds a fix plus better handling of accelerator keys, ands auto menu title for the accelerator key data.
*
*Revision 1.4.2.7  2005/03/06 22:50:58  ddiego
*overhaul of RTTI macros. this includes changes to various examples to accommadate the new changes.
*
*Revision 1.4.2.6  2005/02/28 04:51:55  ddiego
*fixed issue in handling componenent state and events when in design mode
*
*Revision 1.4.2.5  2005/02/27 01:45:33  ddiego
*fixed bug in testing whether a path should be loaded as a bundle.
*added some additional rtti info for certain classes in app kit.
*
*Revision 1.4.2.4  2005/02/16 05:09:31  ddiego
*bunch o bug fixes and enhancements to the property editor and treelist control.
*
*Revision 1.4.2.3  2005/01/01 20:31:07  ddiego
*made an adjustment to quitting and event loop, and added some changes to the DefaultTabModel.
*
*Revision 1.4.2.2  2004/12/31 17:41:23  ddiego
*fixes a drag-drop bug, initially listed under the vcfbuilders
*bug list
*
*Revision 1.4.2.1  2004/12/31 17:39:47  ddiego
*fixes a drag-drop bug, initially listed under the vcfbuilders
*bug list
*Revision 1.4  2004/12/01 04:31:20  ddiego
*merged over devmain-0-6-6 code. Marcello did a kick ass job
*of fixing a nasty bug (1074768VCF application slows down modal dialogs.)
*that he found. Many, many thanks for this Marcello.
*

*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*

*Revision 1.2.2.10  2004/11/18 15:24:26  pallindo
*Fixed a line where there was a comment about a Font cast fix for some vc6 compilers, but the fix wasn't actually there.  So I just put it in.
*
*Revision 1.2.2.9  2004/11/03 05:10:45  ddiego
*osx open file now 95% functional - woot
*
*Revision 1.2.2.8  2004/10/23 18:10:41  ddiego
*mac osx updates, some more fixes for dialog code and for command button peer functionality
*
*Revision 1.2.2.7  2004/09/21 23:41:23  ddiego
*made some big changes to how the base list, tree, text, table, and tab models are laid out. They are not just plain interfaces. The actual
*concrete implementations of them now derive from BOTH Model and the specific
*tree, table, etc model interface.
*Also made some fixes to the way the text input is handled for a text control.
*We now process on a character by character basis and modify the model one
*character at a time. Previously we were just using brute force and setting
*the whole models text. This is more efficent, though its also more complex.
*
*Revision 1.2.2.6  2004/09/21 05:46:50  dougtinkham
*modified adjustViewableBoundsAndOriginForScrollable for new scrolling
*
*Revision 1.2.2.5  2004/09/12 22:34:21  ddiego
*fixed bug in handling window cleanup when exception thrown from constructor.
*
*Revision 1.2.2.4  2004/09/06 23:05:55  ddiego
*fixed border in button class
*
*Revision 1.2.2.3  2004/09/06 21:30:19  ddiego
*added a separate paintBorder call to Control class
*
*Revision 1.2.2.2  2004/08/21 21:06:52  ddiego
*migrated over the Resource code to the FoudationKit.
*Added support for a GraphicsResourceBundle that can get images.
*Changed the AbstractApplication class to call the System::getResourceBundle.
*Updated the various example code accordingly.
*
*Revision 1.2.2.1  2004/08/19 03:22:53  ddiego
*updates so new system tray code compiles
*
*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*
*Revision 1.2  2004/08/07 02:49:06  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.8  2004/07/23 04:20:56  ddiego
*more checkins
*
*Revision 1.1.2.7  2004/07/22 04:18:58  ddiego
*fixed bug 995642 delete LoalePeer in Locale, and added some miscellaneous changes to the QTPlayer. Also fixing (not finished yet) a bug that
*prevents the TreePeer from being properly notified when the tree model's
*item is deleted.
*
*Revision 1.1.2.6  2004/07/17 17:56:24  ddiego
*minor mods to the TableControl and the TabbedPages control
*so that drawing updates get drawn better, and we don't have weird missing
*artifacts.
*
*Revision 1.1.2.5  2004/07/14 21:54:41  ddiego
*attempts to fix problem with borders and drawing on common controls.
*Sort of works on editor control. There is a subtle repaint problem in painting
*damaged portions of the control.
*
*Revision 1.1.2.4  2004/07/12 02:05:45  ddiego
*fixed a subtle bug (that only showed up when using a lightweight
*control) that happened with MouseClick events being handled twice.
*
*Revision 1.1.2.3  2004/07/09 03:39:28  ddiego
*merged in changes from the OSX branch for new theming API. Added
*support for controlling the use of locale translated strings in components.
*
*Revision 1.1.2.2.2.1  2004/07/06 03:27:12  ddiego
*more osx updates that add proper support
*for lightweight controls, some fixes to text layout, and some window painting issues. Also a fix
*so that controls and windows paint either their default theme background or their background
*color.
*
*Revision 1.1.2.2  2004/04/29 03:43:13  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:15  ddiego
*migration towards new directory structure
*
*Revision 1.60.2.1  2004/04/09 06:08:21  ddiego
*nybbles and bytes
*
*Revision 1.60  2004/04/03 15:48:44  ddiego
*Merged over code from the 0-6-3 branch.
*
*Revision 1.59  2004/01/20 01:54:56  ddiego
*merged some more changes from dev branch, primarily changes to
*teh RTTI API so that we now process enum sets correctly (i.e. a long
*that is a mask made of enum values).
*
*Revision 1.57.2.8  2004/03/21 20:25:40  marcelloptr
*Scrollable automatically calculates the scroll given the line where to go
*
*Revision 1.57.2.7  2004/03/21 00:39:23  ddiego
*merged vc7.1 changes into dev branch
*
*Revision 1.57.2.6  2004/03/19 21:25:57  ddiego
*just some minor noodlin
*
*Revision 1.57.2.5  2004/03/17 03:22:27  ddiego
*fixed a glitch in setting focus
*
*Revision 1.57.2.4  2004/03/01 05:59:19  ddiego
*and even MORE updates to the TableControl. Most of the core functionality
from Chris Maunder's CGridCtrl has been migrated over, and is functional.
Item editing and item dragging is still not done. Had to make a minor change
to the AbstractScroallable class to allow it have vertical and/or horizontal
delegate's set in order to notify them of position changes. This was needed
by the TableControl to properly update the top left non fixed cell calculation.
The performance is kind of slow ( :) ) in debug mode, but quite snappy in release.

*Revision 1.57.2.3  2004/01/18 04:52:46  ddiego
*Added a new EnumSet class that handles manipulating unsigned longs
*as a mask of bits. Adds support for reading in the enum value names and
*ORing them together to form the complete mask value. Also made
*mods to the VFFOutput and VFFInput stream classes so that that the []
*property is correctly read and written
*
*Revision 1.57.2.2  2004/01/16 04:30:46  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.57.2.1  2004/01/15 05:35:04  ddiego
*making some minor changes so that nested menu components get handled
*correctly and added from a VFF file
*
*Revision 1.57.2.3  2004/01/18 04:52:46  ddiego
*Added a new EnumSet class that handles manipulating unsigned longs
*as a mask of bits. Adds support for reading in the enum value names and
*ORing them together to form the complete mask value. Also made
*mods to the VFFOutput and VFFInput stream classes so that that the []
*property is correctly read and written
*
*Revision 1.57.2.2  2004/01/16 04:30:46  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.57.2.1  2004/01/15 05:35:04  ddiego
*making some minor changes so that nested menu components get handled
*correctly and added from a VFF file
*

*Revision 1.57  2003/12/18 05:16:00  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.56.2.19  2003/12/02 05:50:05  ddiego
*added preliminary support for teh Action class. This will make it easier
*to hook up complimentary UI elements (such as a "copy" menu item, and a
*"copy" toolbar item) and have tehm respond to update and actions via a
*single source.
*Got rid of the old toolbar button and separator class. Merged in Marcellos
*new fixes for the Container and Splitter classes.
*Some misc fixes to the Toolbar, groups and checks now work correctly.
*
*Revision 1.56.2.18  2003/11/10 01:57:43  ddiego
*add a fromString methods to StingUtils
*added some minor fixes to list box control and added a SelectionChanged
*Delegate to it
*add some minor fixes ot ComboBoxControl
*added an unknownColor() method to ColorNames class
*
*Revision 1.56.2.17  2003/10/28 20:23:26  ddiego
*minor header changes
*
*Revision 1.56.2.16  2003/10/20 03:40:13  ddiego
* made some minor changes fixed a bug in color where we forget to actually
*assign hls/hsv values.
*
*Revision 1.56.2.15  2003/10/14 21:32:49  ddiego
*little change ?
*
*Revision 1.56.2.14  2003/10/14 04:31:07  ddiego
*some more adjustments to hack on getting the alignments to wrok better
*
*Revision 1.56.2.13  2003/10/13 04:02:51  ddiego
*fixed some issues with calculating the view bounds if scrollbar
*are present as well as adding some functions to get teh bounds of
*left/right and top/bottom spaces that can surround a scrollbar.
*
*Revision 1.56.2.12  2003/10/12 06:34:13  ddiego
*added some fixes to standard container layout algorithms - thisstill needs
*to be tested, but it looks like it may fix some outstanding issues
*with the layout logic
*
*Revision 1.56.2.11  2003/09/12 00:09:18  ddiego
*added better tabbing behaviour - fixed an earlier bug.
*Code is easier to understand and it simplified the implementation
*a bit as well
*Moved around the RTTI definitions for various Appkit classes to a
*single inline and stripped them from the various class headers
*
*Revision 1.56.2.10  2003/09/06 19:45:15  ddiego
*changes to ensure that the destroy() is properly called.
*Destructors were moved back to pbulic scope in case that was causing a bug.
*Moving them all(all teh component derived classes) to private scope causes
*a complete failure in hte VC6 compiler. Alas...
*So destructors are present, and modal dialogs can still be created on the
*stack, but almost any other component should be created on the heap, and
*gotten rid of via free() NOT using operator delete directly.
*also moved the vcs info to the end of the file for some of the headers
*This will be an ongoing process.
*
*Revision 1.56.2.9  2003/09/05 21:03:21  ddiego
*moved the various control destructor's to protected scope
*migrated code into destroy() overridden methods
*----------------------------------------------------------------------
*
*Revision 1.56.2.8  2003/09/02 02:11:13  ddiego
*fixed some glitches in drag drop. also cleaned up the drag drop event
*classes. Began some fixes to the html browser implementation on Win32
*
*Revision 1.56.2.7  2003/08/27 03:53:40  ddiego
*view model bug fix and image file name extension bug fix
*
*Revision 1.56.2.6  2003/08/26 03:16:49  ddiego
*added a syntax fix cause VC6 is too stupid to compile code correctly.
*Thanks to Marcello for pointing it out.
*
*Revision 1.56.2.5  2003/08/22 01:19:11  ddiego
*finally fixed the it so that lightweight controls can now host containers
*and and act as a parent for heavyweight controls
*
*Revision 1.56.2.4  2003/08/19 04:43:40  ddiego
*further code to support lightweight container implementation. Not quite
*finished
*
*Revision 1.56.2.3  2003/08/18 19:52:37  ddiego
*changed the Container from being a class you derive from to a separate
*intance that is created and assigned dynamically to any Control.
*
*Revision 1.56.2.2  2003/08/18 02:55:41  ddiego
*added fix for bug [ 789902 ] EnumeratorContainer::prevElement() points to container_->end, also added an example
*
*Revision 1.56.2.1  2003/08/12 02:52:55  ddiego
*added properties getBottom/getRight/setBottom/setRight to Control
*
*Revision 1.56  2003/08/09 02:56:45  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.55.2.9  2003/08/02 00:41:12  marcelloptr
*fixes for vc6;  improved dependencies
*
*Revision 1.55.2.8  2003/08/01 00:49:26  ddiego
*added a fix for popup windows that also fixed a problem with the
*ComboBoxControl drop down list disapearing.
*
*Revision 1.55.2.7  2003/07/24 04:10:43  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.55.2.6  2003/06/28 04:43:20  ddiego
*cleaned up the vcf/include/events directory and got rid of files, moving
*some of the various event handler template classes into the same header
*that the event handler's event is associated with
*also made some changes to properly take advantage of a Control's View, if it
*is set.
*
*Revision 1.55.2.5  2003/06/20 04:36:46  ddiego
*further AGG integration
*moved files over to renamed directories
*
*Revision 1.55.2.4  2003/06/17 03:54:26  ddiego
*further agg integration - took out the getImage/putImage from GraphicsContext -
*this was too slow. now have an alternate solution that seems to work OK
*
*Revision 1.55.2.3  2003/06/13 03:06:40  ddiego
*bug fixes for
*585238:	Modal dialog which makes a modal Dialog
*585239:	Painting weirdness in a modal dialog
*also some clean up of miscellaneous debug trace statements
*and implemented task
*79266 - change DebugInfo to be stack based
*
*Revision 1.55.2.2  2003/06/13 00:03:19  ddiego
*more xmake fixes for the new version
*bug fixes for bugs
*509004	Opening a modal Dialog causes flicker
*also have tooltips working again
*
*Revision 1.55.2.1  2003/05/27 04:45:39  ddiego
*doing some code cleanup to fix some bugs in the way dialogs and popups
*work in Win32 port. Cleaned up the ControlPeer and DialogPeer interfaces
*a bit.
*
*Revision 1.55  2003/05/17 20:37:47  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.54.2.3  2003/04/17 04:29:52  ddiego
*updated scintilla, added gtk support for the application kit, with stubs
*for the basic peers.
*
*Revision 1.54.2.2  2003/03/23 03:24:00  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.54.2.1  2003/03/12 03:13:04  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.54  2003/02/26 04:30:55  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.53.2.5  2003/02/24 05:42:19  ddiego
*moved the code for the VariantData calss into it's own header
*migrated to the new event style using Delegates instead of relying on
*the ugly macros that we were using before - same functionality though
*made sure everything still works and compiles, including neccessary
*changes in the VCF Builder so that it creates code in the new style
*This changes to teh new style of using Delegates completes task 58837
*
*Revision 1.53.2.4  2003/01/08 00:19:59  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.53.2.3  2002/12/27 23:04:59  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.53.2.2  2002/12/25 22:06:34  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.53.2.1  2002/12/02 00:38:36  ddiego
*more fixes to get the ApplicationKit to compile under mingw. Everything now
*compiles OK at this point.
*
*Revision 1.53  2002/11/18 00:46:09  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.52.4.3  2002/10/07 05:02:56  ddiego
*addeds some more gui work to teh TemplateNewClassDlg.
*
*Revision 1.52.4.2  2002/10/01 20:34:59  ddiego
*borders
*
*Revision 1.52.4.1  2002/09/27 23:38:36  ddiego
*added support for geting various layout information
*added support for drawing various graphics UI primitives like scroll buttons
*tabs, tab pages, etc, partially to have this support in place for use
*in MacOSX.
*Also added scrolling buttons to TabbedPages, this fixes task 56652 in the
*ApplicationKit list
*
*Revision 1.52  2002/09/12 03:26:06  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.51.6.4  2002/09/10 04:07:51  ddiego
*misc fixes plus now posting the TableControl::finishEditing as a event
*
*Revision 1.51.6.3  2002/09/06 05:24:52  ddiego
*fixed bug in TableControl where it does not proeprly finished the ItemEditor
*correctly on loss of focus for the editor's control
*
*Revision 1.51.6.2  2002/07/14 05:40:02  ddiego
**** empty log message ***
*
*Revision 1.51.6.1  2002/06/28 17:45:30  ddiego
*migrated over lucki's changes (from his branch) for drag drop
*compiles OK, made chages to control and UIToolkit as neccessary
*still testing though.
*
*Revision 1.51  2002/05/09 03:10:45  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.50  2002/03/31 19:54:33  ddiego
*fixed a release bug in the TreeListControl
*made sure that saving the state of a Frame works correctly
*
*Revision 1.49  2002/03/22 04:30:18  ddiego
*bug fixes for weird resizing of win32 common controls (it figures) with the
*new code I put in yesterday. Put back the old code and it seems to work OK.
*Sigh...
*
*Revision 1.48  2002/03/21 04:01:22  ddiego
*fixed [ 532894 ] bug using the Frame::setClientBounds()
*
*Revision 1.47  2002/03/21 01:36:36  ddiego
*fix [ 532623 ] alignment problem & [ 525214 ] alignment loss after resize JEC 20-03-2002
*there was an incorrect comparison being done in AbstractContainer::insertBefore() that
*was resulting in controls being respositioned in the incorrect order. Should be cool now.
*
*Revision 1.46.4.3  2002/05/01 00:28:42  ddiego
*put back a mod made to the Control::setFocus() method were the previous focus control would get a
*setFocus(false) call - this was causing an issue with sertain popup windows
*
*Revision 1.46.4.2  2002/04/27 15:52:41  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.46.4.1  2002/04/08 20:55:31  zzack
*changed include style
*
*Revision 1.46  2002/03/05 04:44:14  ddiego
*fixed 525664 TreeList enum bug
*fixed popup menus not appearing right when scrolled to a position beyond 0,0
*fixed multi select problems with double entries
*
*Revision 1.45  2002/02/20 04:07:59  ddiego
*consolidated event handling code a bit
*introduced a virtual handleEvent() method to Component
*clean up some of the event constants, so they are now localized in the
*appropriate control classes.
*
*Revision 1.44  2002/02/07 04:38:55  ddiego
*fixes to Win32Edit, which include problems with setting text, and a bug that
*caused it to crash in Win 98. All textControls now default to the "EDIT"
*window class unles they are multiline, in which case an attempt is made to
*load the richedit control, and if that fails then the EDIT class is used
*Removed responding to WM_COMMAND messages
*in the default parent in the Win32Toolkit, also to fix the Win32Edit crash in 9.x
*
*Revision 1.43  2002/01/24 01:46:50  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


