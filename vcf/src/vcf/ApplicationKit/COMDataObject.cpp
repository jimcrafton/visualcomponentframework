//COMDataObject.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/VCFCOM.h"
#include "vcf/ApplicationKit/ComUtils.h"
#include "vcf/ApplicationKit/COMDataObject.h"


using namespace VCFCOM;
using namespace VCF;


DataRendering::DataRendering()
{
	memset( &formatETC_, 0, sizeof(formatETC_) );
	memset( &storage_, 0, sizeof(storage_) );
	owner_ = NULL;

}

DataRendering::DataRendering( FORMATETC * formatETC, STGMEDIUM * stgMedium, IUnknown* newStorageOwner ):
	Object()
{
	memset( &formatETC_, 0, sizeof(formatETC_) );
	memset( &storage_, 0, sizeof(storage_) );
	owner_ = NULL;

	formatETC_ = *formatETC;
	storage_ = *stgMedium;
	owner_ = stgMedium->pUnkForRelease;
	storage_.pUnkForRelease = newStorageOwner;
}

DataRendering::~DataRendering()
{
	if ( NULL != owner_ ){
		owner_->Release();
		owner_ = NULL;
	}
}

VCF::String DataRendering::toString()
{
	VCF::String result;
	//result = format( "DataRendering @ %p \n", this );
	switch ( formatETC_.cfFormat ){
	case CF_BITMAP:{
		result += "formatETC_.cfFormat = CF_BITMAP";
				   }
		break;

	case CF_DIB:{
		result += "formatETC_.cfFormat = CF_DIB";
				}
		break;

	case CF_DIF:{
		result += "formatETC_.cfFormat = CF_DIF";
				}
		break;

	case CF_HDROP:{
		result += "formatETC_.cfFormat = CF_HDROP";
				  }
		break;

	case CF_METAFILEPICT:{
		result += "formatETC_.cfFormat = CF_METAFILEPICT";
						 }
		break;

	case CF_OEMTEXT:{
		result += "formatETC_.cfFormat = CF_OEMTEXT";
					}
		break;

	case CF_TEXT:{
		result += "formatETC_.cfFormat = CF_TEXT";
				 }
		break;

	case CF_WAVE:{
		result += "formatETC_.cfFormat = CF_WAVE";
				 }
		break;

	case CF_TIFF:{
		result += "formatETC_.cfFormat = CF_TIFF";
				 }
		break;
	};
	return result;
}

/**
*COMDataObject
*/

COMDataObject::COMDataObject( IDataObject* outerDataObject ):
	ref_(0),
	dataObj_(NULL),
	outerDataObject_(outerDataObject)
{

}

COMDataObject::~COMDataObject()
{
	//dataObj_->release();
}


STDMETHODIMP COMDataObject::GetData( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
	HRESULT result = E_FAIL;

	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->GetData( formatETC, stgMedium );
	}
	else {
		if ( (NULL == formatETC) || (NULL == stgMedium) ){
			result = DATA_E_FORMATETC;
		}
		else{
			result = DATA_E_FORMATETC;

			DataRendering dataRender = findDataRenderingForType( formatETC );

			if ( !dataRender.isEmpty() ){
				if ( TYMED_ISTORAGE == dataRender.formatETC_.tymed ){
					dataRender.storage_.pstg->AddRef();
				}
				if ( TYMED_ISTREAM == dataRender.formatETC_.tymed){
					dataRender.storage_.pstm->AddRef();
				}

				*stgMedium = dataRender.storage_;
				AddRef();
				result = S_OK;
			}
		}
	}
	return result;
}

STDMETHODIMP COMDataObject::GetDataHere( FORMATETC * formatETC, STGMEDIUM * stgMedium )
{
	HRESULT result = E_NOTIMPL;

	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->GetDataHere( formatETC, stgMedium );
	}
	return result;
}

STDMETHODIMP COMDataObject::QueryGetData( FORMATETC * formatETC )
{

	HRESULT result = E_FAIL;


	if ( NULL==formatETC ){
        return DATA_E_FORMATETC;
	}

	if ( !findDataRenderingForType( formatETC ).isEmpty() ){
		result = S_OK;//NOERROR;
	}
	else {
		result = DATA_E_FORMATETC;
	}

	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->QueryGetData( formatETC );
	}
	return result;
}

STDMETHODIMP COMDataObject::GetCanonicalFormatEtc( FORMATETC * formatETCIn, FORMATETC * formatETCOut )
{
	HRESULT result = DATA_S_SAMEFORMATETC;

	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->GetCanonicalFormatEtc( formatETCIn, formatETCOut );
	}

	return result;
}

/**
* if the releaseData is false we cannot go on - Our data objects need to release the data.
*This may change in future releases.
*if the FormatETC or stgMedium passed in are NULL we should also quit - can't do anything
*otherwise we do the following:
*	1.) Create a data Rendering and add it to the vector renderings_.
*	2.)
*/
STDMETHODIMP COMDataObject::SetData( FORMATETC * formatETC, STGMEDIUM * stgMedium, BOOL releaseData )
{
	HRESULT result = E_NOTIMPL;
	//ClipboardDataObject_
	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->SetData( formatETC, stgMedium, releaseData );
	}
	else {
		if ( false  == releaseData ){
			result = E_FAIL;
		}
		else if ( (NULL==formatETC) || (NULL==stgMedium) ){
			//clean out the clipboard data
			result = E_FAIL;
		}
		else {
			renderings_.push_back( DataRendering( formatETC,  stgMedium, (IUnknown*)(this) ) );
			result = S_OK;
		}
	}
	return result;
}

STDMETHODIMP COMDataObject::EnumFormatEtc( DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc )
{

	HRESULT result = E_FAIL;

	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->EnumFormatEtc( dwDirection, ppenumFormatetc );
	}
	else {
		*ppenumFormatetc = NULL;
		EnumFormatETC* enumObj = NULL;
		switch ( dwDirection ){
			case DATADIR_GET:{
				enumObj = new EnumFormatETC();
			}
			break;

			case DATADIR_SET: default:{
				enumObj = NULL;
			}
			break;
		}

		if ( NULL == enumObj ){
			result = E_FAIL;
		}
		else{
			//Let the enumerator copy our format list.
			for ( std::vector<DataRendering>::iterator it = renderings_.begin(); it != renderings_.end(); it++ ){
				DataRendering& render = *it;
				enumObj->add( render.formatETC_ );
			}
			enumObj->Reset();
			enumObj->AddRef();

			result  = S_OK;
		}

		*ppenumFormatetc = dynamic_cast<IEnumFORMATETC*>(enumObj);
	}
	return result;
}

STDMETHODIMP COMDataObject::DAdvise( FORMATETC * formatETC, DWORD advf, IAdviseSink * pAdvSink,  DWORD * pdwConnection )
{
	HRESULT result = OLE_E_ADVISENOTSUPPORTED;
	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->DAdvise( formatETC, advf, pAdvSink, pdwConnection );
	}
	return result;
}

STDMETHODIMP COMDataObject::DUnadvise( DWORD dwConnection )
{
	HRESULT result = OLE_E_ADVISENOTSUPPORTED;
	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->DUnadvise( dwConnection );
	}
	return result ;
}

STDMETHODIMP COMDataObject::EnumDAdvise( IEnumSTATDATA ** ppenumAdvise )
{
	HRESULT result = OLE_E_ADVISENOTSUPPORTED;
	if ( NULL != outerDataObject_ ){
		result = outerDataObject_->EnumDAdvise( ppenumAdvise );
	}
	return result;
}

bool COMDataObject::isTypeSupported(const String& dataType)
{
	if ( NULL == dataObj_ ) {
		return false;
	}
	return dataObj_->isTypeSupported(dataType);
}

void COMDataObject::setDataObject( VCF::DataObject* data )
{
	dataObj_ = data;
	dataObj_->addRef();

	Enumerator<String>* types = dataObj_->getSupportedDataTypes();
	while ( types->hasMoreElements() ) {
		String type = types->nextElement();

		VCF::MemoryStream memStream;
		//Write the data to the mem stream

		if ( dataObj_->saveToStream( type, &memStream ) ) {
			memStream.seek( 0, stSeekFromStart );
			STGMEDIUM stgMedium;
			memset( &stgMedium, 0, sizeof(STGMEDIUM) );
			FORMATETC fmtETC = translateFrameworkFormatToFormatETC( type );
			stgMedium.tymed = fmtETC.tymed;
			//stgMedium.pUnkForRelease = AS_IUNKNOWN(this);
			stgMedium.hGlobal =
				::GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, memStream.getSize() );


			if ( 0 != stgMedium.hGlobal ){
				char* globalMemPtr = (char*)::GlobalLock( stgMedium.hGlobal );
				if ( NULL != globalMemPtr ){
					memStream.read( globalMemPtr, memStream.getSize() );
				}
				GlobalUnlock( stgMedium.hGlobal );

				if ( S_OK != SetData( &fmtETC, &stgMedium, true ) ){
					//throw exception ?
				}
			}
		}
	}
}



DataRendering COMDataObject::findDataRenderingForType( FORMATETC* formatETC )
{
	DataRendering result;
	bool found = false;

	if ( NULL != formatETC ){

		for ( std::vector<DataRendering>::iterator it = renderings_.begin(); it != renderings_.end(); it++ ){
			DataRendering& dataRender = *it;

			found = (dataRender.formatETC_.cfFormat == formatETC->cfFormat);

			if ( true == found ){
				result = dataRender;
				break;
			}
		}
	}
	return result;
}

UINT COMDataObject::translateFrameworkFormat( const String& dataType )
{
	FORMATETC result = COMUtils::translateDataTypeToWin32( dataType );

	return result.cfFormat;
}

FORMATETC COMDataObject::translateFrameworkFormatToFormatETC( const String& dataType )
{
	return COMUtils::translateDataTypeToWin32( dataType );
}

String COMDataObject::translateClipboardFmt( const UINT& fmtType )
{
	String result = "";
	switch ( fmtType ){
		case CF_BITMAP:{
			result += "CF_BITMAP";
		}
		break;

		case CF_DIB:{
			result += "CF_DIB";
		}
		break;

		case CF_DIF:{
			result += "CF_DIF";
		}
		break;

		case CF_HDROP:{
			result += "CF_HDROP";
		}
		break;

		case CF_METAFILEPICT:{
			result += "CF_METAFILEPICT";
		}
		break;

		case CF_OEMTEXT:{
			result += "CF_OEMTEXT";
		}
		break;

		case CF_TEXT:{
			result += "CF_TEXT";
		}
		break;

		case CF_WAVE:{
			result += "CF_WAVE";
		}
		break;

		case CF_TIFF:{
			result += "CF_TIFF";
		}
		break;

		default:{
			char s[256];
			sprintf( s, " %d", fmtType );
			result = s;
		};
		break;
	};
	return result;
};


/**
*CVS Log info
*$Log$
*Revision 1.2  2004/08/07 02:49:05  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.2  2004/04/29 03:43:12  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:14  ddiego
*migration towards new directory structure
*
*Revision 1.3  2003/12/18 05:16:01  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.2.2.3  2003/10/24 04:03:37  ddiego
*More header musical chairs
*
*Revision 1.2.2.2  2003/09/16 21:21:19  ddiego
*freed up the DataObject the com DO held onto
*added support for dynamically get the caption's of tree items
*
*Revision 1.2.2.1  2003/08/27 20:11:48  ddiego
*adjustments to how hte DataObject class work and copy/paste
*
*Revision 1.2  2003/08/09 02:56:46  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.1.2.2  2003/06/27 03:10:59  ddiego
*got rid of some redundant junk in the Clipboard and DataObject
*classes. Instead of a rather dippy use of the DataType calss, we now simply
*use pure mime-types to identify the various "flavours" of data.
*
*Revision 1.1.2.1  2003/05/25 19:07:13  ddiego
*fixed bug [ 524878 ] onDropped not called for MLTcontrol. This
*was due to errors in the drag-drop implementation for WIn32 and is
*now fixed.
*Also cleaned up the drag-drop implementation and moved/deleted a number of
*irrelevant files for COM support. The vcf/include/com and vcf/src/COM
*directories are now gotten rid of.
*
*Revision 1.11  2003/05/17 20:37:17  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.10.2.2  2003/03/23 03:23:53  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.10.2.1  2003/03/12 03:11:53  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.10  2003/02/26 04:30:44  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.9.8.3  2003/01/08 00:19:48  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.9.8.2  2002/12/27 23:04:45  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.9.8.1  2002/12/02 00:38:35  ddiego
*more fixes to get the ApplicationKit to compile under mingw. Everything now
*compiles OK at this point.
*
*Revision 1.9  2002/09/12 03:26:05  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.8.6.1  2002/06/28 17:45:30  ddiego
*migrated over lucki's changes (from his branch) for drag drop
*compiles OK, made chages to control and UIToolkit as neccessary
*still testing though.
*
*Revision 1.8  2002/05/09 03:10:44  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.7.4.2  2002/04/27 15:52:21  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.7.4.1  2002/04/08 20:55:29  zzack
*changed include style
*
*Revision 1.7  2002/02/14 05:04:52  ddiego
*documentation...
*
*Revision 1.6  2002/01/24 01:46:49  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


