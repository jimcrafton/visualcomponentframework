//UIToolkit.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */

#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ApplicationKitPrivate.h"
#include "vcf/ApplicationKit/DefaultPropertyEditors.h"
#include "vcf/ApplicationKit/ImageControl.h"
#include "vcf/ApplicationKit/MenuManager.h"

//Peers

using namespace VCF;

UIToolkit* UIToolkit::toolKitInstance = NULL;

static Control* prevTabbedControlContainer = NULL;

UIToolkit::UIToolkit():
	systemClipboard_(NULL),
	graphicsToolKit_(NULL),
	stopImage_(NULL),
	warningImage_(NULL),
	informationImage_(NULL),
	questionImage_(NULL),
	acceleratorMnemonicHandler_(NULL),
	defaultButtonHandler_(NULL),
	metricsMgr_(NULL),
	policyMgr_(NULL)
{
	acceleratorMnemonicHandler_ =
		new KeyboardEventHandler<UIToolkit>( this, &UIToolkit::onAcceleratorMnemonic );

	defaultButtonHandler_ =
		new KeyboardEventHandler<UIToolkit>( this, &UIToolkit::onDefaultButton );

	Component::initComponentRegistrar();
}

UIToolkit::~UIToolkit()
{
	std::multimap<ulong32,AcceleratorKey*>::iterator it = acceleratorMap_.begin();
	while ( it != acceleratorMap_.end() ) {
		delete it->second;
		it ++;
	}
	acceleratorMap_.clear();

	std::map<String,ComponentInfo*>::iterator it2 = componentInfoMap_.begin();
	while( it2 != componentInfoMap_.end() ) {
		ComponentInfo* info = it2->second;
		delete info;
		info = NULL;
		it2++;
	}
	componentInfoMap_.clear();

	delete systemClipboard_;

	Component::clearRegistedComponents();

	MenuManager::terminate();

	delete stopImage_;
	delete warningImage_;
	delete informationImage_;
	delete questionImage_;

	delete acceleratorMnemonicHandler_;
	acceleratorMnemonicHandler_ = NULL;

	delete defaultButtonHandler_;
	defaultButtonHandler_ = NULL;

	metricsMgr_->free();
}

void UIToolkit::init()
{


	systemClipboard_ = new Clipboard();
	/**
	*register basic property editors
	*/

	PropertyEditorManager::registerPropertyEditor( "VCF::IntegerPropertyEditor", CLASS_INTEGER );
	PropertyEditorManager::registerPropertyEditor( "VCF::DoublePropertyEditor", CLASS_DOUBLE );
	PropertyEditorManager::registerPropertyEditor( "VCF::BoolPropertyEditor", CLASS_BOOL );
	PropertyEditorManager::registerPropertyEditor( "VCF::StringPropertyEditor", CLASS_STRING );

	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::AlignmentType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::IconStyleType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::IconAlignType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::TextAlignmentType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::TextVerticalAlignment" );

	PropertyEditorManager::registerPropertyEditor( "VCF::ColorPropertyEditor", "VCF::Color" );
	PropertyEditorManager::registerPropertyEditor( "VCF::FontPropertyEditor", "VCF::Font" );
	PropertyEditorManager::registerPropertyEditor( "VCF::DefaultMenuItemPropertyEditor", "VCF::DefaultMenuItem" );
	PropertyEditorManager::registerPropertyEditor( "VCF::DefaultListModelPropertyEditor", "VCF::DefaultListModel" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImageFilenamePropertyEditor", "VCF::ImageFilenameString" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImagePropertyEditor", "VCF::Image" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImagePropertyEditor", "VCF::Win32Image" );

	/**
	register the components in categorys
	It's entirely possible that this might ultimately make more sense moved to the 
	VCF Builder at one point.
	*/

	Component::registerComponent( "VCF::TabbedPages", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Panel", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CommandButton", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListViewControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TreeControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::MultilineTextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Label", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CheckBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::RadioButtonControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::SliderControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ProgressControl", STANDARD_CATEGORY );

	Component::registerComponent( "VCF::MenuBar", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::PopupMenu", STANDARD_CATEGORY );

	Component::registerComponent( "VCF::TimerComponent", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::ScrollbarManager", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::SystemTray", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::PushButton", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::OpenGLControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::ImageControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::HTMLBrowserControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::TableControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::Splitter", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::TreeListControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::HeaderControl", ADDITIONAL_CATEGORY );

	Component::registerComponent( "VCF::Basic3DBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::EtchedBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::ColorEtchedBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::Light3DBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::TitledBorder", BORDER_CATEGORY );


	Component::registerComponent( "VCF::StandardContainer", CONTAINER_CATEGORY );
	Component::registerComponent( "VCF::ColumnLayoutContainer", CONTAINER_CATEGORY );
	Component::registerComponent( "VCF::HorizontalLayoutContainer", CONTAINER_CATEGORY );


	internal_setUpdateTimerSpeed( UIToolkit::defaultUpdateSpeed );

	MenuManager::create();
	//Desktop::getDesktop()->init();
}

void UIToolkit::initToolKit()
{
	if ( NULL == UIToolkit::toolKitInstance ) {
#ifdef WIN32
		UIToolkit::toolKitInstance = new Win32ToolKit();
#elif VCF_X11
		UIToolkit::toolKitInstance = new X11UIToolkit();
#elif VCF_GTK
		UIToolkit::toolKitInstance = new GTKUIToolkit();
#elif VCF_OSX
		UIToolkit::toolKitInstance = new OSXUIToolkit();
#endif

		if ( NULL == UIToolkit::toolKitInstance ) {
			//Damn the UI toolkit is STILL NULL !!!
			//Well that means we are well and truly screwed, so lets get out of Dodge pardner!
			throw NoToolKitFoundException( MAKE_ERROR_MSG_2(NO_TOOLKIT_ERROR));
		}


		//inialize the toolkit instance
		((UIToolkit*)UIToolkit::toolKitInstance)->init();

		//verify the presence of a valid UIMetricsManager instance
		if ( NULL == UIToolkit::toolKitInstance->metricsMgr_ ) {
			//Oops! we're screwed, do not pass GO, do NOT collect $200!
			throw InvalidPointerException( MAKE_ERROR_MSG_2("This implementation of the UIToolkit does NOT have a valid instance of a UIMetricsManager! Please fix this!") );
		}
	}
}

void UIToolkit::closeToolkit()
{
	delete UIToolkit::toolKitInstance;
	UIToolkit::toolKitInstance = NULL;
}

UIToolkit* UIToolkit::internal_getDefaultUIToolkit()
{
	return UIToolkit::toolKitInstance;
}




ControlPeer* UIToolkit::createControlPeer( Control* component, ComponentType componentType)
{
	return UIToolkit::toolKitInstance->internal_createControlPeer( component, componentType );
}

ContextPeer* UIToolkit::createContextPeer( Control* component )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( component );
}

ContextPeer* UIToolkit::createContextPeer( OSHandleID contextID )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( contextID );
}

ContextPeer* UIToolkit::createContextPeer( const unsigned long& width, const unsigned long& height )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( width, height );
}

ListviewPeer* UIToolkit::createListViewPeer( ListViewControl* component)
{
	return UIToolkit::toolKitInstance->internal_createListViewPeer( component );
}

TreePeer* UIToolkit::createTreePeer( TreeControl* component)
{
	return UIToolkit::toolKitInstance->internal_createTreePeer( component );
}

TextPeer* UIToolkit::createTextPeer( const bool& autoWordWrap, const bool& multiLined )
{
	return UIToolkit::toolKitInstance->internal_createTextPeer( autoWordWrap,multiLined );
}

TextEditPeer* UIToolkit::createTextEditPeer( TextControl* component, const bool& isMultiLineControl)
{
	return UIToolkit::toolKitInstance->internal_createTextEditPeer( component, isMultiLineControl );
}

HTMLBrowserPeer* UIToolkit::createHTMLBrowserPeer( Control* control )
{
	return UIToolkit::toolKitInstance->internal_createHTMLBrowserPeer( control );
}

ButtonPeer* UIToolkit::createButtonPeer( CommandButton* component)
{
	return UIToolkit::toolKitInstance->internal_createButtonPeer( component );
}

DialogPeer* UIToolkit::createDialogPeer( Control* owner, Dialog* component)
{
	return UIToolkit::toolKitInstance->internal_createDialogPeer( owner, component );
}

DialogPeer* UIToolkit::createDialogPeer()
{
	return UIToolkit::toolKitInstance->internal_createDialogPeer();
}

WindowPeer* UIToolkit::createWindowPeer( Control* component, Control* owner)
{
	return UIToolkit::toolKitInstance->internal_createWindowPeer( component, owner );
}

ToolbarPeer* UIToolkit::createToolbarPeer( Toolbar* toolbar )
{
	return UIToolkit::toolKitInstance->internal_createToolbarPeer( toolbar );
}

MenuItemPeer* UIToolkit::createMenuItemPeer( MenuItem* item )
{
	return UIToolkit::toolKitInstance->internal_createMenuItemPeer( item );
}

MenuBarPeer* UIToolkit::createMenuBarPeer( MenuBar* menuBar )
{
	return UIToolkit::toolKitInstance->internal_createMenuBarPeer( menuBar );
}

PopupMenuPeer* UIToolkit::createPopupMenuPeer( PopupMenu* popupMenu )
{
	return UIToolkit::toolKitInstance->internal_createPopupMenuPeer( popupMenu );
}

ClipboardPeer* UIToolkit::createClipboardPeer()
{
	return UIToolkit::toolKitInstance->internal_createClipboardPeer();
}

DragDropPeer* UIToolkit::createDragDropPeer()
{
	return UIToolkit::toolKitInstance->internal_createDragDropPeer();
}

DataObjectPeer* UIToolkit::createDataObjectPeer()
{
	return UIToolkit::toolKitInstance->internal_createDataObjectPeer();
}

DropTargetPeer* UIToolkit::createDropTargetPeer()
{
	return UIToolkit::toolKitInstance->internal_createDropTargetPeer();
}

ApplicationPeer* UIToolkit::createApplicationPeer()
{
	return UIToolkit::toolKitInstance->internal_createApplicationPeer();
}

Clipboard* UIToolkit::getSystemClipboard()
{
	return UIToolkit::toolKitInstance->internal_getSystemClipboard();
}

CommonFileDialogPeer* UIToolkit::createCommonFileOpenDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFileOpenDialogPeer( owner );
}

CommonFolderBrowseDialogPeer* UIToolkit::createCommonFolderBrowseDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFolderBrowseDialogPeer( owner );
}

CommonFileDialogPeer* UIToolkit::createCommonFileSaveDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFileSaveDialogPeer( owner );
}

CommonColorDialogPeer* UIToolkit::createCommonColorDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonColorDialogPeer( owner );
}

CommonFontDialogPeer* UIToolkit::createCommonFontDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFontDialogPeer( owner );
}

CommonPrintDialogPeer* UIToolkit::createCommonPrintDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonPrintDialogPeer( owner );
}

DesktopPeer* UIToolkit::createDesktopPeer( Desktop* desktop )
{
	return UIToolkit::toolKitInstance->internal_createDesktopPeer( desktop );
}

ScrollPeer* UIToolkit::createScrollPeer( Control* control )
{
	return UIToolkit::toolKitInstance->internal_createScrollPeer( control );
}

CursorPeer* UIToolkit::createCursorPeer( Cursor* cursor )
{
	return UIToolkit::toolKitInstance->internal_createCursorPeer( cursor );
}

SystemTrayPeer* UIToolkit::createSystemTrayPeer()
{
	return UIToolkit::toolKitInstance->internal_createSystemTrayPeer();
}

MenuManagerPeer* UIToolkit::createMenuManagerPeer()
{
	return UIToolkit::toolKitInstance->internal_createMenuManagerPeer();
}

GraphicsResourceBundlePeer* UIToolkit::createGraphicsResourceBundlePeer( AbstractApplication* app )
{
	return UIToolkit::toolKitInstance->internal_createGraphicsResourceBundlePeer( app );
}

bool UIToolkit::createCaret( Control* owningControl, Image* caretImage  )
{
	return UIToolkit::toolKitInstance->internal_createCaret( owningControl, caretImage );
}

bool UIToolkit::destroyCaret( Control* owningControl )
{
	return UIToolkit::toolKitInstance->internal_destroyCaret( owningControl );
}

void UIToolkit::setCaretVisible( const bool& caretVisible )
{
	UIToolkit::toolKitInstance->internal_setCaretVisible( caretVisible );
}

void UIToolkit::setCaretPos( Point* point )
{
	UIToolkit::toolKitInstance->internal_setCaretPos( point );
}

void UIToolkit::postEvent( EventHandler* eventHandler, Event* event, const bool& deleteHandler )
{
	UIToolkit::toolKitInstance->internal_postEvent( eventHandler, event, deleteHandler );
}

void UIToolkit::registerTimerHandler( Object* source, EventHandler* handler, const ulong32& timeoutInMilliSeconds )
{
	UIToolkit::toolKitInstance->internal_registerTimerHandler( source, handler, timeoutInMilliSeconds );
}

void UIToolkit::unregisterTimerHandler( EventHandler* handler )
{
	UIToolkit::toolKitInstance->internal_unregisterTimerHandler( handler );
}

void UIToolkit::runEventLoop()
{
	UIToolkit::toolKitInstance->internal_runEventLoop();
}

UIToolkit::ModalReturnType UIToolkit::runModalEventLoopFor( Control* control )
{
	return UIToolkit::toolKitInstance->internal_runModalEventLoopFor( control );
}


void UIToolkit::quitCurrentEventLoop()
{
	UIToolkit::toolKitInstance->internal_quitCurrentEventLoop();
}

Event* UIToolkit::createEventFromNativeOSEventData( void* eventData )
{
	return UIToolkit::toolKitInstance->internal_createEventFromNativeOSEventData( eventData );
}

VCF::Size UIToolkit::getDragDropDelta()
{
	return UIToolkit::toolKitInstance->internal_getDragDropDelta();
}

const Image* UIToolkit::getStandardStopImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardStopImage();
}

const Image* UIToolkit::getStandardWarningImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardWarningImage();
}

const Image* UIToolkit::getStandardQuestionImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardQuestionImage();
}

const Image* UIToolkit::getStandardInformationImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardInformationImage();
}

void UIToolkit::registerComponentInfo( const String& componentUUID, ComponentInfo* info )
{
	UIToolkit::toolKitInstance->internal_registerComponentInfo( componentUUID, info );
}

void UIToolkit::removeComponentInfo( ComponentInfo* info )
{
	UIToolkit::toolKitInstance->internal_removeComponentInfo( info );
}

void UIToolkit::registerAccelerator( AcceleratorKey* accelerator )
{
	UIToolkit::toolKitInstance->internal_registerAccelerator( accelerator );
}

void UIToolkit::removeAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask, Object* src )
{
	UIToolkit::toolKitInstance->internal_removeAccelerator( keyCode, modifierMask, src );
}

VCF::Button* UIToolkit::getDefaultButton()
{
	return UIToolkit::toolKitInstance->internal_getDefaultButton();
}

void UIToolkit::setDefaultButton( Button* defaultButton )
{
	UIToolkit::toolKitInstance->internal_setDefaultButton( defaultButton );
}

void UIToolkit::removeDefaultButton( Button* defaultButton )
{
	UIToolkit::toolKitInstance->internal_removeDefaultButton( defaultButton );
}

AcceleratorKey* UIToolkit::getAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask, Object* src )
{
	return UIToolkit::toolKitInstance->internal_getAccelerator( keyCode, modifierMask, src );
}

bool UIToolkit::findMatchingAccelerators( AcceleratorKey* key, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	return UIToolkit::toolKitInstance->internal_findMatchingAccelerators( key, matchingAccelerators );
}

void UIToolkit::removeAcceleratorKeysForControl( Control* control )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForControl( control );
}

void UIToolkit::removeAcceleratorKeysForMenuItem( MenuItem* item )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForMenuItem( item );
}

void UIToolkit::removeAcceleratorKeysForObject( Object* src )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForObject( src );
}


void UIToolkit::handleKeyboardEvent( KeyboardEvent* event )
{
	UIToolkit::toolKitInstance->internal_handleKeyboardEvent( event );
}

VirtualKeyCode UIToolkit::findMnemonic( const String& caption )
{
	return UIToolkit::toolKitInstance->internal_findMnemonic( caption );
}

ComponentInfo* UIToolkit::getComponentInfo( const String& componentUUID )
{
	return UIToolkit::toolKitInstance->internal_getComponentInfo( componentUUID );
}

ComponentInfo* UIToolkit::getComponentInfo( Class* componentClass )
{
	return UIToolkit::toolKitInstance->internal_getComponentInfo( componentClass );
}

UIMetricsManager* UIToolkit::getUIMetricsManager()
{
	return UIToolkit::toolKitInstance->internal_getUIMetricsManager();
}

UIPolicyManager* UIToolkit::getUIPolicyManager()
{
	return UIToolkit::toolKitInstance->internal_getUIPolicyManager();
}










Clipboard* UIToolkit::internal_getSystemClipboard()
{
	return systemClipboard_;
}



ContextPeer* UIToolkit::internal_createContextPeer( OSHandleID contextID )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return graphicsToolKit_->createContextPeer( contextID );
}

ContextPeer* UIToolkit::internal_createContextPeer( Control* component )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return NULL;//graphicsToolKit_->createContextPeer( component );
}

ContextPeer* UIToolkit::internal_createContextPeer( const unsigned long& width, const unsigned long& height )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return graphicsToolKit_->createContextPeer( width, height );
}


void UIToolkit::internal_registerComponentInfo( const String& componentUUID, ComponentInfo* info )
{
	if ( componentUUID != info->getComponentUUID() ) {
		throw RuntimeException( "Attempting to register a component's info with a mismatched UUID." );
	}
	componentInfoMap_[ componentUUID ] = info;
}

ComponentInfo* UIToolkit::internal_getComponentInfo( const String& componentUUID )
{
	ComponentInfo* result = NULL;
	std::map< String,ComponentInfo*>::iterator found = componentInfoMap_.find( componentUUID );
	if ( found != componentInfoMap_.end() ) {
		result = found->second;
	}
	return result;
}

ComponentInfo* UIToolkit::internal_getComponentInfo( Class* componentClass )
{
	if ( NULL == componentClass ) {
		throw RuntimeException( "Can't get Component information from a NULL Class." );
	}
	return getComponentInfo( componentClass->getID() );
}

void UIToolkit::internal_removeComponentInfo( ComponentInfo* info )
{
	std::map< String,ComponentInfo*>::iterator found = componentInfoMap_.find( info->getComponentUUID() );
	if ( found != componentInfoMap_.end() ) {
		componentInfoMap_.erase( found );
	}
}

void UIToolkit::internal_registerAccelerator( AcceleratorKey* accelerator )
{
	AcceleratorKey::Value key;
	key = accelerator;	


	typedef std::multimap<ulong32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	std::multimap<ulong32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		if ( (accelerator->getAssociatedControl() == accel->getAssociatedControl()) && 
				(accelerator->getAssociatedMenuItem() == accel->getAssociatedMenuItem()) && 
				(accelerator->getAssociatedObject() == accel->getAssociatedObject()) ) {

			accel->free();
			//remove old entry!
			acceleratorMap_.erase( it );
			break;
		}

		it ++;
	}

	std::pair<ulong32,AcceleratorKey*> item(key,accelerator);
	acceleratorMap_.insert( item );
}

bool UIToolkit::internal_findMatchingAccelerators( AcceleratorKey* key, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	matchingAccelerators.clear();

	AcceleratorKey::Value keyVal;
	keyVal = key;

	typedef std::multimap<ulong32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( keyVal );

	std::multimap<ulong32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		// we don't need to put in the list the accelerator (key) to which all the others are matching.
		if ( (accel->getEventHandler() == key->getEventHandler()) && 
				(accel != key) ) {
			matchingAccelerators.push_back( accel );
		}

		it ++;
	}

	return !matchingAccelerators.empty();
}

AcceleratorKey* UIToolkit::internal_getAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask, Object* src )
{
	AcceleratorKey* result = NULL;

	AcceleratorKey::Value key( modifierMask, keyCode );


	typedef std::multimap<ulong32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	std::multimap<ulong32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		if ( (src == accel->getAssociatedControl()) || 
				(src == accel->getAssociatedMenuItem()) || 
				(src == accel->getAssociatedObject()) ) {

			result = accel;
			break;
		}

		it ++;
	}

	return result;
}

void internal_handleKeyboardButtonEvent ( Event* e )
{
	VCF::Button* button = (VCF::Button*)e->getUserData();

	if ( NULL != button ) {
		button->click();
	}
}

void UIToolkit::internal_handleKeyboardEvent( KeyboardEvent* event )
{
	if ( vkEscape == event->getVirtualCode() ) {
		Frame* frame = Frame::getActiveFrame();
		if ( NULL != frame ) {
			Event* e = (Event*)event->clone();
			e->setType( Control::KEYBOARD_DOWN );
			frame->handleEvent( e );
			if ( e->isConsumed() ) {
				e->free();
				return;
			}
			e->free();
		}
	}

	AcceleratorKey::Value key( event->getKeyMask(), event->getVirtualCode() );

	typedef std::multimap<ulong32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	//look for accelerator in control then app
	AcceleratorKey* accelerator = NULL;
	Control* control = (Control*)event->getSource();


	AccelMapIter it = range.first;
	if ( control ) {
		if ( control->areParentsEnabled() ) {

			while ( it != range.second ) {

				AcceleratorKey* accel = it->second;
				// check if the control associated to this accelerator is the same having the focus
				if ( accel->getAssociatedControl() == control ) {
					accelerator = accel;
					break;
				}

				it ++;
			}
		}
	}




	//if accelerator is still null try and find the first matching menu item
	if ( NULL == accelerator ) {
		it = range.first;
		while ( it != range.second ) {
			AcceleratorKey* accel = it->second;
			if ( accel->getAssociatedMenuItem() != NULL ) {
				accelerator = accel;
				//check to make sure the menu item's frame is enabled!
				if ( NULL != accel ) {
					MenuItem* mi = accel->getAssociatedMenuItem();
					mi->update();
				}
				break;
			}

			it ++;
		}
	}

	//if accelerator is still null try and find the first matching object
	if ( NULL == accelerator ) {
		it = range.first;
		while ( it != range.second ) {

			AcceleratorKey* accel = it->second;
			if ( accel->getAssociatedObject() != NULL ) {
				accelerator = accel;
				break;
			}

			it ++;
		}
	}


	if ( NULL != accelerator ) {

		EventHandler* ev = NULL;

		if ( accelerator->isMnemonic() ) {
			ev = acceleratorMnemonicHandler_;
		}
		else {
			ev = accelerator->getEventHandler();
		}

		if ( NULL != ev ) {
			if ( accelerator->isEnabled() ) {
				KeyboardEvent* acceleratorEvent = new KeyboardEvent( accelerator, Control::KEYBOARD_ACCELERATOR,
																	event->getRepeatCount(),
																	event->getKeyMask(),
																	event->getKeyValue(),
																	event->getVirtualCode() );

				postEvent( ev, acceleratorEvent, false );
			}

			//KeyboardEvent acceleratorEvent( accelerator, Control::KEYBOARD_ACCELERATOR,
			//														event->getRepeatCount(),
			//														event->getKeyMask(),
			//														event->getKeyValue(),
			//														event->getVirtualCode() );

			//ev->invoke( &acceleratorEvent );


			// as the event has been processed, we don't let it to be forwarded further to any other controls
			event->setConsumed( true );
		}
	}
	else if ( NULL != control ) {

		VirtualKeyCode keyCode = event->getVirtualCode();
		/**
		as per bug [ 585087 ] Get rid of arrow key tabbing
		I am commenting the arrow key tabbing out - will
		work out something better !
		*/
		switch( keyCode ) {

			case vkTab : /*case vkUpArrow : case vkDownArrow : case vkLeftArrow : case vkRightArrow :*/{
				handleTabKeyboardEvent( event );
			}
			break;

			case vkReturn :{

				if ( false == control->keepReturnCharacter() ) {
					//event->setConsumed( true );

					Button* button = getDefaultButton();

					Event* e = (Event*)event->clone();
					e->setUserData( button );

					postEvent( new StaticEventHandlerInstance<Event>(internal_handleKeyboardButtonEvent),
								e );

					/*
					if ( NULL != button ) {
						button->click();
					}
					*/
				}
			}
			break;
		}
	}
}

void UIToolkit::handleTabKeyboardEvent( KeyboardEvent* event )
{
	Control* control = (Control*) event->getSource();

	if ( !control->keepsTabKey() ) {
		bool goForward = !event->hasShiftKey();

		Control* currentFocused = Control::getCurrentFocusedControl();
		if ( NULL == currentFocused ) {
			currentFocused = control;
		}
		Frame* parentFrame = currentFocused->getParentFrame();

		std::vector<Control*> tabList;
		Control::buildTabList( parentFrame, tabList );

		Control* newFocusedControl = NULL;
		std::vector<Control*>::iterator found = std::find( tabList.begin(), tabList.end(), currentFocused );
		long index = -1;
		if ( found != tabList.end() ) {
			index = found - tabList.begin();
		}
		if ( goForward ) {
			index ++;

			if ( index >= tabList.size() ) {
				index = 0;
			}

			if ( index >= 0 ) {
				while ( index < tabList.size() ) {
					Control* c = tabList[index];
					if ( c->canAcceptFocus() ) {
						if ( c->getTabStop() ) {
							break;
						}
					}
					index++;
				}
			}

			if ( index >= tabList.size() ) {
				index = 0;
			}

		}
		else {
			index --;

			if ( index <= 0 ) {
				index = tabList.size()-1;
			}

			if ( index < tabList.size() ) {
				while ( index > -1 ) {
					Control* c = tabList[index];
					if ( c->canAcceptFocus() ) {
						if ( c->getTabStop() ) {
							break;
						}
					}
					index--;
				}
			}

			if ( index <= 0 ) {
				index = tabList.size()-1;
			}
		}


		newFocusedControl = tabList[index];
		newFocusedControl->setFocused();

		event->consume();
	}
}

const Image* UIToolkit::internal_getStandardStopImage()
{
	return stopImage_;
}

const Image* UIToolkit::internal_getStandardWarningImage()
{
	return warningImage_;
}

const Image* UIToolkit::internal_getStandardQuestionImage()
{
	return questionImage_;
}

const Image* UIToolkit::internal_getStandardInformationImage()
{
	return informationImage_;
}

void UIToolkit::onAcceleratorMnemonic( KeyboardEvent* event )
{
	 AcceleratorKey* accelerator = (AcceleratorKey*)event->getSource();
	 if ( NULL != accelerator ) {
		Control* control = accelerator->getAssociatedControl();
		if ( NULL != control ) {
			control->mnemonicActivate();
		}
	}
}

VirtualKeyCode UIToolkit::internal_findMnemonic( const String& caption )
{
	VirtualKeyCode result = vkUndefined;

#if (! defined _MSC_VER) || ( (_MSC_VER < 1300) || defined ( STLPORT ) )
	const VCFChar* P = caption.c_str();
#else
	const VCFChar* P = caption.c_str();
#endif
	const VCFChar* start = P;
	int size = caption.size();

	while ( (P - start) < size ) {
		if ( (*P == '&') && (((P - start)+1) < size) ) {
			VCFChar nextChar = *(P+1);
			//this is not locale or Unicode safe !
			if ( ((nextChar >= 'A') && (nextChar <= 'Z')) || ((nextChar >= 'a') && (nextChar <= 'z')) ) {
				if ( (nextChar >= 'A') && (nextChar <= 'Z') ) {
					result = (VirtualKeyCode)(vkLetterA + (nextChar - 'A'));
				}
				else {
					result = (VirtualKeyCode)(vkLetterA + (nextChar - 'a'));
				}
				break;
			}
			else if ( (nextChar >= '0') && (nextChar <= '9') ) {
				result = (VirtualKeyCode)(vkNumber0 + (nextChar - '0'));

				break;
			}
		}
		P++;
	}

	return result;
}

VCF::Button* UIToolkit::internal_getDefaultButton()
{
	Button* result = NULL;
	if ( ! defaultButtonList_.empty() ) {
		result = *defaultButtonList_.begin();
	}
	return result;
}

void UIToolkit::internal_setDefaultButton( Button* defaultButton )
{
	if ( true == defaultButtonList_.empty() ) {
		defaultButtonList_.push_back( defaultButton );
	}
	else {
		defaultButtonList_.insert( defaultButtonList_.begin(), defaultButton );
	}
}

void UIToolkit::onDefaultButton( KeyboardEvent* event )
{
	Control* control = (Control*)event->getSource();
	/*
	Control* buttonControl = dynamic_cast<Control*>(control);
	if ( (buttonControl == Control::getCurrentFocusedControl()) && (NULL != temporaryDefaultButton_) ) {
		temporaryDefaultButton_->click();
	}
	else if ( NULL != defaultButton_ ) {
		defaultButton_->click();
	}

  */

}

void UIToolkit::internal_removeDefaultButton( Button* defaultButton )
{
	std::vector<Button*>::iterator found = std::find( defaultButtonList_.begin(), defaultButtonList_.end(), defaultButton );
	if ( found != defaultButtonList_.end() ) {
		defaultButtonList_.erase( found );
	}
}

void UIToolkit::internal_removeAccelerator( const VirtualKeyCode& keyCode, const ulong32& modifierMask, Object* src )
{

	AcceleratorKey::Value key( modifierMask, keyCode );

	typedef std::multimap<ulong32,AcceleratorKey*>::iterator AccelMapIter;

	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );	

	std::vector<AccelMapIter> removeAccels;

	AccelMapIter it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;
		if ( (accel->getAssociatedControl() == src) || 
			(accel->getAssociatedMenuItem() == src) ||
			(accel->getAssociatedObject() == src) ) {
			accel->release();
			removeAccels.push_back( it );
		}

		it ++;
	}

	std::vector<AccelMapIter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}

void UIToolkit::internal_removeAcceleratorKeysForControl( Control* control )
{
	typedef std::multimap<ulong32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedControl() == control ) {
			accel->release();
			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}

}

void UIToolkit::internal_removeAcceleratorKeysForMenuItem( MenuItem* menuItem )
{
	typedef std::multimap<ulong32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedMenuItem() == menuItem ) {
			accel->release();
			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}

void UIToolkit::internal_removeAcceleratorKeysForObject( Object* src )
{
	typedef std::multimap<ulong32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedObject() == src ) {
			accel->release();
			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}


void UIToolkit::addToUpdateTimer( Component* component )
{
	UIToolkit::toolKitInstance->internal_addToUpdateTimer( component );
}

void UIToolkit::removeFromUpdateTimer( Component* component )
{
	UIToolkit::toolKitInstance->internal_removeFromUpdateTimer( component );
}

void UIToolkit::setUpdateTimerSpeed( const unsigned long& milliseconds )
{
	UIToolkit::toolKitInstance->internal_setUpdateTimerSpeed( milliseconds );
}

void UIToolkit::internal_addToUpdateTimer( Component* component )
{
	std::vector<Component*>::iterator found = std::find( componentsToUpdate_.begin(), componentsToUpdate_.end(), component );
	if ( found == componentsToUpdate_.end() ) {
		componentsToUpdate_.push_back( component );
	}
}

void UIToolkit::internal_removeFromUpdateTimer( Component* component )
{
	std::vector<Component*>::iterator found = std::find( componentsToUpdate_.begin(), componentsToUpdate_.end(), component );
	if ( found != componentsToUpdate_.end() ) {
		componentsToUpdate_.erase( found );
	}
}

void UIToolkit::internal_setUpdateTimerSpeed( const unsigned long& milliseconds )
{
	EventHandler* ev = getEventHandler( "UIToolkit::onUpdateComponentsTimer" );
	if ( NULL != ev ) {
		internal_unregisterTimerHandler( ev );
	}

	if ( NULL == ev ) {
		ev = new TimerEventHandler<UIToolkit>( this, &UIToolkit::onUpdateComponentsTimer, "UIToolkit::onUpdateComponentsTimer" );
	}

	internal_registerTimerHandler( this, ev, milliseconds );
}

void UIToolkit::onUpdateComponentsTimer( TimerEvent* e )
{
	std::vector<Component*>::iterator it = componentsToUpdate_.begin();
	while ( it != componentsToUpdate_.end() ) {
		Component* component = *it;
		Event updateEvent( this, Component::COMPONENT_NEEDS_UPDATING );
		component->handleEvent( &updateEvent );
		it ++;
	}
}


/**
*CVS Log info
*$Log$
*Revision 1.5  2005/07/09 23:14:56  ddiego
*merging in changes from devmain-0-6-7 branch.
*

*Revision 1.4  2005/01/02 03:04:21  ddiego
*merged over some of the changes from the dev branch because they're important resoource loading bug fixes. Also fixes a few other bugs as well.
*
*Revision 1.3.2.17  2005/06/08 03:27:26  ddiego
*fix for popup menus
*
*Revision 1.3.2.16  2005/06/06 02:34:06  ddiego
*menu changes to better support win32 and osx.
*
*Revision 1.3.2.15  2005/06/02 16:12:16  marcelloptr
*some more documentation
*
*Revision 1.3.2.14  2005/05/15 23:17:38  ddiego
*fixes for better accelerator handling, and various fixes in hwo the text model works.
*
*Revision 1.3.2.13  2005/05/04 00:36:17  marcelloptr
*the accelerator checks first for an unitialized menu item associated to an action... fixed
*
*Revision 1.3.2.12  2005/04/25 00:11:57  ddiego
*added more advanced text support. fixed some memory leaks. fixed some other miscellaneous things as well.
*
*Revision 1.3.2.11  2005/04/20 02:26:00  ddiego
*fixes for single line text and formatting problems in text window creation.
*
*Revision 1.3.2.10  2005/03/27 05:25:13  ddiego
*added more fixes to accelerator handling.
*
*Revision 1.3.2.9  2005/03/21 17:30:38  marcelloptr
*added a comment
*
*Revision 1.3.2.8  2005/03/15 05:29:01  ddiego
*makes the accelerator check logic a bit smarter and also changes
*teh way menu items test to check whether or not they are enabled.
*
*Revision 1.3.2.7  2005/03/14 04:17:24  ddiego
*adds a fix plus better handling of accelerator keys, ands auto menu title for the accelerator key data.
*
*Revision 1.3.2.6  2005/03/09 05:11:19  ddiego
*fixed property editor class.
*
*Revision 1.3.2.5  2005/03/06 22:50:59  ddiego
*overhaul of RTTI macros. this includes changes to various examples to accommadate the new changes.
*
*Revision 1.3.2.4  2005/02/28 04:51:56  ddiego
*fixed issue in handling componenent state and events when in design mode
*
*Revision 1.3.2.3  2005/02/21 16:20:02  ddiego
*minor changes to various things, property editors, and tree list control.
*
*Revision 1.3.2.2  2004/12/19 07:09:18  ddiego
*more modifications to better handle resource bundles, especially
*if they are part of a LibraryApplication instance.
*
*Revision 1.3.2.1  2004/12/19 04:04:59  ddiego
*made modifications to methods that return a handle type. Introduced
*a new typedef for handles, that is a pointer, as opposed to a 32bit int,
*which was causing a problem for 64bit compiles.
*
*Revision 1.3  2004/12/01 04:31:38  ddiego
*merged over devmain-0-6-6 code. Marcello did a kick ass job
*of fixing a nasty bug (1074768VCF application slows down modal dialogs.)
*that he found. Many, many thanks for this Marcello.
*
*Revision 1.2.2.4  2004/09/21 23:41:24  ddiego
*made some big changes to how the base list, tree, text, table, and tab models are laid out. They are not just plain interfaces. The actual
*concrete implementations of them now derive from BOTH Model and the specific
*tree, table, etc model interface.
*Also made some fixes to the way the text input is handled for a text control.
*We now process on a character by character basis and modify the model one
*character at a time. Previously we were just using brute force and setting
*the whole models text. This is more efficent, though its also more complex.
*
*Revision 1.2.2.3  2004/08/31 04:12:12  ddiego
*cleaned up the GraphicsContext class - made more pervasive use
*of transformation matrix. Added common print dialog class. Fleshed out
*printing example more.
*
*Revision 1.2.2.2  2004/08/19 03:22:54  ddiego
*updates so new system tray code compiles
*
*Revision 1.2.2.1  2004/08/18 21:20:24  ddiego
*added initial system tray code for win32
*
*Revision 1.2  2004/08/07 02:49:10  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.4  2004/05/23 14:11:59  ddiego
*osx updates
*
*Revision 1.1.2.3  2004/05/06 02:56:35  ddiego
*checking in OSX updates
*
*Revision 1.1.2.2  2004/04/29 03:43:15  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:19  ddiego
*migration towards new directory structure
*
*Revision 1.58  2004/04/03 15:48:50  ddiego
*Merged over code from the 0-6-3 branch.
*
*Revision 1.57  2004/01/20 01:54:57  ddiego
*merged some more changes from dev branch, primarily changes to
*teh RTTI API so that we now process enum sets correctly (i.e. a long
*that is a mask made of enum values).
*
*Revision 1.56.2.5  2004/03/21 19:44:58  marcelloptr
*improvements on TextModel and getCRCount
*
*Revision 1.56.2.4  2004/03/21 00:39:24  ddiego
*merged vc7.1 changes into dev branch
*
*Revision 1.56.2.3  2004/03/18 04:19:57  ddiego
*some minor stuff for tables
*
*Revision 1.56.2.2  2004/02/24 01:42:45  ddiego
*initial OSX ApplicationKit port checkin
*
*Revision 1.56.2.1  2004/01/18 04:52:46  ddiego
*Added a new EnumSet class that handles manipulating unsigned longs
*as a mask of bits. Adds support for reading in the enum value names and
*ORing them together to form the complete mask value. Also made
*mods to the VFFOutput and VFFInput stream classes so that that the []
*property is correctly read and written
*
*Revision 1.56  2003/12/18 05:16:02  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.55.2.6  2003/12/08 05:05:28  ddiego
*added a bunch more documentation to classes, and added support for new doc
*keywords (@delegates, @del, @delegate, @event, and @eventtype). This
*makes it easier to see at a glance what events a class fires off.
*Added finishing touches for the Action implementation and have a partially
*complete example for this checked in.
*
*Revision 1.55.2.5  2003/10/31 05:06:38  ddiego
*added toolbar impl
*
*Revision 1.55.2.4  2003/10/04 20:14:59  ddiego
*aaddec changes to support compiling on GCC 3.3.1, which is much more
*picky than some of the previous versions.
*
*Revision 1.55.2.3  2003/09/12 00:09:31  ddiego
*added better tabbing behaviour - fixed an earlier bug.
*Code is easier to understand and it simplified the implementation
*a bit as well
*Moved around the RTTI definitions for various Appkit classes to a
*single inline and stripped them from the various class headers
*
*Revision 1.55.2.2  2003/08/28 21:47:30  ddiego
*added escape reponse...
*
*Revision 1.55.2.1  2003/08/18 19:52:39  ddiego
*changed the Container from being a class you derive from to a separate
*intance that is created and assigned dynamically to any Control.
*
*Revision 1.55  2003/08/09 02:56:46  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.54.2.3  2003/08/02 22:36:20  marcelloptr
*use of std::map more conforming to standard
*
*Revision 1.54.2.2  2003/07/24 04:10:45  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.54.2.1  2003/07/06 01:20:29  ddiego
*added basic Document/View classes. These are based on the existing MVC
*architecture already present in the framework already, and exapnd on the
*existing functionality. Many of the ideas were influenced by the NeXT/Cocoa's
*Document/View architecture. Some of the new features are:
*  automatic creation and connection of the various parts including the
*  Document, view and Window.
*  Automatic default menu items, to ensure standard UI conformance. The menu
*  items are merged with an existing ones.
*  Automatic clipboard support in the form of cut/copy/paste and connecting this
*  directly to the current document
*  Support for Undo/Redo item as well, including default menu item validation
*  Default support for opening and saving documents, including presenting the
*  correct Dialogs to the User, and properly filling the default data, based
*  on the documents data.
*  Support for multiple document types
*  Support for differnt Document Interface policies. Currently we support
*  SDI (Single Document Interface) and MDI (Multiple Document Interface)
*
*Revision 1.54  2003/05/17 20:37:42  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.53.2.3  2003/04/17 04:29:51  ddiego
*updated scintilla, added gtk support for the application kit, with stubs
*for the basic peers.
*
*Revision 1.53.2.2  2003/03/23 03:23:59  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.53.2.1  2003/03/12 03:12:50  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.53  2003/02/26 04:30:53  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.52.2.5  2003/01/08 00:19:55  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.52.2.4  2002/12/27 23:04:57  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.52.2.3  2002/12/26 04:32:12  ddiego
*added basic peer implementation to ApplicationKit so that we can now create
*a VERY simple application and terminate correctly. Woohoo! First steps
*of running on linux!
*
*Revision 1.52.2.2  2002/12/25 22:38:00  ddiego
*more stupid fixes to get rid of the damn gcc no newline warning...grrr...
*
*Revision 1.52.2.1  2002/12/25 22:06:32  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.52  2002/11/18 00:46:09  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.51.4.2  2002/09/28 02:37:38  ddiego
*fixed up the radiobox and checkbox, label and header controls to properly
*take advantage of default heights from the UIMetricsManager
*fixed the default height for radioboxes and checkboxes in Win32 so that they are
*10 dialog units high - added the neccessary conversion code from dialog
*units to pixels
*
*Revision 1.51.4.1  2002/09/27 23:38:36  ddiego
*added support for geting various layout information
*added support for drawing various graphics UI primitives like scroll buttons
*tabs, tab pages, etc, partially to have this support in place for use
*in MacOSX.
*Also added scrolling buttons to TabbedPages, this fixes task 56652 in the
*ApplicationKit list
*
*Revision 1.51  2002/09/12 03:26:06  ddiego
*merged over the changes from the devmain-0-5-5b branch
*
*Revision 1.50.6.2  2002/07/26 04:24:29  ddiego
*added more support for properly querying modified document, and removing the
*documents from the doc tab pages, made some changes in TabbedPages to support
*this as well
*
*Revision 1.50.6.1  2002/07/02 05:35:11  marcelloptr
*fixes for vc6, vc7, separated builds, automatic library selection, stlport
*
*Revision 1.50  2002/05/09 03:10:45  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.49  2002/03/31 18:21:26  ddiego
*fixed memory leak of accelerators in UIToolkit::removeAcceleratorKeysForControl()
*
*Revision 1.48  2002/03/19 01:39:56  ddiego
*minor changes to ComboBoxControl to fix tabbing error with arrow keys
*fixes bug 531678 Bad behaviour of arrow keys in Combobox
*
*Revision 1.47.4.2  2002/04/27 15:52:32  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.47.4.1  2002/04/08 20:55:30  zzack
*changed include style
*
*Revision 1.47  2002/03/13 01:26:34  ddiego
*fixes to the TreeListControl
*plus fix for bug [ 529012 ] typecombo crash in the ComboBoxControl. Caused
*by not checking a null pointer in the UIToolkits' methods for getting the
*next and previous control
*
*Revision 1.46  2002/02/20 04:07:59  ddiego
*consolidated event handling code a bit
*introduced a virtual handleEvent() method to Component
*clean up some of the event constants, so they are now localized in the
*appropriate control classes.
*
*Revision 1.45  2002/02/07 04:38:55  ddiego
*fixes to Win32Edit, which include problems with setting text, and a bug that
*caused it to crash in Win 98. All textControls now default to the "EDIT"
*window class unles they are multiline, in which case an attempt is made to
*load the richedit control, and if that fails then the EDIT class is used
*Removed responding to WM_COMMAND messages
*in the default parent in the Win32Toolkit, also to fix the Win32Edit crash in 9.x
*
*Revision 1.44  2002/01/26 15:11:09  ddiego
*Default button now working
*
*Revision 1.43  2002/01/24 01:46:49  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


