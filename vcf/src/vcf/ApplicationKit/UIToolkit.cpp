//UIToolkit.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */

#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ApplicationKitPrivate.h"
#include "vcf/ApplicationKit/DefaultPropertyEditors.h"
#include "vcf/ApplicationKit/ImageControl.h"
#include "vcf/ApplicationKit/MenuManager.h"
#include "vcf/ApplicationKit/PropertyEditorManager.h"
#include "vcf/FoundationKit/VFFInputStream.h"

#if defined(VCF_AGG)
#include "AggUIToolkit.h"
#endif


using namespace VCF;





UIToolkit* UIToolkit::toolKitInstance = NULL;

static Control* prevTabbedControlContainer = NULL;

UIToolkit::UIToolkit():
	systemClipboard_(NULL),
	graphicsToolKit_(NULL),
	stopImage_(NULL),
	warningImage_(NULL),
	informationImage_(NULL),
	questionImage_(NULL),
	acceleratorMnemonicHandler_(NULL),
	defaultButtonHandler_(NULL),
	policyMgr_(NULL),
	quitModalLoop_(false)
{
	acceleratorMnemonicHandler_ =
		new ClassProcedure1<KeyboardEvent*,UIToolkit>( this, &UIToolkit::onAcceleratorMnemonic );

	defaultButtonHandler_ =
		new ClassProcedure1<KeyboardEvent*,UIToolkit>( this, &UIToolkit::onDefaultButton );

	Component::initComponentRegistrar();
}

UIToolkit::~UIToolkit()
{
	std::multimap<uint32,AcceleratorKey*>::iterator it = acceleratorMap_.begin();
	while ( it != acceleratorMap_.end() ) {
		if ( it->second->getOwner() == NULL ) {
			it->second->free();
		}
		it ++;
	}
	acceleratorMap_.clear();

	std::map<String,ComponentInfo*>::iterator it2 = componentInfoMap_.begin();
	while( it2 != componentInfoMap_.end() ) {
		ComponentInfo* info = it2->second;
		delete info;
		info = NULL;
		it2++;
	}
	componentInfoMap_.clear();

	delete systemClipboard_;

	Component::clearRegistedComponents();

	MenuManager::terminate();

	delete stopImage_;
	delete warningImage_;
	delete informationImage_;
	delete questionImage_;

	acceleratorMnemonicHandler_->free();
	acceleratorMnemonicHandler_ = NULL;

	defaultButtonHandler_->free();
	defaultButtonHandler_ = NULL;

	delete policyMgr_;	
}


String UIToolkit::getControlConstants( const String& name )
{
	String result;

	if ( name == CC_FONTNAME ) {
		Font f = UIToolkit::getUIMetricsManager()->getDefaultFontFor(UIMetricsManager::ftControlFont);
		result = f.getName();
	}
	else if ( name == CC_FONTSIZE ) {
		Font f = UIToolkit::getUIMetricsManager()->getDefaultFontFor(UIMetricsManager::ftControlFont);
		result = StringUtils::toString(f.getPointSize());
	}
	else if ( name == CC_BUTTONHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtButtonHeight ) );
	}
	else if ( name == CC_LABELHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtLabelHeight ) );
	}
	else if ( name == CC_CHECKBOXHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtCheckBoxHeight ) );
	}
	else if ( name == CC_COMBOBOXHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtComboBoxHeight ) );
	}
	else if ( name == CC_HEADERHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtHeaderHeight ) );
	}
	else if ( name == CC_TEXTHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtTextControlHeight ) );
	}
	else if ( name == CC_VPROGRESSWIDTH ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtVerticalProgressWidth ) );
	}
	else if ( name == CC_HPROGRESSHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtHorizontalProgressHeight ) );
	}
	else if ( name == CC_RADIOBOXHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtRadioBoxHeight ) );
	}
	else if ( name == CC_SEPARATORHEIGHT ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtSeparatorHeight ) );
	}
	else if ( name == CC_WINDOW_BORDER ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtWindowBorderDelta ) );
	}
	else if ( name == CC_CONTAINER_BORDER ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtContainerBorderDelta ) );
	}
	else if ( name == CC_CONTROL_VSPACE ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtControlVerticalSpacing ) );
	}
	else if ( name == CC_CONTROL_HSPACE ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtControlHorizontalSpacing ) );
	}
	else if ( name == CC_INFO_TOPSPACE ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtInformationControlTopSpacer ) );
	}
	else if ( name == CC_INFO_BOTTOMSPACE ) {
		result = StringUtils::toString( UIToolkit::getUIMetricValue( UIMetricsManager::mtInformationControlBottomSpacer ) );
	}


	return result;
}

void UIToolkit::init()
{


	systemClipboard_ = new Clipboard();
	/**
	register basic property editors
	One could argue that these don't belong here. Instead they 
	belong in some form designer that someone else implements...
	*/

	PropertyEditorManager::registerPropertyEditor( "VCF::IntegerPropertyEditor", CLASS_INTEGER );
	PropertyEditorManager::registerPropertyEditor( "VCF::DoublePropertyEditor", CLASS_DOUBLE );
	PropertyEditorManager::registerPropertyEditor( "VCF::BoolPropertyEditor", CLASS_BOOL );
	PropertyEditorManager::registerPropertyEditor( "VCF::StringPropertyEditor", CLASS_STRING );

	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::AlignmentType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::IconStyleType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::IconAlignType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::TextAlignmentType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::TextVerticalAlignment" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::FrameStyleType" );
	PropertyEditorManager::registerPropertyEditor( "VCF::EnumPropertyEditor", "VCF::ButtonCommandType" );

	PropertyEditorManager::registerPropertyEditor( "VCF::EnumSetPropertyEditor", "VCF::AnchorTypes" );
	PropertyEditorManager::registerPropertyEditor( "VCF::CursorPropertyEditor", "VCF::Cursor::SystemCursorType" );

	PropertyEditorManager::registerPropertyEditor( "VCF::ColorPropertyEditor", "VCF::Color" );
	PropertyEditorManager::registerPropertyEditor( "VCF::FontPropertyEditor", "VCF::Font" );
	PropertyEditorManager::registerPropertyEditor( "VCF::DefaultMenuItemPropertyEditor", "VCF::DefaultMenuItem" );
	PropertyEditorManager::registerPropertyEditor( "VCF::DefaultListModelPropertyEditor", "VCF::DefaultListModel" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImageFilenamePropertyEditor", "VCF::ImageFilenameString" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImagePropertyEditor", "VCF::Image" );
	PropertyEditorManager::registerPropertyEditor( "VCF::ImagePropertyEditor", "VCF::Win32Image" );

	/**
	register the components in categorys
	It's entirely possible that this might ultimately make more sense moved to the 
	VCF Builder at one point.

	*/

	Component::registerComponent( "VCF::TabbedPages", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Panel", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CommandButton", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ListViewControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TreeControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::TextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::MultilineTextControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::Label", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::CheckBoxControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::RadioButtonControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::SliderControl", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::ProgressControl", STANDARD_CATEGORY );

	Component::registerComponent( "VCF::MenuBar", STANDARD_CATEGORY );
	Component::registerComponent( "VCF::PopupMenu", STANDARD_CATEGORY );

	Component::registerComponent( "VCF::TimerComponent", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::ScrollbarManager", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::SystemTray", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::PushButton", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::OpenGLControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::ImageControl", ADDITIONAL_CATEGORY );

	Component::registerComponent( "VCF::TableControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::Splitter", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::TreeListControl", ADDITIONAL_CATEGORY );
	Component::registerComponent( "VCF::HeaderControl", ADDITIONAL_CATEGORY );

	Component::registerComponent( "VCF::Basic3DBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::EtchedBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::ColorEtchedBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::Light3DBorder", BORDER_CATEGORY );
	Component::registerComponent( "VCF::TitledBorder", BORDER_CATEGORY );


	Component::registerComponent( "VCF::StandardContainer", CONTAINER_CATEGORY );
	Component::registerComponent( "VCF::ColumnLayoutContainer", CONTAINER_CATEGORY );
	Component::registerComponent( "VCF::HorizontalLayoutContainer", CONTAINER_CATEGORY );


	//internal_setUpdateTimerSpeed( UIToolkit::defaultUpdateSpeed );

	MenuManager::create();
	//UIShell::getUIShell()->init();


	VFFInputStream::registerComponentConstant( CC_FONTNAME, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_FONTSIZE, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_BUTTONHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_LABELHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_CHECKBOXHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_COMBOBOXHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_HEADERHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_TEXTHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_VPROGRESSWIDTH, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_HPROGRESSHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_RADIOBOXHEIGHT, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_SEPARATORHEIGHT, UIToolkit::getControlConstants );

	VFFInputStream::registerComponentConstant( CC_WINDOW_BORDER, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_CONTAINER_BORDER, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_CONTROL_VSPACE, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_CONTROL_HSPACE, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_INFO_TOPSPACE, UIToolkit::getControlConstants );
	VFFInputStream::registerComponentConstant( CC_INFO_BOTTOMSPACE, UIToolkit::getControlConstants );
}

void UIToolkit::initToolKit()
{
	if ( NULL == UIToolkit::toolKitInstance ) {
#if defined(VCF_WIN) && !defined(VCF_AGG)
		UIToolkit::toolKitInstance = new Win32ToolKit();
#elif VCF_AGG
		UIToolkit::toolKitInstance = new AggUIToolkit();
#elif VCF_X11
		UIToolkit::toolKitInstance = new X11UIToolkit();
#elif VCF_GTK
		UIToolkit::toolKitInstance = new GTKUIToolkit();
#elif VCF_OSX
		UIToolkit::toolKitInstance = new OSXUIToolkit();
#elif VCF_XCB
		UIToolkit::toolKitInstance = new XCBUIToolkit();
#endif

		if ( NULL == UIToolkit::toolKitInstance ) {
			//Damn the UI toolkit is STILL NULL !!!
			//Well that means we are well and truly screwed, so lets get out of Dodge pardner!
			throw NoToolKitFoundException( MAKE_ERROR_MSG_2(NO_TOOLKIT_ERROR));
		}


		//inialize the toolkit instance
		((UIToolkit*)UIToolkit::toolKitInstance)->init();	
	}
}

void UIToolkit::closeToolkit()
{
	delete UIToolkit::toolKitInstance;
	UIToolkit::toolKitInstance = NULL;
}

UIToolkit* UIToolkit::internal_getDefaultUIToolkit()
{
	return UIToolkit::toolKitInstance;
}




ControlPeer* UIToolkit::createControlPeer( Control* component, ComponentType componentType)
{
	return UIToolkit::toolKitInstance->internal_createControlPeer( component, componentType );
}

ContextPeer* UIToolkit::createContextPeer( Control* component )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( component );
}

ContextPeer* UIToolkit::createContextPeer( OSHandleID contextID )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( contextID );
}

ContextPeer* UIToolkit::createContextPeer( const uint32& width, const uint32& height )
{
	return UIToolkit::toolKitInstance->internal_createContextPeer( width, height );
}

ListviewPeer* UIToolkit::createListViewPeer( ListViewControl* component)
{
	return UIToolkit::toolKitInstance->internal_createListViewPeer( component );
}

TreePeer* UIToolkit::createTreePeer( TreeControl* component)
{
	return UIToolkit::toolKitInstance->internal_createTreePeer( component );
}

TextPeer* UIToolkit::createTextPeer( const bool& autoWordWrap, const bool& multiLined )
{
	return UIToolkit::toolKitInstance->internal_createTextPeer( autoWordWrap,multiLined );
}

TextEditPeer* UIToolkit::createTextEditPeer( TextControl* component, const bool& isMultiLineControl)
{
	return UIToolkit::toolKitInstance->internal_createTextEditPeer( component, isMultiLineControl );
}


ButtonPeer* UIToolkit::createButtonPeer( CommandButton* component)
{
	return UIToolkit::toolKitInstance->internal_createButtonPeer( component );
}

DialogPeer* UIToolkit::createDialogPeer( Control* owner, Dialog* component)
{
	return UIToolkit::toolKitInstance->internal_createDialogPeer( owner, component );
}

DialogPeer* UIToolkit::createDialogPeer()
{
	return UIToolkit::toolKitInstance->internal_createDialogPeer();
}

WindowPeer* UIToolkit::createWindowPeer( Control* component, Control* owner)
{
	return UIToolkit::toolKitInstance->internal_createWindowPeer( component, owner );
}

PopupWindowPeer* UIToolkit::createPopupWindowPeer( Frame* frame, Window* owner )
{
	return UIToolkit::toolKitInstance->internal_createPopupWindowPeer( frame, owner );
}

TransparentWindowPeer* UIToolkit::createTransparentWindowPeer( Frame* frame )
{
	return UIToolkit::toolKitInstance->internal_createTransparentWindowPeer( frame );
}

DropDownPeer* UIToolkit::createDropDownPeer( Control* control )
{
	return UIToolkit::toolKitInstance->internal_createDropDownPeer( control );
}

ToolbarPeer* UIToolkit::createToolbarPeer( Toolbar* toolbar )
{
	return UIToolkit::toolKitInstance->internal_createToolbarPeer( toolbar );
}

MenuItemPeer* UIToolkit::createMenuItemPeer( MenuItem* item )
{
	return UIToolkit::toolKitInstance->internal_createMenuItemPeer( item );
}

MenuBarPeer* UIToolkit::createMenuBarPeer( MenuBar* menuBar )
{
	return UIToolkit::toolKitInstance->internal_createMenuBarPeer( menuBar );
}

PopupMenuPeer* UIToolkit::createPopupMenuPeer( PopupMenu* popupMenu )
{
	return UIToolkit::toolKitInstance->internal_createPopupMenuPeer( popupMenu );
}

ClipboardPeer* UIToolkit::createClipboardPeer()
{
	return UIToolkit::toolKitInstance->internal_createClipboardPeer();
}

DragDropPeer* UIToolkit::createDragDropPeer()
{
	return UIToolkit::toolKitInstance->internal_createDragDropPeer();
}

DataObjectPeer* UIToolkit::createDataObjectPeer()
{
	return UIToolkit::toolKitInstance->internal_createDataObjectPeer();
}

DropTargetPeer* UIToolkit::createDropTargetPeer()
{
	return UIToolkit::toolKitInstance->internal_createDropTargetPeer();
}

ApplicationPeer* UIToolkit::createApplicationPeer()
{
	return UIToolkit::toolKitInstance->internal_createApplicationPeer();
}

Clipboard* UIToolkit::getSystemClipboard()
{
	return UIToolkit::toolKitInstance->internal_getSystemClipboard();
}

CommonFileDialogPeer* UIToolkit::createCommonFileOpenDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFileOpenDialogPeer( owner );
}

CommonFolderBrowseDialogPeer* UIToolkit::createCommonFolderBrowseDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFolderBrowseDialogPeer( owner );
}

CommonFileDialogPeer* UIToolkit::createCommonFileSaveDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFileSaveDialogPeer( owner );
}

CommonColorDialogPeer* UIToolkit::createCommonColorDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonColorDialogPeer( owner );
}

CommonFontDialogPeer* UIToolkit::createCommonFontDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonFontDialogPeer( owner );
}

CommonPrintDialogPeer* UIToolkit::createCommonPrintDialogPeer( Control* owner )
{
	return UIToolkit::toolKitInstance->internal_createCommonPrintDialogPeer( owner );
}

UIShellPeer* UIToolkit::createUIShellPeer( UIShell* shell )
{
	return UIToolkit::toolKitInstance->internal_createUIShellPeer( shell );
}

ScrollPeer* UIToolkit::createScrollPeer( Control* control )
{
	return UIToolkit::toolKitInstance->internal_createScrollPeer( control );
}

CursorPeer* UIToolkit::createCursorPeer( Cursor* cursor )
{
	return UIToolkit::toolKitInstance->internal_createCursorPeer( cursor );
}

SystemTrayPeer* UIToolkit::createSystemTrayPeer()
{
	return UIToolkit::toolKitInstance->internal_createSystemTrayPeer();
}

MenuManagerPeer* UIToolkit::createMenuManagerPeer()
{
	return UIToolkit::toolKitInstance->internal_createMenuManagerPeer();
}

GraphicsResourceBundlePeer* UIToolkit::createGraphicsResourceBundlePeer( AbstractApplication* app )
{
	return UIToolkit::toolKitInstance->internal_createGraphicsResourceBundlePeer( app );
}

bool UIToolkit::createCaret( Control* owningControl, Image* caretImage  )
{
	return UIToolkit::toolKitInstance->internal_createCaret( owningControl, caretImage );
}

bool UIToolkit::destroyCaret( Control* owningControl )
{
	return UIToolkit::toolKitInstance->internal_destroyCaret( owningControl );
}

void UIToolkit::setCaretVisible( const bool& caretVisible )
{
	UIToolkit::toolKitInstance->internal_setCaretVisible( caretVisible );
}

void UIToolkit::setCaretPos( Point* point )
{
	UIToolkit::toolKitInstance->internal_setCaretPos( point );
}

void UIToolkit::postEvent( EventHandler* eventHandler, Event* event, const bool& deleteHandler )
{
	UIToolkit::toolKitInstance->internal_postEvent( eventHandler, event, deleteHandler );
}

void UIToolkit::registerTimerHandler( Object* source, EventHandler* handler, const uint32& timeoutInMilliSeconds )
{
	UIToolkit::toolKitInstance->internal_registerTimerHandler( source, handler, timeoutInMilliSeconds );
}

void UIToolkit::unregisterTimerHandler( EventHandler* handler )
{
	UIToolkit::toolKitInstance->internal_unregisterTimerHandler( handler );
}

void UIToolkit::runEventLoop()
{
	UIToolkit::toolKitInstance->quitModalLoop_ = false;
	UIToolkit::toolKitInstance->internal_runEventLoop();
}

UIToolkit::ModalReturnType UIToolkit::runModalEventLoopFor( Control* control )
{
	UIToolkit::toolKitInstance->quitModalLoop_ = false;
	return UIToolkit::toolKitInstance->internal_runModalEventLoopFor( control );
}


void UIToolkit::quitModalEventLoop()
{
	UIToolkit::toolKitInstance->quitModalLoop_ = true;
}

void UIToolkit::quitCurrentEventLoop()
{	
	UIToolkit::toolKitInstance->internal_quitCurrentEventLoop();
}

Event* UIToolkit::createEventFromNativeOSEventData( void* eventData )
{
	return UIToolkit::toolKitInstance->internal_createEventFromNativeOSEventData( eventData );
}

VCF::Size UIToolkit::getDragDropDelta()
{
	return UIToolkit::toolKitInstance->internal_getDragDropDelta();
}

const Image* UIToolkit::getStandardStopImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardStopImage();
}

const Image* UIToolkit::getStandardWarningImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardWarningImage();
}

const Image* UIToolkit::getStandardQuestionImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardQuestionImage();
}

const Image* UIToolkit::getStandardInformationImage()
{
	return UIToolkit::toolKitInstance->internal_getStandardInformationImage();
}

void UIToolkit::registerComponentInfo( const String& componentUUID, ComponentInfo* info )
{
	UIToolkit::toolKitInstance->internal_registerComponentInfo( componentUUID, info );
}

void UIToolkit::removeComponentInfo( ComponentInfo* info )
{
	UIToolkit::toolKitInstance->internal_removeComponentInfo( info );
}

void UIToolkit::registerAccelerator( AcceleratorKey* accelerator )
{
	UIToolkit::toolKitInstance->internal_registerAccelerator( accelerator );
}

void UIToolkit::removeAccelerator( const VirtualKeyCode& keyCode, const uint32& modifierMask, Object* src )
{
	UIToolkit::toolKitInstance->internal_removeAccelerator( keyCode, modifierMask, src );
}

VCF::Button* UIToolkit::getDefaultButton()
{
	return UIToolkit::toolKitInstance->internal_getDefaultButton();
}

void UIToolkit::setDefaultButton( Button* defaultButton )
{
	UIToolkit::toolKitInstance->internal_setDefaultButton( defaultButton );
}

void UIToolkit::removeDefaultButton( Button* defaultButton )
{
	UIToolkit::toolKitInstance->internal_removeDefaultButton( defaultButton );
}

AcceleratorKey* UIToolkit::getAccelerator( const VirtualKeyCode& keyCode, const uint32& modifierMask, Object* src )
{
	return UIToolkit::toolKitInstance->internal_getAccelerator( keyCode, modifierMask, src );
}

bool UIToolkit::findMatchingAccelerators( AcceleratorKey* key, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	return UIToolkit::toolKitInstance->internal_findMatchingAccelerators( key, matchingAccelerators );
}

void UIToolkit::getAcceleratorKeysForControl( Control* control, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	UIToolkit::toolKitInstance->internal_getAcceleratorKeysForControl( control, matchingAccelerators );
}

void UIToolkit::getAcceleratorKeysForMenuItem( MenuItem* item, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	UIToolkit::toolKitInstance->internal_getAcceleratorKeysForMenuItem( item, matchingAccelerators );
}

void UIToolkit::getAcceleratorKeysForObject( Object* src, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	UIToolkit::toolKitInstance->internal_getAcceleratorKeysForObject( src, matchingAccelerators );
}

void UIToolkit::removeAcceleratorKeysForControl( Control* control )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForControl( control );
}

void UIToolkit::removeAcceleratorKeysForMenuItem( MenuItem* item )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForMenuItem( item );
}

void UIToolkit::removeAcceleratorKeysForObject( Object* src )
{
	UIToolkit::toolKitInstance->internal_removeAcceleratorKeysForObject( src );
}


void UIToolkit::handleKeyboardEvent( KeyboardEvent* event )
{
	UIToolkit::toolKitInstance->internal_handleKeyboardEvent( event );
}

VirtualKeyCode UIToolkit::findMnemonic( const String& caption )
{
	return UIToolkit::toolKitInstance->internal_findMnemonic( caption );
}

ComponentInfo* UIToolkit::getComponentInfo( const String& componentUUID )
{
	return UIToolkit::toolKitInstance->internal_getComponentInfo( componentUUID );
}

ComponentInfo* UIToolkit::getComponentInfo( Class* componentClass )
{
	return UIToolkit::toolKitInstance->internal_getComponentInfo( componentClass );
}

UIMetricsManager* UIToolkit::getUIMetricsManager()
{
	return GraphicsToolkit::getUIMetricsManager();
}

double UIToolkit::getUIMetricValue( const UIMetricsManager::MetricType& type, const String& text, Font* alternateFont )
{
	return GraphicsToolkit::getUIMetricValue( type, text, alternateFont );
}

VCF::Size UIToolkit::getUIMetricSize( const UIMetricsManager::MetricType& type, const String& text, Font* alternateFont )
{
	return GraphicsToolkit::getUIMetricSize( type, text, alternateFont );
}

VCF::Rect UIToolkit::getUIMetricRect( const UIMetricsManager::MetricType& type, VCF::Rect* rect, Font* alternateFont )
{
	return GraphicsToolkit::getUIMetricRect( type, rect, alternateFont );
}

UIPolicyManager* UIToolkit::getUIPolicyManager()
{
	return UIToolkit::toolKitInstance->internal_getUIPolicyManager();
}

void UIToolkit::systemSettingsChanged()
{
	GraphicsToolkit::systemSettingsChanged();

	UIToolkit::toolKitInstance->internal_systemSettingsChanged();
}


void getHelpInfo( String& helpBookName, String& helpDirectory )
{
	Application* app = Application::getRunningInstance();

	if ( NULL != app ) {		
		app->getHelpInfo( helpBookName, helpDirectory );		
	}	

	if ( helpBookName.empty() || helpDirectory.empty() ) {
		ProgramInfo* info = System::getResourceBundle()->getProgramInfo();
		if ( NULL != info ) {
			if ( helpDirectory.empty() ) {
				helpDirectory = info->getHelpDirectory();
			}
			if ( helpBookName.empty() ) {
				helpBookName = info->getHelpName();
			}
			delete info;
		}
	}

	if ( helpBookName.empty() || helpDirectory.empty() ) {
		//damn, we're STILL not finished - now try 
		//and assume the stuff is in the res directory
		//and the help name is the app name

		if ( helpBookName.empty() ) {
			if ( NULL != app ) {
				helpBookName = app->getName();
			}
			else {
				FilePath fp = FoundationKit::getCommandLine().getArgument(0);
				helpBookName = fp.getBaseName();
			}
		}

		if ( helpDirectory.empty() ) {
			helpDirectory = "Help";
		}
	}	
}

void UIToolkit::displayHelpContents()
{
	Application* app = Application::getRunningInstance();
	bool helpDisplayed = false;
	if ( NULL != app ) {
		helpDisplayed = app->displayHelpContents();
	}

	if ( !helpDisplayed ) {
		String helpBookName;
		String helpDirectory;
		getHelpInfo( helpBookName, helpDirectory );
		UIToolkit::toolKitInstance->internal_displayHelpContents(helpBookName,helpDirectory);
	}	
}

void UIToolkit::displayHelpIndex()
{
	Application* app = Application::getRunningInstance();
	bool helpDisplayed = false;
	
	if ( NULL != app ) {
		helpDisplayed = app->displayHelpIndex();
	}

	if ( !helpDisplayed ) {
		String helpBookName;
		String helpDirectory;
		getHelpInfo( helpBookName, helpDirectory );
		UIToolkit::toolKitInstance->internal_displayHelpIndex(helpBookName, helpDirectory);
	}
}

void UIToolkit::displayHelpSection( const String& helpSection, const String& helpBookName, const String& helpDirectory )
{	
	String helpBookNameTmp;
	String helpDirectoryTmp;
	getHelpInfo( helpBookNameTmp, helpDirectoryTmp );
	if ( !helpBookName.empty() ) {
		helpBookNameTmp = helpBookName;
	}

	if ( !helpDirectory.empty() ) {
		helpDirectoryTmp = helpDirectory;
	}

	UIToolkit::toolKitInstance->internal_displayHelpSection(helpBookNameTmp, helpDirectoryTmp,helpSection);
}

void UIToolkit::displayContextHelpForControl( Control* control )
{
	String helpBookName;
	String helpDirectory;
	getHelpInfo( helpBookName, helpDirectory );

	String whatsThis = control->getWhatsThisHelpString();


	if ( !UIToolkit::toolKitInstance->internal_displayContextHelpForControl( control, helpBookName, helpDirectory ) ) {
		//oops - this control didn't have any immediate what's up help. Lets start walking the parent chain
		//and notifying delegates that a context help event is happening and see if we can get
		//some help there

		HelpEvent event(control);
		
		control->HelpRequested( &event );

		String helpSection = event.helpSection;
		String helpBook = event.helpBook;
		String helpDir = event.helpDirectory;
		if ( helpSection.empty() ) {
			//start searching the up the parent chain...
			Control* parent = control->getParent();
			while ( NULL != parent ) {
				HelpEvent event2(parent);
				parent->HelpRequested( &event2 );
				
				helpSection = event.helpSection;
				helpBook = event.helpBook;
				helpDir = event.helpDirectory;

				if ( !helpSection.empty() ) {
					break;
				}

				parent = parent->getParent();
			}
		}

		if ( !helpSection.empty() ) {
			UIToolkit::displayHelpSection( helpSection, helpBook, helpDir );
		}
	}
}








Clipboard* UIToolkit::internal_getSystemClipboard()
{
	return systemClipboard_;
}



ContextPeer* UIToolkit::internal_createContextPeer( OSHandleID contextID )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return graphicsToolKit_->createContextPeer( contextID );
}

ContextPeer* UIToolkit::internal_createContextPeer( Control* component )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return NULL;//graphicsToolKit_->createContextPeer( component );
}

ContextPeer* UIToolkit::internal_createContextPeer( const uint32& width, const uint32& height )
{
	if ( NULL == graphicsToolKit_ ){
		//throw exception
	}
	return graphicsToolKit_->createContextPeer( width, height );
}


void UIToolkit::internal_registerComponentInfo( const String& componentUUID, ComponentInfo* info )
{
	if ( componentUUID != info->getComponentUUID() ) {
		throw RuntimeException( "Attempting to register a component's info with a mismatched UUID." );
	}
	componentInfoMap_[ componentUUID ] = info;
}

ComponentInfo* UIToolkit::internal_getComponentInfo( const String& componentUUID )
{
	ComponentInfo* result = NULL;
	std::map< String,ComponentInfo*>::iterator found = componentInfoMap_.find( componentUUID );
	if ( found != componentInfoMap_.end() ) {
		result = found->second;
	}
	return result;
}

ComponentInfo* UIToolkit::internal_getComponentInfo( Class* componentClass )
{
	if ( NULL == componentClass ) {
		throw RuntimeException( "Can't get Component information from a NULL Class." );
	}
	return getComponentInfo( componentClass->getID() );
}

void UIToolkit::internal_removeComponentInfo( ComponentInfo* info )
{
	std::map< String,ComponentInfo*>::iterator found = componentInfoMap_.find( info->getComponentUUID() );
	if ( found != componentInfoMap_.end() ) {
		componentInfoMap_.erase( found );
	}
}

void UIToolkit::internal_registerAccelerator( AcceleratorKey* accelerator )
{
	AcceleratorKey::Value key;
	key = accelerator;	


	typedef std::multimap<uint32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	std::multimap<uint32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		if ( (accelerator->getAssociatedControl() == accel->getAssociatedControl()) && 
				(accelerator->getAssociatedMenuItem() == accel->getAssociatedMenuItem()) && 
				(accelerator->getAssociatedObject() == accel->getAssociatedObject()) ) {

			if ( NULL == accel->getOwner() ) {
				accel->free();
			}

			//remove old entry!
			acceleratorMap_.erase( it );
			break;
		}

		it ++;
	}

	std::pair<uint32,AcceleratorKey*> item(key,accelerator);
	
	if ( accelerator->getOwner() == NULL ) {
		accelerator->addRef();
	}

	acceleratorMap_.insert( item );
}

bool UIToolkit::internal_findMatchingAccelerators( AcceleratorKey* key, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	matchingAccelerators.clear();

	AcceleratorKey::Value keyVal;
	keyVal = key;

	typedef std::multimap<uint32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( keyVal );

	std::multimap<uint32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		// we don't need to put in the list the accelerator (key) to which all the others are matching.
		if ( (accel->getEventHandler() == key->getEventHandler()) && 
				(accel != key) ) {
			matchingAccelerators.push_back( accel );
		}

		it ++;
	}

	return !matchingAccelerators.empty();
}

void UIToolkit::internal_getAcceleratorKeysForControl( Control* control, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	std::multimap<uint32,AcceleratorKey*>::iterator it = acceleratorMap_.begin();
	while ( it != acceleratorMap_.end() ) {
		if ( it->second->getAssociatedControl() == control ) {
			matchingAccelerators.push_back( it->second );
		}
		++it;
	}
}

void UIToolkit::internal_getAcceleratorKeysForMenuItem( MenuItem* item, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	std::multimap<uint32,AcceleratorKey*>::iterator it = acceleratorMap_.begin();
	while ( it != acceleratorMap_.end() ) {
		if ( it->second->getAssociatedMenuItem() == item ) {
			matchingAccelerators.push_back( it->second );
		}
		++it;
	}
}

void UIToolkit::internal_getAcceleratorKeysForObject( Object* src, std::vector<AcceleratorKey*>& matchingAccelerators )
{
	std::multimap<uint32,AcceleratorKey*>::iterator it = acceleratorMap_.begin();
	while ( it != acceleratorMap_.end() ) {
		if ( it->second->getAssociatedObject() == src ) {
			matchingAccelerators.push_back( it->second );
		}
		++it;
	}
}	

AcceleratorKey* UIToolkit::internal_getAccelerator( const VirtualKeyCode& keyCode, const uint32& modifierMask, Object* src )
{
	AcceleratorKey* result = NULL;

	AcceleratorKey::Value key( modifierMask, keyCode );


	typedef std::multimap<uint32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	std::multimap<uint32,AcceleratorKey*>::iterator it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;

		if ( (src == accel->getAssociatedControl()) || 
				(src == accel->getAssociatedMenuItem()) || 
				(src == accel->getAssociatedObject()) ) {

			result = accel;
			break;
		}

		it ++;
	}

	return result;
}

void internal_handleKeyboardButtonEvent ( Event* e )
{
	VCF::Button* button = (VCF::Button*)e->getUserData();

	if ( NULL != button ) {
		button->click();
	}
}

void UIToolkit::internal_handleKeyboardEvent( KeyboardEvent* event )
{
	if ( vkEscape == event->getVirtualCode() ) {
		Frame* frame = Frame::getActiveFrame();
		if ( NULL != frame ) {
			Event* e = (Event*)event->clone();
			e->setType( Control::KEYBOARD_DOWN );
			frame->handleEvent( e );
			if ( e->isConsumed() ) {
				delete e;
				return;
			}
			delete e;
		}
	}

	
	AcceleratorKey::Value key( event->getKeyMask(), event->getVirtualCode() );

	typedef std::multimap<uint32,AcceleratorKey*>::iterator AccelMapIter;
	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );

	//look for accelerator in control then app
	AcceleratorKey* accelerator = NULL;
	Control* control = (Control*)event->getSource();


	AccelMapIter it = range.first;
	if ( control ) {
		if ( control->areParentsEnabled() ) {

			while ( it != range.second ) {

				AcceleratorKey* accel = it->second;
				// check if the control associated to this accelerator is the same having the focus
				if ( accel->getAssociatedControl() == control ) {
					accelerator = accel;
					break;
				}

				it ++;
			}
		}
	}




	//if accelerator is still null try and find the first matching menu item
	if ( NULL == accelerator ) {
		it = range.first;
		while ( it != range.second ) {
			AcceleratorKey* accel = it->second;
			if ( accel->getAssociatedMenuItem() != NULL ) {
				accelerator = accel;
				//check to make sure the menu item's frame is enabled!
				if ( NULL != accel ) {
					MenuItem* mi = accel->getAssociatedMenuItem();
					mi->update();
				}
				break;
			}

			it ++;
		}
	}

	//if accelerator is still null try and find the first matching object
	if ( NULL == accelerator ) {
		it = range.first;
		while ( it != range.second ) {

			AcceleratorKey* accel = it->second;
			if ( accel->getAssociatedObject() != NULL ) {
				accelerator = accel;
				break;
			}

			it ++;
		}
	}


	if ( NULL != accelerator ) {

		CallBack* ev = NULL;

		if ( accelerator->isMnemonic() ) {
			ev = acceleratorMnemonicHandler_;
		}
		else {
			ev = accelerator->getEventHandler();
		}

		if ( NULL != ev ) {
			if ( accelerator->isEnabled() ) {
				KeyboardEvent* acceleratorEvent = new KeyboardEvent( accelerator, Control::KEYBOARD_ACCELERATOR,
																	event->getRepeatCount(),
																	event->getKeyMask(),
																	event->getKeyValue(),
																	event->getVirtualCode() );

				postEvent( (EventHandler*)ev, acceleratorEvent, false );
			}

			//KeyboardEvent acceleratorEvent( accelerator, Control::KEYBOARD_ACCELERATOR,
			//														event->getRepeatCount(),
			//														event->getKeyMask(),
			//														event->getKeyValue(),
			//														event->getVirtualCode() );

			//ev->invoke( &acceleratorEvent );


			// as the event has been processed, we don't let it to be forwarded further to any other controls
			event->setConsumed( true );
		}
	}
	else if ( NULL != control ) {

		VirtualKeyCode keyCode = event->getVirtualCode();
		/**
		as per bug [ 585087 ] Get rid of arrow key tabbing
		I am commenting the arrow key tabbing out - will
		work out something better !
		*/
		switch( keyCode ) {

			case vkTab : /*case vkUpArrow : case vkDownArrow : case vkLeftArrow : case vkRightArrow :*/{
				handleTabKeyboardEvent( event );
			}
			break;

			case vkReturn :{

				if ( false == control->keepsReturnCharacter() ) {
					//event->setConsumed( true );

					Button* button = getDefaultButton();

					Event* e = (Event*)event->clone();
					e->setUserData( button );

					postEvent( new EventHandler(internal_handleKeyboardButtonEvent),
								e );

					/*
					if ( NULL != button ) {
						button->click();
					}
					*/
				}
			}
			break;
			default:
			break;

		}
	}
}

void UIToolkit::handleTabKeyboardEvent( KeyboardEvent* event )
{
	Control* control = (Control*) event->getSource();

	if ( !control->keepsTabKey() ) {
		bool goForward = !event->hasShiftKey();

		Control* currentFocused = Control::getCurrentFocusedControl();
		if ( NULL == currentFocused ) {
			currentFocused = control;
		}
		Frame* parentFrame = currentFocused->getParentFrame();

		std::vector<Control*> tabList;
		Control::buildTabList( parentFrame, tabList );

		Control* newFocusedControl = NULL;
		std::vector<Control*>::iterator found = std::find( tabList.begin(), tabList.end(), currentFocused );
		int32 index = -1;
		if ( found != tabList.end() ) {
			index = found - tabList.begin();
		}
		if ( goForward ) {
			index ++;

			if ( index >= tabList.size() ) {
				index = 0;
			}

			if ( index >= 0 ) {
				while ( index < tabList.size() ) {
					Control* c = tabList[index];
					if ( c->canAcceptFocus() ) {
						if ( c->getTabStop() ) {
							break;
						}
					}
					index++;
				}
			}

			if ( index >= tabList.size() ) {
				index = 0;
			}

		}
		else {
			index --;

			if ( index <= 0 ) {
				index = tabList.size()-1;
			}

			if ( index < tabList.size() ) {
				while ( index > -1 ) {
					Control* c = tabList[index];
					if ( c->canAcceptFocus() ) {
						if ( c->getTabStop() ) {
							break;
						}
					}
					index--;
				}
			}

			if ( index <= 0 ) {
				index = tabList.size()-1;
			}
		}


		newFocusedControl = tabList[index];
		newFocusedControl->setFocused();

		event->consume();
	}
}

const Image* UIToolkit::internal_getStandardStopImage()
{
	return stopImage_;
}

const Image* UIToolkit::internal_getStandardWarningImage()
{
	return warningImage_;
}

const Image* UIToolkit::internal_getStandardQuestionImage()
{
	return questionImage_;
}

const Image* UIToolkit::internal_getStandardInformationImage()
{
	return informationImage_;
}

void UIToolkit::onAcceleratorMnemonic( KeyboardEvent* event )
{
	 AcceleratorKey* accelerator = (AcceleratorKey*)event->getSource();
	 if ( NULL != accelerator ) {
		Control* control = accelerator->getAssociatedControl();
		if ( NULL != control ) {
			control->mnemonicActivate();
		}
	}
}

VirtualKeyCode UIToolkit::internal_findMnemonic( const String& caption )
{
	VirtualKeyCode result = vkUndefined;

#if (! defined VCF_MSC) || ( (_MSC_VER < 1300) || defined ( STLPORT ) )
	const VCFChar* P = caption.c_str();
#else
	const VCFChar* P = caption.c_str();
#endif
	const VCFChar* start = P;
	int size = caption.size();

	while ( (P - start) < size ) {
		if ( (*P == '&') && (((P - start)+1) < size) ) {
			VCFChar nextChar = *(P+1);
			//this is not locale or Unicode safe !
			if ( ((nextChar >= 'A') && (nextChar <= 'Z')) || ((nextChar >= 'a') && (nextChar <= 'z')) ) {
				if ( (nextChar >= 'A') && (nextChar <= 'Z') ) {
					result = (VirtualKeyCode)(vkLetterA + (nextChar - 'A'));
				}
				else {
					result = (VirtualKeyCode)(vkLetterA + (nextChar - 'a'));
				}
				break;
			}
			else if ( (nextChar >= '0') && (nextChar <= '9') ) {
				result = (VirtualKeyCode)(vkNumber0 + (nextChar - '0'));

				break;
			}
		}
		P++;
	}

	return result;
}

VCF::Button* UIToolkit::internal_getDefaultButton()
{
	Button* result = NULL;
	if ( ! defaultButtonList_.empty() ) {
		result = *defaultButtonList_.begin();
	}
	return result;
}

void UIToolkit::internal_setDefaultButton( Button* defaultButton )
{
	if ( true == defaultButtonList_.empty() ) {
		defaultButtonList_.push_back( defaultButton );
	}
	else {
		defaultButtonList_.insert( defaultButtonList_.begin(), defaultButton );
	}
}

void UIToolkit::onDefaultButton( KeyboardEvent* event )
{
	//Control* control = (Control*)event->getSource();
	/*
	Control* buttonControl = dynamic_cast<Control*>(control);
	if ( (buttonControl == Control::getCurrentFocusedControl()) && (NULL != temporaryDefaultButton_) ) {
		temporaryDefaultButton_->click();
	}
	else if ( NULL != defaultButton_ ) {
		defaultButton_->click();
	}

  */

}

void UIToolkit::internal_removeDefaultButton( Button* defaultButton )
{
	std::vector<Button*>::iterator found = std::find( defaultButtonList_.begin(), defaultButtonList_.end(), defaultButton );
	if ( found != defaultButtonList_.end() ) {
		defaultButtonList_.erase( found );
	}
}

void UIToolkit::internal_removeAccelerator( const VirtualKeyCode& keyCode, const uint32& modifierMask, Object* src )
{

	AcceleratorKey::Value key( modifierMask, keyCode );

	typedef std::multimap<uint32,AcceleratorKey*>::iterator AccelMapIter;

	std::pair<AccelMapIter, AccelMapIter> range = acceleratorMap_.equal_range( key );	

	std::vector<AccelMapIter> removeAccels;

	AccelMapIter it = range.first;
	while ( it != range.second ) {
		AcceleratorKey* accel = it->second;
		if ( (accel->getAssociatedControl() == src) || 
			(accel->getAssociatedMenuItem() == src) ||
			(accel->getAssociatedObject() == src) ) {
			if ( accel->getOwner() == NULL ) {
				accel->release();
			}

			removeAccels.push_back( it );
		}

		it ++;
	}

	std::vector<AccelMapIter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}

void UIToolkit::internal_removeAcceleratorKeysForControl( Control* control )
{
	typedef std::multimap<uint32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedControl() == control ) {
			if ( accel->getOwner() == NULL ) {
				accel->release();
			}

			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}

}

void UIToolkit::internal_removeAcceleratorKeysForMenuItem( MenuItem* menuItem )
{
	typedef std::multimap<uint32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedMenuItem() == menuItem ) {
			if ( accel->getOwner() == NULL ) {
				accel->release();
			}

			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}

void UIToolkit::internal_removeAcceleratorKeysForObject( Object* src )
{
	typedef std::multimap<uint32,AcceleratorKey*>::iterator accel_iter;

	std::vector<accel_iter> removeAccels;

	accel_iter it = acceleratorMap_.begin();

	while ( it != acceleratorMap_.end() ) {
		AcceleratorKey* accel = it->second;
		if ( accel->getAssociatedObject() == src ) {
			if ( accel->getOwner() == NULL ) {
				accel->release();
			}

			removeAccels.push_back( it );
		}
		it ++;
	}

	std::vector<accel_iter>::iterator it2 = removeAccels.begin();
	while ( it2 != removeAccels.end() ) {
		acceleratorMap_.erase( *it2 );
		it2 ++;
	}
}


void UIToolkit::addToUpdateList( Component* component )
{
	UIToolkit::toolKitInstance->internal_addToUpdateList( component );
}

void UIToolkit::removeFromUpdateList( Component* component )
{
	UIToolkit::toolKitInstance->internal_removeFromUpdateList( component );
}

void UIToolkit::setUpdateTimerSpeed( const uint32& milliseconds )
{
	UIToolkit::toolKitInstance->internal_setUpdateTimerSpeed( milliseconds );
}

void UIToolkit::internal_addToUpdateList( Component* component )
{
	std::vector<Component*>::iterator found = std::find( componentsToUpdate_.begin(), componentsToUpdate_.end(), component );
	if ( found == componentsToUpdate_.end() ) {
		componentsToUpdate_.push_back( component );
	}
}

void UIToolkit::internal_removeFromUpdateList( Component* component )
{
	std::vector<Component*>::iterator found = std::find( componentsToUpdate_.begin(), componentsToUpdate_.end(), component );
	if ( found != componentsToUpdate_.end() ) {
		componentsToUpdate_.erase( found );
	}
}

void UIToolkit::internal_setUpdateTimerSpeed( const uint32& milliseconds )
{
	CallBack* ev = getCallback( "UIToolkit::onUpdateComponentsTimer" );
	if ( NULL != ev ) {
		internal_unregisterTimerHandler( (EventHandler*)ev );
	}

	if ( NULL == ev ) {
		ev = new ClassProcedure1<TimerEvent*,UIToolkit>( this, &UIToolkit::onUpdateComponentsTimer, "UIToolkit::onUpdateComponentsTimer" );
	}

	internal_registerTimerHandler( this, (EventHandler*)ev, milliseconds );
}

void UIToolkit::onUpdateComponentsTimer( TimerEvent* e )
{
	std::vector<Component*>::iterator it = componentsToUpdate_.begin();
	while ( it != componentsToUpdate_.end() ) {
		Component* component = *it;
		Event updateEvent( this, Component::COMPONENT_NEEDS_UPDATING );
		component->handleEvent( &updateEvent );
		it ++;
	}
}

void UIToolkit::internal_idleTime()
{
	Frame* frm = Frame::getActiveFrame();
	if ( NULL != frm ) {
		if ( frm->getVisible() ) {
			std::vector<Component*>::iterator it = componentsToUpdate_.begin();
			while ( it != componentsToUpdate_.end() ) {
				Component* component = *it;
				Event updateEvent( this, Component::COMPONENT_NEEDS_UPDATING );
				component->handleEvent( &updateEvent );
				it ++;
			}
		}
	}
}


/**
$Id$
*/
