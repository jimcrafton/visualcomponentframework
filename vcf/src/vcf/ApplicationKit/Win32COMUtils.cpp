//COMUtils.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ApplicationKitPrivate.h"
#include "vcf/ApplicationKit/Win32COMUtils.h"
#include "vcf/ApplicationKit/Win32Clipboard.h"
#include <shellapi.h>
#include "thirdparty/win32/comet/interface.h"
#include "thirdparty/win32/comet/bstr.h"
#include "vcf/ApplicationKit/Win32HResult.h"

using namespace VCFCOM;
using namespace VCF;
using namespace comet;

std::map<VCF::String,UINT> COMUtils::standardWin32DataTypes;

HRESULT COMUtils::createCOMObject( const String& progID, IID interfaceID,
		                             void** object )
{
	HRESULT comResult = E_FAIL;

	CLSID clsid;

#if defined(VCF_CYGWIN) || defined(VCF_CW_W32) || defined(VCF_MINGW)
	wchar_t* tmp = new wchar_t[progID.size()+1];
	memset( tmp, 0 , (progID.size()+1)*sizeof(wchar_t) );
	AnsiString id = progID;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, id.c_str(), id.size(), tmp, progID.size() ) ) {
		return comResult;
	}


 	BSTR tmpProgID = SysAllocString( tmp );
	if ( NULL == tmpProgID ) {
		delete [] tmp;
		return comResult;
	}

	comResult = CLSIDFromProgID( tmpProgID, &clsid );

	if ( SUCCEEDED(comResult) ){
		comResult = createCOMObject( clsid, interfaceID, object );
	}

	SysFreeString( tmpProgID );
	delete [] tmp;
#else
	bstr_t tmpProgID;
	tmpProgID = progID.c_str();

	comResult = CLSIDFromProgID( tmpProgID.in(), &clsid );

	if ( SUCCEEDED(comResult) ){
		comResult = createCOMObject( clsid, interfaceID, object );
	}
#endif


	return comResult;
}

HRESULT COMUtils::createCOMObject( CLSID clsid, IID interfaceID,
		                             void** object )
{
	HRESULT result = E_FAIL;

	IUnknown* pIUnknown = NULL;

	result = CoCreateInstance( clsid, 0, CLSCTX_INPROC_SERVER, IID_IUnknown,
		                          (void**) &pIUnknown );

	if ( (SUCCEEDED(result)) && (NULL != pIUnknown) ){
		result = pIUnknown->QueryInterface( interfaceID, object );
		if ( (SUCCEEDED(result)) && (NULL != object) ){

		}

		pIUnknown->Release();

	}
	return result;

}

HRESULT COMUtils::BSTRtoString( const BSTR src, String& dest )
{
	HRESULT result = E_FAIL;
#if defined(VCF_CYGWIN) || defined(VCF_CW_W32) || defined(VCF_MINGW)
	String tmpString;
	SAFEARRAY* safeArray = NULL;
	result = VectorFromBstr(src, &safeArray );
	if ( SUCCEEDED(result) ){
		wchar_t *buf = NULL;
		uint32 bstrSize = SysStringLen( src );
		result = SafeArrayAccessData(safeArray, (void**)&buf );
		if ( SUCCEEDED(result) ) {
			char* tmp = new char[bstrSize+1];
			memset( tmp, 0, (bstrSize+1)*sizeof(char) );
			WideCharToMultiByte( CP_ACP, 0, buf, bstrSize, tmp, bstrSize, NULL, NULL );
			tmpString = tmp;
			delete [] tmp;
			result = S_OK;
		}
		SafeArrayUnaccessData( safeArray );
		SafeArrayDestroy( safeArray );
	}
#else
	bstr_t tmp( src );
	String tmpString( tmp.c_str() );
#endif
	dest = tmpString;
	result = S_OK;
	return result;
}

HRESULT COMUtils::UUIDtoString( const UUID id, String& dest )
{
	HRESULT result = E_FAIL;


	if ( System::isUnicodeEnabled() ) {
		WideChar* tmpid = NULL;
		RPC_STATUS rpcresult = UuidToStringW( const_cast<UUID*>( &id ), reinterpret_cast<unsigned short**>(&tmpid) );

		if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
			result = E_FAIL;
		}
		else {
			dest = "";
			dest = String( tmpid );

			RpcStringFreeW( reinterpret_cast<unsigned short**>(&tmpid) );

			result = S_OK;
		}
	}
	else{
		char* tmpid = NULL;
		RPC_STATUS rpcresult = UuidToStringA( const_cast<UUID*>( &id ), (unsigned char**)&tmpid );

		if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
			result = E_FAIL;
		}
		else {
			dest = "";
			dest = String( tmpid );

			RpcStringFreeA( (unsigned char**)&tmpid );

			result = S_OK;
		}
	}

	return result;
}

HRESULT COMUtils::StringtoUUID( const String& src, UUID& destID )
{
	HRESULT result = E_FAIL;
	UUID tmpUUID;

	RPC_STATUS rpcresult = 0;

	if ( System::isUnicodeEnabled() ) {
		WideChar tmpid[256];
		memset(tmpid,0,256);
		src.copy( tmpid, minVal<>(sizeof(tmpid),src.size()) );

		rpcresult = UuidFromStringW( reinterpret_cast<unsigned short*>(&tmpid[0]), &tmpUUID );
	}
	else {
		AnsiString s = src;
		char tmpid[256];
		memset(tmpid,0,256);
		s.copy( tmpid, minVal<>(sizeof(tmpid),s.size()) );

		rpcresult = UuidFromStringA( (unsigned char*)tmpid, &tmpUUID );
	}

	if ( RPC_S_OUT_OF_MEMORY == rpcresult ) {
		result = E_FAIL;
	}
	else {
		destID = tmpUUID;

		result = S_OK;
	}

	return result;
}

HRESULT COMUtils::makeDefaultFormatETC( const CLIPFORMAT& clipboardFormat, FORMATETC* formatETC )
{
	HRESULT result = E_FAIL;

	if ( NULL != formatETC ){
		formatETC->cfFormat = clipboardFormat;
		formatETC->dwAspect = DVASPECT_CONTENT;
		formatETC->lindex = -1;
		formatETC->ptd = NULL;
		formatETC->tymed = TYMED_HGLOBAL;
		result = S_OK;
	}

	return result;
}

HRESULT COMUtils::getPidlsFromHGlobal(const HGLOBAL HGlob, std::vector<String>& fileNames  )
{
	LPIDA pCIDA = NULL;
	HRESULT result = E_FAIL;

	pCIDA = LPIDA(GlobalLock(HGlob));

	fileNames.clear();

	int count = pCIDA->cidl;
	for (int i=0;i < count; i++){
		 // [0]: folder IDList, [1] to [cidl]: item IDList
		LPCITEMIDLIST pidlf = NULL;
		pidlf = (LPCITEMIDLIST)( ((UINT_PTR)pCIDA) + pCIDA->aoffset[0] );

		String fixedPath;
		String pidlPath;

		LPCITEMIDLIST pidl = NULL;
		pidl = (LPCITEMIDLIST)( ((UINT_PTR)pCIDA) + pCIDA->aoffset[i+1] );

		if ( System::isUnicodeEnabled() ) {
			WideChar pathf[MAX_PATH] = L"";

			SHGetPathFromIDListW(pidlf, pathf);

			fixedPath = pathf;

			WideChar path[MAX_PATH] = L"";
			SHGetPathFromIDListW(pidl, path);
			pidlPath = path;
		}
		else {
			char pathf[MAX_PATH] = "";

			SHGetPathFromIDListA(pidlf, pathf);

			fixedPath = pathf;

			char path[MAX_PATH] = "";
			SHGetPathFromIDListA(pidl, path);
			pidlPath = path;
		}

		int pos = pidlPath.find_last_of( "\\");
		if ( pos != 0 ){
			int strLength = pidlPath.length();
			strLength -= pos;
			String subStr = pidlPath.substr( pos, strLength );
			if ( (subStr != "") && (subStr.length() > 0) ){
				fixedPath += subStr;
				fileNames.push_back( fixedPath );
				result = S_OK;
			}
		}
	}
	GlobalUnlock(HGlob);

	return result;
}

HRESULT COMUtils::StringtoBSTR( const String& src, BSTR& dest )
{
	HRESULT result = E_FAIL;

/*#if defined(VCF_CYGWIN) || defined(VCF_CW_W32)
    wchar_t* tmp = new wchar_t[src.size()+1];
	memset( tmp, 0 , src.size()+1 );
	AnsiString asrc = src;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, asrc.c_str(), asrc.size(), tmp, src.size() ) ) {
	    return result;*/
#if defined(VCF_CYGWIN) || defined(VCF_CW_W32)  || defined(VCF_MINGW)
	wchar_t* tmp = new wchar_t[src.size()+1];
	memset( tmp, 0 , (src.size()+1)*sizeof(wchar_t) );
	AnsiString asrc = src;
	if ( 0 == MultiByteToWideChar( CP_ACP, 0, asrc.c_str(), asrc.size(), tmp, src.size() ) ) {
		return result;
	}

	result = SysReAllocString( &dest, tmp );

	delete [] tmp;
#else
	bstr_t tmp( src.c_str() );
	dest = bstr_t::detach(tmp);
#endif


	result = S_OK;
	return result;
}

DWORD COMUtils::translateActionType( const VCF::DragActionType& action )
{
	DWORD result = 0;
	switch ( action ){
		case daNone:{
			result = DROPEFFECT_NONE;
		}
		break;

		case daCopy:{
			result = DROPEFFECT_COPY;
		}
		break;

		case daMove:{
			result = DROPEFFECT_MOVE;
		}
		break;

		case daLink:{
			result = DROPEFFECT_LINK;
		}
		break;
	};

	return result;
}

FORMATETC COMUtils::translateDataTypeToWin32( const String& dataType )
{
	FORMATETC result;
	memset( &result, 0, sizeof(result) );
	COMUtils::makeDefaultFormatETC( 0, &result );

	std::map<VCF::String,UINT>::iterator found =  COMUtils::standardWin32DataTypes.find( dataType );

	if ( found != COMUtils::standardWin32DataTypes.end() ) {
		result.cfFormat = found->second;

		switch ( result.cfFormat ) {
			case CF_METAFILEPICT : {
				result.tymed = TYMED_MFPICT;
			}
			break;

			case CF_ENHMETAFILE : {
				result.tymed = TYMED_ENHMF;
			}
			break;

			case CF_BITMAP : {
				result.tymed = TYMED_GDI;
			}
			break;
		}
	}
	else {
		if ( System::isUnicodeEnabled() ) {
			result.cfFormat = ::RegisterClipboardFormatW( dataType.c_str() );
		}
		else {
			result.cfFormat = ::RegisterClipboardFormatA( dataType.ansi_c_str() );
		}

		COMUtils::standardWin32DataTypes[dataType] = result.cfFormat;
	}

	return result;
}

String COMUtils::translateWin32ClipboardFormat( const FORMATETC& formatETC )
{
	String result;


	std::map<VCF::String,UINT>::iterator it =  COMUtils::standardWin32DataTypes.begin();
	while ( it != COMUtils::standardWin32DataTypes.end() ) {

		if ( it->second == formatETC.cfFormat ) {
			result = it->first;
			break;
		}
		it ++;
	}

	if ( !result.empty() ) {
		return result;
	}

	//otherwise do it the hard way....




	switch ( formatETC.cfFormat ){

		//apparently this is RTF format
		case 49239:{
			result =  RTF_DATA_TYPE;
		}
		break;

		case CF_TEXT:{
			result =  STRING_DATA_TYPE;
		}
		break;

		case CF_HDROP:{
			result = FILE_DATA_TYPE;
		}
		break;

		case CF_BITMAP:{
			result = "image/bmp";
		}
		break;

		case CF_DIB:{

		}
		break;
/*
		case CF_DIBV5:{

		}
		break;
*/
		case CF_DIF:{

		}
		break;

		case CF_DSPBITMAP:{

		}
		break;

		case CF_DSPENHMETAFILE:{

		}
		break;

		case CF_DSPMETAFILEPICT:{

		}
		break;

		case CF_DSPTEXT:{

		}
		break;

		case CF_ENHMETAFILE:{
			result = "image/application-x-emf";
		}
		break;

		case CF_LOCALE:{

		}
		break;

		case CF_METAFILEPICT:{
			result = "image/application-x-wmf";
		}
		break;

		case CF_OEMTEXT:{

		}
		break;

		case CF_OWNERDISPLAY:{

		}
		break;

		case CF_PALETTE:{

		}
		break;

		case CF_PENDATA:{

		}
		break;

		case CF_RIFF:{

		}
		break;

		case CF_SYLK:{

		}
		break;

		case CF_WAVE:{

		}
		break;

		case CF_TIFF:{
			result = "image/tiff";
		}
		break;

		case CF_UNICODETEXT:{

		}
		break;
	}
	return result;
}

VCF::DataObject* COMUtils_createFromHGlobal( STGMEDIUM& stg, const VCF::String& dataType )
{
	VCF::DataObject* result = NULL;

	uchar* rawGlobalMem = (uchar*)::GlobalLock( stg.hGlobal );
	uint32 memSize = GlobalSize( stg.hGlobal );

	if ( dataType == STRING_DATA_TYPE ) {
		AnsiString tmp;
		tmp.append( (const char*)rawGlobalMem, memSize );

		result = new TextDataObject(String(tmp));
	}
	else if ( dataType == COMPONENT_DATA_TYPE ) {
		AnsiString tmp;
		tmp.append( (const char*)rawGlobalMem, memSize );

		result = new TextDataObject(tmp);
	}
	else if ( (dataType == "image/bmp") || (dataType == IMAGE_DATA_TYPE) ) {
		BasicInputStream bis( rawGlobalMem, memSize );
		Image* image = GraphicsToolkit::createImage(1,1);

		bis >> dynamic_cast<VCF::Persistable*>(image);

		result = new ImageDataObject(image);
	}
	else if ( dataType == FILE_DATA_TYPE ) {


		uint32 count = DragQueryFile((HDROP)stg.hGlobal, (UINT)-1, NULL, 0);
		if ( count > 0 ) {
			String data;
			FilePath fp;
			result = new VCF::DataObject();

			bool unicodeEnabled = System::isUnicodeEnabled();


			for ( int i=0;i<count;i++ ) {


				if ( unicodeEnabled ) {
					VCFChar tmp[MAX_PATH];
					DragQueryFileW((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}
				else {
					char tmp[MAX_PATH];
					DragQueryFileA((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}

				if ( i > 0 ) {
					data += "\n";
				}

				data += fp;
			}
			result->addSupportedDataType( dataType, new BinaryPersistable( (const unsigned char*)data.c_str(), data.size_in_bytes() ) );
		}
	}
	else {
		result = new VCF::DataObject();
		result->addSupportedDataType( dataType, new BinaryPersistable( (unsigned char*)rawGlobalMem, memSize ) );
	}

	::GlobalUnlock( stg.hGlobal );
	return result;
}

VCF::Persistable* COMUtils_createPersistableFromHGlobal( STGMEDIUM& stg, const VCF::String& dataType )
{
	VCF::Persistable* result = NULL;

	uchar* rawGlobalMem = (uchar*)::GlobalLock( stg.hGlobal );
	uint32 memSize = GlobalSize( stg.hGlobal );

	if ( (dataType == L"image/bmp" ) || (dataType == IMAGE_DATA_TYPE) ) {
		BasicInputStream bis( rawGlobalMem, memSize );

		Image* image = GraphicsToolkit::createImage(1,1);

		result = dynamic_cast<VCF::Persistable*>(image);

		bis >> result;
	}
	else if ( dataType == FILE_DATA_TYPE ) {

		uint32 count = DragQueryFile((HDROP)stg.hGlobal, (UINT)-1, NULL, 0);
		if ( count > 0 ) {
			String data;
			FilePath fp;
			bool unicodeEnabled = System::isUnicodeEnabled();


			for ( int i=0;i<count;i++ ) {

				if ( unicodeEnabled ) {
					VCFChar tmp[MAX_PATH];
					DragQueryFileW((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}
				else {
					char tmp[MAX_PATH];
					DragQueryFileA((HDROP)stg.hGlobal, i, tmp, MAX_PATH-1 );
					fp = String(tmp);
				}

				if ( i > 0 ) {
					data += "\n";
				}

				data += fp;
			}

			result = new BinaryPersistable( (const unsigned char*)data.c_str(), data.size_in_bytes() );
		}
	}
	else {
		result = new BinaryPersistable( (unsigned char*)rawGlobalMem, memSize );
	}

	::GlobalUnlock( stg.hGlobal );
	return result;
}

//#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
//#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

void COMUtils_HiMetricToPixel( const SIZE& sizeInHiMetric, SIZE& sizeInPix )
{
	const int HIMETRIC_PER_INCH = 2540;

	HDC hDCScreen = GetDC(::GetDesktopWindow());


	// Pixels per logical inch along width
	int pixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	// Pixels per logical inch along height
	int pixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);

	ReleaseDC(::GetDesktopWindow(), hDCScreen);

	sizeInPix.cx = (pixelsPerInchX * sizeInHiMetric.cx + (HIMETRIC_PER_INCH/2)) / HIMETRIC_PER_INCH;
	sizeInPix.cy = (pixelsPerInchY * sizeInHiMetric.cy + (HIMETRIC_PER_INCH/2)) / HIMETRIC_PER_INCH;
}

VCF::Persistable* COMUtils::getPersistableFromOLEDataObject( const VCF::String dataType, IDataObject* oleDataObject, FORMATETC* fmtETC )
{
	VCF::Persistable* result = NULL;
	HRESULT hr = oleDataObject->QueryGetData( fmtETC );
	if ( SUCCEEDED(hr) ) {
		STGMEDIUM stg;
		memset( &stg, 0, sizeof(STGMEDIUM) );

		hr = oleDataObject->GetData( fmtETC, &stg );
		if ( SUCCEEDED(hr) ) {
			switch( stg.tymed ) {
				case TYMED_HGLOBAL : {
					result = COMUtils_createPersistableFromHGlobal( stg, dataType );
				}
				break;

				case TYMED_GDI : {
					BITMAP bmp;
					memset( &bmp, 0, sizeof(BITMAP) );
					int err = ::GetObject( stg.hBitmap, sizeof(BITMAP), &bmp );

					if ( 0 == err ) {
						//throw an exception - failed top get bitmap info
					}

					Image* image = GraphicsToolkit::createImage( bmp.bmWidth, bmp.bmHeight );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC dc = win32Image->getDC();

					HDC tmpDC = ::CreateCompatibleDC( NULL );

					HBITMAP oldBMP = (HBITMAP)::SelectObject( tmpDC, stg.hBitmap );

					err = ::BitBlt( dc, 0, 0, bmp.bmWidth, bmp.bmHeight, tmpDC, 0, 0, SRCCOPY );

					::SelectObject( tmpDC, oldBMP );
					::DeleteDC( tmpDC );

					result = dynamic_cast<Persistable*>( image );
				}
				break;

				case TYMED_MFPICT : {

					METAFILEPICT* metaFilePict = (METAFILEPICT*) GlobalLock( stg.hGlobal );
					SIZE sz = { metaFilePict->xExt, metaFilePict->yExt };
					SIZE sz2;

					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, metaFilePict->mm );

					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );


					int err = PlayMetaFile( bmpDC, metaFilePict->hMF );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( err ) {
						result = dynamic_cast<Persistable*>( image );
					}
					else {
						err = ::GetLastError();
					}


					::GlobalUnlock( stg.hGlobal );

				}
				break;

				case TYMED_ENHMF : {

					ENHMETAHEADER metaHdr;
					memset( &metaHdr, 0, sizeof(ENHMETAHEADER) );

					int err = GetEnhMetaFileHeader( stg.hEnhMetaFile, sizeof(ENHMETAHEADER), &metaHdr );

					SIZE sz = {metaHdr.rclFrame.right-metaHdr.rclFrame.left,
								metaHdr.rclFrame.bottom - metaHdr.rclFrame.top};
					SIZE sz2;
					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, MM_TEXT );
					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );

					err = PlayEnhMetaFile( bmpDC, stg.hEnhMetaFile, (RECT *)&metaHdr.rclBounds );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( FALSE != err ) {
						result = dynamic_cast<Persistable*>( image );
					}

				}
				break;

				case TYMED_ISTREAM : {

				}
				break;

				case TYMED_ISTORAGE : {

				}
				break;
			}

			ReleaseStgMedium( &stg );
		}
	}

	return result;
}

VCF::DataObject* COMUtils::getDataObjectFromOLEDataObject( const VCF::String dataType, IDataObject* oleDataObject, FORMATETC* fmtETC )
{

	VCF::DataObject* result = NULL;

	HRESULT hr = oleDataObject->QueryGetData( fmtETC );
	if ( SUCCEEDED(hr) ) {
		STGMEDIUM stg;
		memset( &stg, 0, sizeof(STGMEDIUM) );

		hr = oleDataObject->GetData( fmtETC, &stg );
		if ( SUCCEEDED(hr) ) {
			switch( stg.tymed ) {
				case TYMED_HGLOBAL : {
					result = COMUtils_createFromHGlobal( stg, dataType );
				}
				break;

				case TYMED_GDI : {
					BITMAP bmp;
					memset( &bmp, 0, sizeof(BITMAP) );
					int err = ::GetObject( stg.hBitmap, sizeof(BITMAP), &bmp );

					if ( 0 == err ) {
						//throw an exception - failed top get bitmap info
					}

					Image* image = GraphicsToolkit::createImage( bmp.bmWidth, bmp.bmHeight );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC dc = win32Image->getDC();

					HDC tmpDC = ::CreateCompatibleDC( NULL );

					HBITMAP oldBMP = (HBITMAP)::SelectObject( tmpDC, stg.hBitmap );

					err = ::BitBlt( dc, 0, 0, bmp.bmWidth, bmp.bmHeight, tmpDC, 0, 0, SRCCOPY );

					::SelectObject( tmpDC, oldBMP );
					::DeleteDC( tmpDC );

					result = new ImageDataObject( image );

					delete image;
				}
				break;

				case TYMED_MFPICT : {

					METAFILEPICT* metaFilePict = (METAFILEPICT*) GlobalLock( stg.hGlobal );
					SIZE sz = { metaFilePict->xExt, metaFilePict->yExt };
					SIZE sz2;

					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, metaFilePict->mm );

					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );


					int err = PlayMetaFile( bmpDC, metaFilePict->hMF );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( err ) {

						result = new ImageDataObject( image );
					}
					else {
						delete image;
						err = ::GetLastError();
					}



					::GlobalUnlock( stg.hGlobal );

				}
				break;

				case TYMED_ENHMF : {

					ENHMETAHEADER metaHdr;
					memset( &metaHdr, 0, sizeof(ENHMETAHEADER) );

					int err = GetEnhMetaFileHeader( stg.hEnhMetaFile, sizeof(ENHMETAHEADER), &metaHdr );

					SIZE sz = {metaHdr.rclFrame.right-metaHdr.rclFrame.left,
								metaHdr.rclFrame.bottom - metaHdr.rclFrame.top};
					SIZE sz2;
					COMUtils_HiMetricToPixel( sz, sz2 );

					Image* image = GraphicsToolkit::createImage( sz2.cx, sz2.cy );
					Win32Image* win32Image = dynamic_cast<Win32Image*>( image );
					HDC bmpDC = win32Image->getDC();

					UINT oldMM = ::SetMapMode( bmpDC, MM_TEXT );
					POINT pt = {0,0};
					::SetViewportOrgEx( bmpDC, 0, 0, &pt );
					SIZE viewPtExt = {0,0};
					::SetViewportExtEx( bmpDC, sz2.cx, sz2.cy, &viewPtExt );

					err = PlayEnhMetaFile( bmpDC, stg.hEnhMetaFile, (RECT *)&metaHdr.rclBounds );

					::SetMapMode( bmpDC, oldMM );
					::SetViewportOrgEx( bmpDC, pt.x, pt.y, NULL );
					::SetViewportExtEx( bmpDC, viewPtExt.cx, viewPtExt.cy, NULL );

					if ( FALSE != err ) {
						result = new ImageDataObject( image );
					}
					delete image;

				}
				break;

				case TYMED_ISTREAM : {

				}
				break;

				case TYMED_ISTORAGE : {

				}
				break;
			}

			ReleaseStgMedium( &stg );
		}
	}

	return result;
}


void COMUtils::registerDataTypes()
{

#if defined(VCF_CW) && defined(VCF_UNICODE)
	VCFCOM::COMUtils::standardWin32DataTypes[STRING_DATA_TYPE] = CF_TEXT;
	VCFCOM::COMUtils::standardWin32DataTypes[INTEGER_DATA_TYPE] = ::RegisterClipboardFormat( L"text/x-vcf-integer" );
	VCFCOM::COMUtils::standardWin32DataTypes[OBJECT_DATA_TYPE] = ::RegisterClipboardFormat( L"application/x-vcf-object" );
	VCFCOM::COMUtils::standardWin32DataTypes[FILE_DATA_TYPE] = CF_HDROP;
	VCFCOM::COMUtils::standardWin32DataTypes[BYTE_STREAM_DATA_TYPE] = ::RegisterClipboardFormat( L"application/octet-stream" );
	VCFCOM::COMUtils::standardWin32DataTypes[IMAGE_DATA_TYPE] = ::RegisterClipboardFormat( L"image/x-vcf-image" );
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-wmf"] = CF_METAFILEPICT;
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-emf"] = CF_ENHMETAFILE;
	VCFCOM::COMUtils::standardWin32DataTypes["image/bmp"] = CF_BITMAP;
	VCFCOM::COMUtils::standardWin32DataTypes[COMPONENT_DATA_TYPE] = ::RegisterClipboardFormat( L"text/x-vcf-vff" );
#else
	VCFCOM::COMUtils::standardWin32DataTypes[STRING_DATA_TYPE] = CF_TEXT;
	VCFCOM::COMUtils::standardWin32DataTypes[INTEGER_DATA_TYPE] = ::RegisterClipboardFormat( "text/x-vcf-integer" );
	VCFCOM::COMUtils::standardWin32DataTypes[OBJECT_DATA_TYPE] = ::RegisterClipboardFormat( "application/x-vcf-object" );
	VCFCOM::COMUtils::standardWin32DataTypes[FILE_DATA_TYPE] = CF_HDROP;
	VCFCOM::COMUtils::standardWin32DataTypes[BYTE_STREAM_DATA_TYPE] = ::RegisterClipboardFormat( "application/octet-stream" );
	VCFCOM::COMUtils::standardWin32DataTypes[IMAGE_DATA_TYPE] = ::RegisterClipboardFormat( "image/x-vcf-image" );
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-wmf"] = CF_METAFILEPICT;
	VCFCOM::COMUtils::standardWin32DataTypes["image/application-x-emf"] = CF_ENHMETAFILE;
	VCFCOM::COMUtils::standardWin32DataTypes["image/bmp"] = CF_BITMAP;
	VCFCOM::COMUtils::standardWin32DataTypes[COMPONENT_DATA_TYPE] = ::RegisterClipboardFormat( "text/x-vcf-vff" );
#endif
}


/**
$Id$
*/
