//TreeControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/TreeControl.h"
#include "vcf/ApplicationKit/TreePeer.h"
#include "vcf/ApplicationKit/DefaultTreeModel.h"
#include "vcf/ApplicationKit/DefaultTreeItem.h"


using namespace VCF;

TreeControl::TreeControl():
	imageList_(NULL),
	stateImageList_(NULL),
	treeModel_(NULL),
	currentSelectedItem_(NULL)
{
	treePeer_ = UIToolkit::createTreePeer( this );
	peer_ = dynamic_cast<ControlPeer*>( treePeer_ );

	if ( NULL == treePeer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	peer_->create( this );

	init();

	setVisible( true );
}

TreeControl::~TreeControl()
{
	if ( NULL != treeModel_ ) {
//		treeModel_->release();
	}
	treeModel_ = NULL;
}

void TreeControl::init()
{

	CallBack* tmh =
		new ClassProcedure1<TreeModelEvent*,TreeControl>( this,
												&TreeControl::onTreeRootNodeChanged,
												"TreeControl::onTreeRootNodeChanged" );



	tmh = new ClassProcedure1<TreeModelEvent*,TreeControl>( this,
													&TreeControl::onTreeNodeAdded,
													"TreeControl::onTreeNodeAdded" );

	tmh = new ClassProcedure1<TreeModelEvent*,TreeControl>( this,
													&TreeControl::onTreeNodeDeleted,
													"TreeControl::onTreeNodeDeleted" );

	

	CallBack* mh = new ClassProcedure1<ModelEvent*,TreeControl>( this, &TreeControl::onModelEmptied, "ModelHandler" );


	setTreeModel( new DefaultTreeModel() );

	addComponent( getViewModel() );

	setBorder( new Basic3DBorder( true ) );

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );
}

void TreeControl::setTreeModel( TreeModel * model )
{
	if ( NULL != treeModel_ ){

		EventHandler* ev = (EventHandler*)getEventHandler( "TreeControl::onTreeRootNodeChanged" );
		treeModel_->removeTreeRootNodeChangedHandler ( ev );

		ev = (EventHandler*)getEventHandler( "TreeControl::onTreeNodeAdded" );
		treeModel_->removeTreeNodeAddedHandler( ev );

		ev = (EventHandler*)getEventHandler( "TreeControl::onTreeNodeDeleted" );
		treeModel_->removeTreeNodeDeletedHandler( ev );

		ev = (EventHandler*)getEventHandler( "ModelHandler" );
		getViewModel()->removeModelHandler( (ModelHandler*)ev );
	}

	treeModel_ = model;

	if ( NULL != treeModel_ ) {

		EventHandler* tml = (EventHandler*)getEventHandler( "TreeControl::onTreeRootNodeChanged" );
		treeModel_->addTreeRootNodeChangedHandler ( tml );

		tml = (EventHandler*)getEventHandler( "TreeControl::onTreeNodeAdded" );
		treeModel_->addTreeNodeAddedHandler( tml );

		tml = (EventHandler*)getEventHandler( "TreeControl::onTreeNodeDeleted" );
		treeModel_->addTreeNodeDeletedHandler( tml );		
	}

	setViewModel( dynamic_cast<Model*>(treeModel_) );

	if ( NULL != treeModel_ ) {
		getViewModel()->addModelHandler( (ModelHandler*)getEventHandler( "ModelHandler" ) );
	}
}

TreeModel* TreeControl::getTreeModel()
{
	return treeModel_;
}

ImageList* TreeControl::getImageList()
{
	return imageList_;
}

void TreeControl::setImageList( ImageList* imageList )
{
	imageList_ = imageList;
	treePeer_->setImageList( imageList );
}

void TreeControl::paint( GraphicsContext * context )
{
	Rect innerBounds = getClientBounds( false );	

	context->setColor( getColor() );
			
	context->rectangle( &innerBounds );
			
	context->fillPath();
}

void TreeControl::onTreeRootNodeChanged( TreeModelEvent* event )
{
	TreeItem* item = event->getTreeItem();
	//treePeer_->addItem( item );
}

void TreeControl::onTreeNodeAdded( TreeModelEvent* event )
{
	TreeItem* item = event->getTreeItem();
	
	item->setControl( this );

	treePeer_->addItem( item );
	CallBack* il = getEventHandler( "TreeItemListener" );
	if  ( il == NULL ) {
		il = new ClassProcedure1<ItemEvent*,TreeControl>( this, &TreeControl::onTreeItemPaint, "TreeItemListener" );
	}
	item->ItemPaint += il;
}

void TreeControl::onTreeNodeDeleted( TreeModelEvent* event )
{
	if ( currentSelectedItem_ == event->getTreeItem() ) {
		currentSelectedItem_ = NULL;
	}
}

void TreeControl::onModelEmptied( ModelEvent* event )
{
	treePeer_->clear();
	currentSelectedItem_ = NULL;
}

TreeItem* TreeControl::hitTestForItem( Point* pt, TreeItem* item )
{
	TreeItem* result = NULL;
	if ( item->containsPoint( pt ) ) {
		result = item;
	}
	else if ( !item->isLeaf() && item->isExpanded() ){
		Enumerator<TreeItem*>* children = item->getChildren();
		while ( children->hasMoreElements() ) {
			TreeItem* childItem = children->nextElement();
			result = hitTestForItem( pt, childItem );
			if ( result != NULL ) {
				break;
			}
		}
	}

	return result;
}

TreeItem* TreeControl::findItem( Point* pt )
{
	TreeItem* result = NULL;

	Enumerator<TreeItem*>* rootItems = treeModel_->getRootItems();
	while ( true == rootItems->hasMoreElements() ) {
		TreeItem* item = rootItems->nextElement();
		result = hitTestForItem( pt, item );
		if ( NULL != result ) {
			break;
		}
	}

	return result;
}

double TreeControl::getItemIndent()
{
	return treePeer_->getItemIndent();
}

void TreeControl::setItemIndent( const double& indent )
{
	treePeer_->setItemIndent( indent );
}

void TreeControl::onTreeItemPaint( ItemEvent* event )
{
	return ;

	TreeItem* item = (TreeItem*)event->getSource();
	GraphicsContext* context = event->getContext();
	if ( NULL != context ) {
		ImageList* il = getImageList();
		if ( NULL != il ) {
			Rect imgRect = *(item->getBounds());
			imgRect.left_ += (item->getLevel()+1) * getItemIndent();
			imgRect.right_ = imgRect.left_ + il->getImageWidth();
			context->setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );
			context->rectangle( &imgRect );
			context->fillPath();

			if ( stateImageList_ == NULL ) {
				il->draw( context, item->getImageIndex(), &imgRect );
			}
			else {
				if ( true == item->isSelected() ) {
					if ( true == item->isExpanded() ) {
						if ( item->getExpandedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getExpandedImageIndex(), &imgRect );
						}
						else if ( item->getSelectedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getSelectedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
					else {
						if ( item->getSelectedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getSelectedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
				}
				else {
					if ( true == item->isExpanded() ) {
						if ( item->getExpandedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getExpandedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
					else {
						il->draw( context, item->getImageIndex(), &imgRect );
					}
				}
			}
		}
	}
}

void TreeControl::setStateImageList( ImageList* imageList )
{
	stateImageList_ = imageList;
	treePeer_->setStateImageList( imageList );
}

ImageList* TreeControl::getStateImageList()
{
	return stateImageList_;
}

void TreeControl::addItem( TreeItem* parent, TreeItem* item )
{
	treeModel_->addNodeItem( item, parent );
}

TreeItem* TreeControl::addItem( TreeItem* parent, const String& caption, const uint32 imageIndex )
{
	TreeItem* result = NULL;
	result = new DefaultTreeItem( caption, this, treeModel_ );
	result->setImageIndex( imageIndex );
	treeModel_->addNodeItem( result, parent );
	return result;
}

void TreeControl::removeItem( TreeItem* item )
{
	treeModel_->deleteNodeItem( item );
}

TreeItem* TreeControl::getSelectedItem()
{
	return currentSelectedItem_;
}

Rect TreeControl::getItemImageRect( TreeItem* item )
{
	return treePeer_->getItemImageRect( item );
}

void TreeControl::handleEvent( Event* event )
{
	Control::handleEvent( event );
	switch ( event->getType() ) {
		case TREEITEM_SELECTED : {
			currentSelectedItem_ = (TreeItem*)event->getUserData();

			ItemSelected( (ItemEvent*)event );
		}
		break;

		case TREEITEM_EXPANDED : {
			ItemExpanded( (ItemEvent*)event );
		}
		break;

		case TreeControl::ITEM_STATECHANGE_REQUESTED : {
			ItemStateChangeRequested( (ItemEvent*)event );
		}
		break;

	}
}

bool TreeControl::getAllowLabelEditing()
{
	return treePeer_->getAllowLabelEditing();
}

void TreeControl::setAllowLabelEditing( const bool& allowLabelEditing )
{
	treePeer_->setAllowLabelEditing( allowLabelEditing );
}

Rect TreeControl::getItemRect( TreeItem* item )
{
	return treePeer_->getItemRect( item );
}


/**
$Id$
*/
