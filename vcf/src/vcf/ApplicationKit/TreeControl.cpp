//TreeControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */
#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/TreeControl.h"
#include "vcf/ApplicationKit/TreePeer.h"
#include "vcf/ApplicationKit/DefaultTreeModel.h"
#include "vcf/ApplicationKit/TreeItem.h"


using namespace VCF;

TreeControl::TreeControl():
	imageList_(NULL),
	stateImageList_(NULL),
	currentSelectedItem_(NULL),
	controlChangeToModel_(false),
	columnModel_(NULL),
	inCallbackChange_(false)
{
	treePeer_ = UIToolkit::createTreePeer( this );
	peer_ = dynamic_cast<ControlPeer*>( treePeer_ );

	if ( NULL == treePeer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	peer_->create( this );

	CallBack* mh = new ClassProcedure1<ModelEvent*,TreeControl>( this, &TreeControl::onModelChanged, "TreeControl::onModelChanged" );

	setViewModel( new DefaultTreeModel() );

	addComponent( getViewModel() );

	setBorder( new Basic3DBorder( true ) );

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );

	setVisible( true );
}

TreeControl::TreeControl( TreeModel* model ):
	imageList_(NULL),
	stateImageList_(NULL),
	currentSelectedItem_(NULL),
	controlChangeToModel_(false),
	columnModel_(NULL),
	inCallbackChange_(false)
{
	treePeer_ = UIToolkit::createTreePeer( this );
	peer_ = dynamic_cast<ControlPeer*>( treePeer_ );

	if ( NULL == treePeer_ ){
		throw InvalidPeer(MAKE_ERROR_MSG(NO_PEER), __LINE__);
	};

	peer_->create( this );

	CallBack* mh = new ClassProcedure1<ModelEvent*,TreeControl>( this, &TreeControl::onModelChanged, "TreeControl::onModelChanged" );

	if ( NULL != model ) {
		setViewModel( model );
		
		
		addComponent( getViewModel() );
	}

	setBorder( new Basic3DBorder( true ) );

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );

	setVisible( true );
}


TreeControl::~TreeControl()
{
	
}


void TreeControl::modelChanged( Model* oldModel, Model* newModel )
{
	TreeModel* tm = (TreeModel*)oldModel;
	if ( NULL != tm ) {
		CallBack* ev = getCallback( "TreeControl::onModelChanged" );
		tm->ModelChanged -= (ModelHandler*)ev;
	}

	tm = (TreeModel*)newModel;

	if ( NULL != tm ) {
		tm->ModelChanged += getCallback( "TreeControl::onModelChanged" );
	}

}


TreeModel* TreeControl::getTreeModel()
{
	return (TreeModel*) getViewModel();
}

void TreeControl::setTreeModel( TreeModel* tm )
{	
	setViewModel( tm );
}

ImageList* TreeControl::getImageList()
{
	return imageList_;
}

void TreeControl::setImageList( ImageList* imageList )
{
	imageList_ = imageList;
	treePeer_->setImageList( imageList );
}

void TreeControl::paint( GraphicsContext * context )
{
	Rect innerBounds = getClientBounds( false );	

	context->setColor( getColor() );
			
	context->rectangle( &innerBounds );
			
	context->fillPath();
}



void TreeControl::onModelChanged( ModelEvent* event )
{
	//treePeer_->clear();
	//currentSelectedItem_ = NULL;

	if ( !controlChangeToModel_ ) {
		switch ( event->getType() ) {
			case TreeModel::ItemRemoved : {
				TreeModelEvent* te = (TreeModelEvent*)event;

				if ( this->itemExists( te->key ) ) {
					std::map<TreeModel::Key,TreeItem*>::iterator it = itemMap_.find( te->key );

					if ( it != itemMap_.end() ) {						
						TreeItem* item = it->second;
						if ( currentSelectedItem_ == item ) {
							currentSelectedItem_ = NULL;
						}
						removeComponent( item );
						itemMap_.erase( it );
					}					
				}
			}
			break;

			case TreeModel::ContentsDeleted : {
				currentSelectedItem_ = NULL;

				std::map<TreeModel::Key,TreeItem*>::iterator it = itemMap_.begin();
				while ( it != itemMap_.end() ) {
					TreeItem* item = it->second;
					
					removeComponent( item );
					item->free();

					++it;
				}

				itemMap_.clear();
			}
			break;
		}
	}
}


double TreeControl::getItemIndent()
{
	return treePeer_->getItemIndent();
}

void TreeControl::setItemIndent( const double& indent )
{
	treePeer_->setItemIndent( indent );
}

void TreeControl::onTreeItemPaint( ItemEvent* event )
{
	return ;

	TreeItem* item = (TreeItem*)event->getSource();
	GraphicsContext* context = event->paintContext;
	if ( NULL != context ) {
		ImageList* il = getImageList();
		if ( NULL != il ) {
			Rect imgRect = item->getBounds();
			imgRect.left_ += (item->getLevel()+1) * getItemIndent();
			imgRect.right_ = imgRect.left_ + il->getImageWidth();
			context->setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );
			context->rectangle( &imgRect );
			context->fillPath();

			if ( stateImageList_ == NULL ) {
				il->draw( context, item->getImageIndex(), &imgRect );
			}
			else {
				if ( true == item->isSelected() ) {
					if ( true == item->isExpanded() ) {
						if ( item->getExpandedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getExpandedImageIndex(), &imgRect );
						}
						else if ( item->getSelectedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getSelectedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
					else {
						if ( item->getSelectedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getSelectedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
				}
				else {
					if ( true == item->isExpanded() ) {
						if ( item->getExpandedImageIndex() >= 0 ) {
							stateImageList_->draw( context, item->getExpandedImageIndex(), &imgRect );
						}
						else {
							il->draw( context, item->getImageIndex(), &imgRect );
						}
					}
					else {
						il->draw( context, item->getImageIndex(), &imgRect );
					}
				}
			}
		}
	}
}

void TreeControl::setStateImageList( ImageList* imageList )
{
	stateImageList_ = imageList;
	treePeer_->setStateImageList( imageList );
}

ImageList* TreeControl::getStateImageList()
{
	return stateImageList_;
}

void TreeControl::insertItem( TreeItem* parent, TreeItem* item )
{
	controlChangeToModel_ = true;

	VCF_ASSERT( NULL != item );
	
	TreeModel::Key parentKey = (NULL != parent) ? parent->getKey() : TreeModel::RootKey;

	TreeModel* tm = getTreeModel();
	item->setControl( this );

	if ( item->getModel() == NULL ) {
		//no model, so we need a new key...
		TreeModel::Key key = tm->insert( VariantData(), parentKey );
		item->setKey( key );
	}
	
	item->setModel( tm );
	
	addComponent( item );

	controlChangeToModel_ = false;
}

TreeItem* TreeControl::insertItem( TreeItem* parent, const String& caption, const uint32 imageIndex )
{
	TreeItem* result = NULL;

	controlChangeToModel_ = true;

	TreeModel* tm = getTreeModel();

	TreeModel::Key parentKey = (NULL != parent) ? parent->getKey() : TreeModel::RootKey;
	TreeModel::Key key = tm->insert( caption, parentKey ); //since controlChangeToModel_ is set, onModelChanged is ignored

	result = new TreeItem();
	result->setModel( tm );//set explicitly here, since we've already generated a key

	insertItem( parent, result );

	controlChangeToModel_ = true;

	result->setCaption( caption );
	result->setImageIndex( imageIndex );
	result->setKey( key );
	


	controlChangeToModel_ = false;
	return result;
}

void TreeControl::removeItem( TreeItem* item )
{
	TreeModel* tm = getTreeModel();

	tm->remove( item->getKey() );
	item->setKey( TreeModel::InvalidKey );
}

TreeItem* TreeControl::getSelectedItem()
{
	return currentSelectedItem_;
}

Rect TreeControl::getItemImageRect( const TreeModel::Key& item )
{
	return treePeer_->getItemImageRect( item );
}

TreeModel::Key TreeControl::hitTest( const Point& pt )
{
	return treePeer_->hitTest( pt );
}

void TreeControl::handleEvent( Event* event )
{
	Control::handleEvent( event );
	switch ( event->getType() ) {
		case TREEITEM_SELECTED : {
			ItemSelected( (ItemEvent*)event );
		}
		break;

		case TreeControl::ITEM_STATECHANGE_REQUESTED : {
			ItemStateChangeRequested( (ItemEvent*)event );
		}
		break;

		case Component::COMPONENT_ADDED : {
			ComponentEvent* ev = (ComponentEvent*)event;
			Component* child = ev->getChildComponent();
			TreeItem* item = dynamic_cast<TreeItem*>(child);
			if ( NULL != item ) {
				if ( item->getControl() != this ) {
					item->setControl(this);
				}

				insertItem( item->getParent(), item );
			}
		}
		break;

		case Component::COMPONENT_REMOVED : {
			
		}
		break;

	}
}

bool TreeControl::getAllowLabelEditing()
{
	return treePeer_->getAllowLabelEditing();
}

void TreeControl::setAllowLabelEditing( const bool& allowLabelEditing )
{
	treePeer_->setAllowLabelEditing( allowLabelEditing );
}

Rect TreeControl::getItemRect( const TreeModel::Key& item )
{
	return treePeer_->getItemRect( item );
}

TreeItem* TreeControl::getItemParent( TreeItem* item )
{
	TreeItem* result = NULL;

	TreeModel::Key parent = getTreeModel()->getParent( item->getKey() );
	if ( parent != TreeModel::RootKey && parent != TreeModel::InvalidKey ) {
		result = getItemFromKey( parent );
	}

	return result;
}

void TreeControl::setItemParent( TreeItem* item, TreeItem* parent )
{
	getTreeModel()->move( item->getKey(), parent->getKey() );
}

void TreeControl::addChildItem( TreeItem* item, TreeItem* child )
{
	insertItem( item, child );
}

void TreeControl::removeChildItem( TreeItem* item, TreeItem* child )
{
	removeItem( child );
}

TreeItem* TreeControl::getItemFromKey( const TreeModel::Key& key )
{
	TreeItem* result = NULL;

	if ( key != TreeModel::InvalidKey && key != TreeModel::RootKey ) {
		std::map<TreeModel::Key,TreeItem*>::iterator found =
			itemMap_.find( key );
		if ( found != itemMap_.end() ) {
			result = found->second;
		}
		else {
			result = new TreeItem();
			result->setControl( this );
			result->setModel( getTreeModel() );

			addComponent( result );
			result->setKey( key ); //calls setItemKey() and maps the key to the item for us

		}
	}

	return result;
}

void TreeControl::setItemKey( TreeItem* item, const TreeModel::Key& key )
{
	if ( key != TreeModel::InvalidKey ) {
		itemMap_[key] = item;
	}
}

bool TreeControl::getItemChildren( TreeItem* item, std::vector<TreeItem*>& children )
{
	TreeModel* tm = getTreeModel();
	std::vector<TreeModel::Key> childKeys;
	tm->getChildren( item->getKey(), childKeys );

	std::vector<TreeModel::Key>::iterator it = childKeys.begin();
	while ( it != childKeys.end() ) {
		TreeItem* childItem = getItemFromKey( *it );
		children.push_back( childItem );
		++it;
	}


	return !children.empty();
}

void TreeControl::insertItemSubItem( TreeItem* item, const uint32& index, TreeSubItem* subItem )
{

}

void TreeControl::removeItemSubItem( TreeItem* item, TreeSubItem* subItem )
{

}

bool TreeControl::getItemSubItems( TreeItem* item, std::vector<TreeSubItem*>& subItems )
{
	return !subItems.empty();
}

TreeSubItem* TreeControl::getItemSubItem( TreeItem* item, const uint32& index )
{
	TreeSubItem* result = NULL;

	return result;
}

uint32 TreeControl::getItemSubItemCount( TreeItem* item )
{
	return 0;
}

uint64 TreeControl::sizeOf() const
{
	uint64 result = sizeof(TreeControl);

	TreeControl* ptr = (TreeControl*)this;

	const TreeModel* tm = (const TreeModel*)ptr->getTreeModel();

	result += tm->sizeOf();


	std::map<TreeModel::Key,TreeItem*>::const_iterator it = itemMap_.begin();
	while ( it != itemMap_.end() ) {
		TreeItem* item = it->second;
			
		result += item->sizeOf();
		
		++it;
	}


	return result;
}

bool TreeControl::itemExists( const TreeModel::Key& key )
{
	return itemMap_.find( key ) != itemMap_.end();
}

void TreeControl::itemExpanded( TreeItem* item )
{
	
	if ( item->isExpanded() ) {
		TreeItem* parent = item->getParent();
		if ( parent != NULL ) {
			if ( !parent->isExpanded() ) {
				parent->expand( true );
			}
		}
	}

	ItemEvent e(item, TreeItem::tieExpanding);
	Point pt = UIShell::getUIShell()->getCurrentMousePosition();
	this->translateFromScreenCoords( &pt );
	e.point =pt;

	ItemExpanded( &e );
}

void TreeControl::itemSelected( TreeItem* item )
{
	if ( item->isSelected() ) {
		if ( NULL != currentSelectedItem_ ) {
			currentSelectedItem_->setSelected( false );
		}

		currentSelectedItem_ = item;			
	}	

	ItemEvent event( item, TREEITEM_SELECTED );
	Point pt = UIShell::getUIShell()->getCurrentMousePosition();
	this->translateFromScreenCoords( &pt );
	event.point = pt;
		
	ItemSelected( &event );
}


/**
$Id$
*/
