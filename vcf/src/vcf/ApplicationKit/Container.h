#ifndef _VCF_CONTAINER_H__
#define _VCF_CONTAINER_H__
//Container.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */





namespace VCF{

class Control;

class ControlEvent;

class MouseEvent;

class GraphicsContext;

class MouseHandler;

class Rect;


#define CONTAINER_CLASSID		"70ac023d-fb3f-44ee-9fc9-9b4dcebe472f"

/**
\class Container Container.h "vcf/ApplicationKit/Container.h"
A Container is a Component that is implemented when a Control
wants to be able to contain other child controls within itself.
A container can have child controls added or removed, and supports
searching all of it's child controls by name.
In addition a container has methods for enumerating all of it's children
and a method for explicitly resizing all of the children
*/
class APPLICATIONKIT_API Container : public Component {
public:
	Container(){};

	Container( Component* owner ): Component(owner){};

	virtual ~Container(){};

	/**
	*adds a child control to this container
	*@param Control the child control to add
	*Note: the child is added with the alignment
	*type that is already set on the child.
	*/
	virtual void add( Control * child ) = 0;

	/**
	*adds a child control using the specified
	*AlignmentType. The child's alignment also
	*will get set to this value.
	*@param Control* the control to add
	*@param AlignmentType the alignment type to add the child with
	*<table width="100%" cellpadding="2" cellspacing="0" border="1" bordercolor="#C0C0C0">
    *<tr>
    *<td width="20%" bgcolor="#C0C0C0" valign=TOP>
    *Value</td>
    *<td width="80%" bgcolor="#C0C0C0" valign=TOP>
    *Meaning</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *	<code>ALIGN_NONE</code></td>
    * <td width="80%" valign=TOP>
    *   The default value for a control's alignment. The control's top, left,
    *   width, and height are what determine it's position, regardless of
    *   surrounding controls.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_TOP</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the top of the parent container and resizes to
    *   fill in the width of the parent control. The height of the control is
    *   not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_BOTTOM</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the bottom of the parent container and resizes
    *   to fill in the width of the parent control. The height of the control
    *   is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_LEFT</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the left side of the parent container and
    *   resizes to fill in the height of the parent control. The width of the
    *   control is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_RIGHT</code></td>
    * <td width="80%" valign=TOP>
    *   The control moves to the right side of the parent container and
    *   resizes to fill in the height of the parent control. The width of the
    *   control is not altered during parent dimension changes.</td>
    *</tr>
    *<tr>
    * <td width="20%" valign=TOP>
    *   <code>ALIGN_CLIENT</code></td>
    * <td width="80%" valign=TOP>
    *   The control resizes to fill in the remaining client area of a form
    *   (after all other alignment positions of other controls are calculated).</td>
    *</tr>
	*</table>
	*/
	virtual void add( Control * child, const AlignmentType& alignment ) = 0;

	/**
	*inserts a child control into this container before the control specified in beforeControl.
	*If the child is already present then it's order in the container list is
	*modified accordingly. If the beforeControl control is not found in the list of
	*children then the child is added at the <b><i>beginning</i></b> of the list
	*/
	virtual void insertBeforeControl( Control * child, const AlignmentType& alignment, Control* beforeControl ) = 0;

	/**
	*inserts a child control into this container after the specified index.
	*If the child is already present then it's order in the container list is
	*modified accordingly. If the index specified is not within the container list's
	*bounds then the child is added at the <b><i>end</i></b> of the list
	*/
	virtual void insertAtIndex( Control * child, const AlignmentType& alignment, const uint32& index ) = 0;

	/**
	*Sends the specified child to the first position in containers list
	*/
	virtual void sendControlToFront( Control* child ) = 0;

	/**
	*Sends the specified child to the last position in containers list
	*/
	virtual void sendControlToBack( Control* child ) = 0;

	/**
	*removes the child control from the container - does <b><i>NOT</i></b>
	*delete the control
	*@param Control the control to remove from this container
	*/
	virtual void remove( Control* child ) = 0;

	/**
	removes \em all child controls
	*/
	virtual void clear() = 0;

	/**
	*returns an Enumerator of controls that represents all the
	*children in this container.
	*@return Enumerator<Control*> an enunerator of all the child controls
	*that this container has.
	*/
	virtual Enumerator<Control*>* getChildren() = 0;


	/**
	Paints all children of this container
	*/
	virtual void paintChildren( GraphicsContext* context ) = 0;

	/**
	*returns the numer of child controls that
	*this container has.
	*/
	virtual uint32 getChildCount() = 0;

	/**
	*searches through all the child controls of this
	*container. The first child control whose name
	*matches the name passed in is returned as a result
	*of the search. If the container ahs no children, or
	*none of the child controls have a name that matches
	*then NULL is returned.
	*@param String the name of the child control to find
	*@return Control the result of the search, NULL if nothing
	*nothing was found, otherwise a valid pointer to a child control
	*of this container.
	*/
	virtual Control* findControl( const String& controlName ) = 0;

	/**
	*resizes all the children, according to their alignment types
	*and anchor values. Usually called by the implementing container
	*control when it is resized.
	@param Control the child control that has changed and should be paid
	attention to. If the the parameter is NULL then the control that
	the container is attached to has changed.
	*/
	virtual void resizeChildren( Control* control ) = 0;

	virtual Control* getControlAtIndex( const uint32& index ) = 0;

	virtual int32 getControlIndex( Control* control ) = 0;

	virtual void updateTabOrder( Control* child, uint32& newTabOrder ) = 0;

	virtual void getTabList( std::vector<Control*>& tabList ) = 0;

	/**
	Sets the control that this container is attached to
	and responds to events from
	*/
	virtual void setContainerControl( Control* control ) = 0;

	virtual Control* getContainerControl() = 0;
};





/**
\class DelegatedContainer Container.h "vcf/ApplicationKit/Container.h"
This class is used to provide easy access to a containers methods 
so the developer doesn't have to get the container instance of the
control. See the Container class for documentation of the actual
methods.
@see Container
*/
template< typename ContainerType>
class DelegatedContainer {
public:

	DelegatedContainer(): delegate_(NULL) {
	}

	void paintChildren( GraphicsContext* context ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->paintChildren( context );
	}

	void add( Control * child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->add( child );
	}

	void add( Control * child, const AlignmentType& alignment ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->add( child, alignment );
	}

	void insertBeforeControl( Control * child, const AlignmentType& alignment, Control* beforeControl ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->insertBeforeControl( child, alignment, beforeControl );
	}

	void insertAtIndex( Control * child, const AlignmentType& alignment, const uint32& index ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->insertAtIndex( child, alignment, index );
	}

	void sendControlToFront( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->sendControlToFront( child );
	}

	void sendControlToBack( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->sendControlToBack( child );
	}

	void remove( Control* child ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->remove( child );
	}

	Enumerator<Control*>* getChildren() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getChildren();
	};

	uint32 getChildCount() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return 0;
		}
		return container->getChildCount();
	}

	Control* findControl( const String& controlName ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->findControl(controlName);
	}

	void resizeChildren( Control* control )  {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->resizeChildren( control );
	}

	Control* getControlAtIndex( const uint32& index ){
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getControlAtIndex(index);
	}

	int32 getControlIndex( Control* control ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return -1;
		}
		return container->getControlIndex(control);
	}

	void updateTabOrder( Control* child, uint32& newTabOrder ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->updateTabOrder(child,newTabOrder);
	}

	void getTabList( std::vector<Control*>& tabList ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->getTabList( tabList );
	}

	void setContainerControl( Control* control ) {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return;
		}
		container->setContainerControl(control);
	}

	Control* getContainerControl() {
		Container* container = delegate_->getContainer();
		if ( NULL == container ) {
			return NULL;
		}
		return container->getContainerControl();
	}

	void setContainerDelegate( ContainerType* delegate ) {
		delegate_ = delegate;
	}

	protected:
	ContainerType* delegate_;
};


};


#endif // _VCF_CONTAINER_H__

/**
$Id$
*/
