#ifndef _VCF_ITEM_H__
#define _VCF_ITEM_H__
//Item.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */



namespace VCF  {



class ItemListener;

class Image;

class Model;

class ItemEvent;

class Rect;

class Point;

class GraphicsContext;

class Control;

class Item;

/**
\class ItemSort ItemSort.h "vcf/ApplicationKit/ItemSort.h"
*/
class ItemSort {
public:
	virtual ~ItemSort(){};
	
	virtual bool compare( const Item* x, const Item* y) = 0;
};


/**
*these are a general set of enumeration masks that can be used
*to describe the items state above and beyond whether the item
*is selected
*/
enum ItemDisplayState{
	idsNone =			0x0000,
	idsChecked =		0x0005,
	idsUnChecked =		0x0006,
	idsRadioUnpressed = 0x0007,
	idsRadioPressed =	0x0008,
	idsCanPaint =		0x0010
};



#define ITEM_CLASSID		"ED88C0AA-26AB-11d4-B539-00C04F0196DA"

/**
\class Item Item.h "vcf/ApplicationKit/Item.h"
The Item class can be used represent a single element in a model.
It's useful because as a component it gets all the automatic 
persistance abilities of a component and the ability
to easily edit it at design time through a visual form
editor (like the VCF Builder). 

The Item class has a number of virtual methods that must be implemented,
but the exact methods of implementation may vary widely. For example
it possible that in order to calculate the item's index hte item
may simply carry around a member variable that stores the index. 
An alternate approach would be to query the model the item
is attached to and ask the model for the item's index position.
*/
class APPLICATIONKIT_API Item : public UIComponent {
public:
	

	Item():data_(NULL),selected_(false),imageIndex_(-1),
			displayState_(idsNone),model_(NULL),owningControl_(NULL),font_(NULL),keyVal_(NULL) {			
		tag_ = -1;
	};

	virtual ~Item(){
		delete font_;
	};
	
	

	/**
	This is called to determine if a given point is within the
	bounds of the item. The bounds may be slightly different
	than what is returned by getBounds(). For example, an item
	may not support getBounds(), but may have a non-rectangular
	region and may implement containsPoint() accordingly.
	*/
    virtual bool containsPoint( Point * pt ) const {
		return bounds_.containsPt( pt );
	}

	/**
	returns the Bounds for the Item or NULL if not
	applicable.
	*/
	virtual Rect getBounds() {
		return bounds_;
	}

	virtual void setBounds( const Rect& bounds ) {
		bounds_ = bounds;
	}

	/**
	This image index represents the state of an particular item
	separate from whether or not it is selected. Typically it
	is offset horizontally from the regular image that getImageIndex()
	represents. This image is frequently used to represent check marks
	for things like tree or list controls.
	*/
	virtual int32 getStateImageIndex() const {
		return -1;
	}

	virtual void setStateImageIndex( const int32& index ) {
		stateChanged();
	}

	virtual int32 getImageIndex() const {
		return imageIndex_;
	}

	virtual void setImageIndex( const int32& imageIndex ) {
		imageIndex_ = imageIndex;
	}

	
		

	/**
	Returns some application defined data. This can be anything 
	you want, hence the void* storage.
	*/
    void* getData() const {
		return data_;
	}

	/**
	Sets the application defined data.
	*/
	void setData( void* data ) {
		data_ = data;
	}

	/**
	*indicates whether the item can paint itself.
	*In general this is often false, but when true,
	*the control that contains the item should
	*call the item's paint() method whenever the item
	*needs repainting.
	*/
	virtual bool canPaint() const {
		return false;
	}

	virtual void paint( GraphicsContext* context, Rect* paintRect ) {}

	bool isSelected() const {
		return selected_;
	}

	virtual void setSelected( const bool& selected ) {
		selected_ = selected;
	}

	/**
	Represents the current state of the item
	that is entirely item specific as well as 
	specific to the control that is hosting 
	the item(s). Some controls will completely 
	ignore this value.
	*/
	uint32 getDisplayState() const {
		return displayState_;
	}

	/**
	Sets the state for the item. This is made virtual to
	allow subclasses to customize the behaviour. 
	*/
	virtual void setDisplayState( const uint32& state ){
		displayState_ = state;
		stateChanged();
	}

	void setChecked( const bool& val ) {
		if ( val ) {
			if ( (displayState_ & idsUnChecked) == idsUnChecked ) {
				displayState_ &= ~idsUnChecked;
			}
			displayState_ |= idsChecked;
			stateChanged();
		}
		else {
			if ( (displayState_ & idsChecked) == idsChecked ) {
				displayState_ &= ~idsChecked;
			}
			displayState_ |= idsUnChecked;
			stateChanged();
		}
	}

	bool isChecked() const {
		return (displayState_ & idsChecked) == idsChecked;
	}

	bool isUnchecked() const {
		return (displayState_ & idsUnChecked) == idsUnChecked;
	}

	void setRadioPressed( const bool& val ) {
		if ( val ) {
			displayState_ |= idsRadioPressed;
			displayState_ &= ~idsRadioUnpressed;
			stateChanged();
		}
		else {
			displayState_ &= ~idsRadioPressed;
			displayState_ |= idsRadioUnpressed;
			stateChanged();
		}		
	}

	bool isRadioPressed() const {
		return (displayState_ & idsRadioPressed) == idsRadioPressed;
	}

	bool isRadioUnpressed() const {
		return (displayState_ & idsRadioUnpressed) == idsRadioUnpressed;
	}

	



	/**
	Returns the model that this item belongs to.
	*/
	Model* getModel() const {
		return model_;
	}

	/**
	Sets the model that this item is a part of. 
	Subclasses may need or want to customize this.
	*/
	virtual void setModel( Model* model ) {
		model_ = model;
	}

	/**
	All items may have a control that "owns" them.
	so in a ListControl, the ListItem::getControl() would
	return the ListControl the items were part of. 
	The control for item \em must match with the
	view control of the item's model.
	*/
	Control* getControl() const {
		return owningControl_;
	}

	/**
	Sets the owning control for this item. It's made
	virtual so that subclasses can override the behaviour
	if they need to.
	*/
	virtual void setControl( Control* control ) {
		owningControl_ = control;
	}


	Font* getFont();

	/**
	Indicates that the default font for this item should be used. It's 
	also an indicator that the font is NULL and no attempts at modifications
	have been attempted.
	*/
	bool isFontDefault();

	void setFont( Font* val );


	VariantData getKeyValue() const {
		if ( NULL == keyVal_ ) {
			return VariantData::null();
		}

		return *keyVal_;
	}

	void setKeyValue( const VariantData& val ) {
		
		if ( NULL == keyVal_ && !val.isNull() ) {
			keyVal_ = new VariantData();
		}

		if ( *keyVal_ != val ) {
			*keyVal_ = val;
		}
	}
protected:
	void* data_;	
	Rect bounds_;	
	bool selected_;
	int32 imageIndex_;
	Font* font_;

	uint32 displayState_;
	Model* model_;
	Control* owningControl_;
	VariantData* keyVal_;

	void stateChanged() {
		if ( NULL != owningControl_ ) {
			ItemEvent e(this,ItemEvent::StateChanged);
			Component* c = (Component*)owningControl_;
			c->handleEvent( &e );
		}
	}
};



inline Font* Item::getFont()
{
	if ( NULL == font_ ) {
		font_ = new Font();
	}
	return font_;
}

inline bool Item::isFontDefault()
{
	return (NULL == font_) ? true : false;
}

inline void Item::setFont( Font* val )
{
	Font* f = getFont();
	*f = *val;
}


};


#endif // _VCF_ITEM_H__

/**
$Id$
*/
