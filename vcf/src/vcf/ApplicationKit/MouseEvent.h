#ifndef _VCF_MOUSEEVENT_H__
#define _VCF_MOUSEEVENT_H__
//MouseEvent.h

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


#if _MSC_VER > 1000
#   pragma once
#endif


/* Generated by Together */




namespace VCF{




/**
Mouse button masks
*/
enum MouseButtomMasks{
	mbmUndefined = 0,
	mbmLeftButton = 1,
	mbmMiddleButton = 2,
	mbmRightButton = 4,
	mbmPrimaryButton = mbmLeftButton,
	mbmSecondaryButton = mbmRightButton,
	mbmTertiaryButton = mbmMiddleButton
};




/**
\class MouseEvent MouseEvent.h "vcf/ApplicationKit/MouseEvent.h"
*/
class APPLICATIONKIT_API MouseEvent : public Event {
public:
	MouseEvent( Object* source ) : Event(source),
		buttonMask_(0), keyMask_(0), mouseDelta_(0){}

	MouseEvent( Object* source, const uint32& eventType ): Event(source,eventType),
		buttonMask_(0),keyMask_(0){}

	MouseEvent( Object* source, const uint32& eventType, const uint32& buttonMask,
		        const uint32& keyMask, Point* point ): Event(source,eventType),
		buttonMask_(buttonMask),keyMask_(keyMask),point_(*point){}

	MouseEvent( const MouseEvent& rhs ):Event(rhs),
		buttonMask_(0),keyMask_(0) {
		*this = rhs;
	}

	virtual ~MouseEvent(){};


	MouseEvent& operator=( const MouseEvent& rhs ) {
		Event::operator =( rhs );
		buttonMask_ = rhs.buttonMask_;
		keyMask_ = rhs.keyMask_;
		point_ = rhs.point_;
		return *this;
	}

	virtual Object* clone( bool deep=false ) {
		return new MouseEvent(*this);
	}

	/**
	*returns the point for this mouse event
	*/
    Point* getPoint(){
		return &point_;
	}

	void setPoint( Point* point ){
		point_.x_ = point->x_;
		point_.y_ = point->y_;
	}

    uint32 getKeyMask(){
		return keyMask_;
	}

    uint32 getButtonMask(){
		return buttonMask_;
	}
	
	/**
	indicates whether the mouse event has occurred while the 
	user has the left button down. 
	@see hasPrimaryButton()
	*/
	bool hasLeftButton(){
		return ( mbmLeftButton & buttonMask_ ) != 0;
	}

	/**
	indicates whether the mouse event has occurred while the 
	user has the middle button down. 
	@see hasTertiaryButton()
	*/
	bool hasMiddleButton(){
		return ( mbmMiddleButton & buttonMask_ ) != 0;
	}

	/**
	indicates whether the mouse event has occurred while the 
	user has the right button down. 
	@see hasSecondaryButton()
	*/
	bool hasRightButton(){
		return ( mbmRightButton & buttonMask_ ) != 0;
	}

	/**
	A more general call to determine which button is pressed
	down. This is the preferred call to make as it does
	not indicate a preference for a right-hand configured
	mouse.

	Indicates whether the mouse event has occurred while the 
	user has the primary button down. The primary button,
	on a mouse configured for right-handed users, is the 
	left button. For a mouse configured for left-handed 
	users it would be the right button.
	*/	
	bool hasPrimaryButton(){
		return ( mbmPrimaryButton & buttonMask_ ) != 0;
	}

	/**
	A more general call to determine which button is pressed
	down. This is the preferred call to make as it does
	not indicate a preference for a right-hand configured
	mouse.

	Indicates whether the mouse event has occurred while the 
	user has the secondary button down. The secondary button,
	on a mouse configured for right-handed users, is the 
	right button. For a mouse configured for left-handed 
	users it would be the left button.
	*/	
	bool hasSecondaryButton(){
		return ( mbmSecondaryButton & buttonMask_ ) != 0;
	}

	/**
	A more general call to determine which button is pressed
	down. This is the preferred call to make as it does
	not indicate a preference for a right-hand configured
	mouse.

	Indicates whether the mouse event has occurred while the 
	user has the tertiary button down. The tertiary button,
	on a mouse configured for right-handed or left-handed
	users, is the middle button.
	*/	
	bool hasTertiaryButton(){
		return ( mbmTertiaryButton & buttonMask_ ) != 0;
	}

	/**
	Use this function to fetch the the distance the wheel is rotated, expressed in multiples or 
	divisions of WHEEL_DELTA, which is 120. A positive value indicates that the wheel was rotated forward, 
	away from the user; a negative value indicates that the wheel was rotated backward, toward the user.
	*/
	short getMouseDelta()
	{
		return ( mouseDelta_ );
	}


	void setMouseDelta( short value )
	{
		mouseDelta_ = value;
	}

	bool hasShiftKey(){
		return ( kmShift & keyMask_ ) != 0;
	}
	
	bool hasAltKey(){
		return ( kmAlt & keyMask_ ) != 0;
	}
	
	bool hasControlKey(){
		return ( kmCtrl & keyMask_ ) != 0;
	}

private:
    uint32 buttonMask_;
    uint32 keyMask_;
    Point point_;
	short mouseDelta_;
};







/**
MouseDelegate
handles the following
\li onMouseDoubleClicked
\li onMouseClicked
\li onMouseMove
\li onMouseUp
\li onMouseDown
*/
typedef Delegate1<MouseEvent*> MouseDelegate; 
typedef MouseDelegate::ProcedureType MouseHandler;


};


#endif // _VCF_MOUSEEVENT_H__

/**
$Id$
*/
