//ListBoxControl.cpp

/*
Copyright 2000-2004 The VCF Project.
Please see License.txt in the top level directory
where you installed the VCF.
*/


/* Generated by Together */

#include "vcf/ApplicationKit/ApplicationKit.h"
#include "vcf/ApplicationKit/ListBoxControl.h"
#include "vcf/ApplicationKit/DefaultListModel.h"

using namespace VCF;


static ListItem* previouslySelectedListItem = NULL;


ListBoxControl::ListBoxControl():
	listModel_(NULL),
	currentMaxWidth_(0),
	currentMaxHeight_(0),
	leftGutter_(2),
	rightGutter_(2),
	textBounded_(false)
{
	setListModel( new DefaultListModel() );

	init();
}


ListBoxControl::ListBoxControl( ListModel* listModel ):
	listModel_(NULL),
	currentMaxWidth_(0),
	currentMaxHeight_(0),
	leftGutter_(2),
	rightGutter_(2),
	textBounded_(false)
{
	setListModel( listModel );
	init();
}

void ListBoxControl::init()
{
	singleSelectedItem_ = NULL;

	allowsMultiSelect_ = false;

	allowsExtendedSelect_ = true;

	setColor( GraphicsToolkit::getSystemColor( SYSCOLOR_WINDOW ) );

	defaultItemHeight_ = getContext()->getTextHeight( "EM" ) + 4;

	EventHandler* lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onItemAdded, "ListBoxControl::onItemAdded" );

	listModel_->addItemAddedHandler( lmh );

	lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onItemDeleted, "ListBoxControl::onItemDeleted" );

	listModel_->addItemDeletedHandler( lmh );

	lmh =
		new ListModelEventHandler<ListBoxControl>( this, &ListBoxControl::onListModelContentsChanged, "ListBoxControl::onListModelContentsChanged" );

	listModel_->addContentsChangedHandler( lmh );

	selectedItemsContainer_.initContainer( selectedItems_ );

	setUseColorForBackground( true );
}

ListBoxControl::~ListBoxControl()
{
	if ( NULL != listModel_ ) {
		EventHandler* ev = getEventHandler( "ListBoxControl::onItemAdded" );
		if ( NULL != ev ) {
			listModel_->removeItemAddedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onItemDeleted" );
		if ( NULL != ev ) {
			listModel_->removeItemDeletedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onListModelContentsChanged" );
		if ( NULL != ev ) {
			listModel_->removeContentsChangedHandler( ev );
		}
		listModel_->release();
	}
}

ListModel* ListBoxControl::getListModel()
{
	return listModel_;
}

void ListBoxControl::setListModel( ListModel * model )
{
	if ( NULL != listModel_ ) {
		EventHandler* ev = getEventHandler( "ListBoxControl::onItemAdded" );
		if ( NULL != ev ) {
			listModel_->removeItemAddedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onItemDeleted" );
		if ( NULL != ev ) {
			listModel_->removeItemDeletedHandler( ev );
		}

		ev = getEventHandler( "ListBoxControl::onListModelContentsChanged" );
		if ( NULL != ev ) {
			listModel_->removeContentsChangedHandler( ev );
		}

		listModel_->release();
	}

	listModel_ = model;


	if ( NULL != listModel_ ) {
		listModel_->addRef();
	}

	setViewModel( listModel_ );

	repaint();
}

void ListBoxControl::onListModelContentsChanged( ListModelEvent* event )
{
	repaint();



	if ( NULL != event ){
		switch ( event->getType() ){
			case LIST_MODEL_CONTENTS_DELETED: {
				singleSelectedItem_ = NULL;
				selectedItems_.clear();
			}
			break;
/*
			case LIST_MODEL_ITEM_CHANGED: {
				ListItem* item = event->getListItem();
				if ( NULL != item ){
					listBoxPeer_->removeItem( item );
					listBoxPeer_->addItem( item );
				}
			}
			break;
			*/
		}

	}
}

void ListBoxControl::onItemAdded( ListModelEvent* event )
{

	//listBoxPeer_->addItem( event->getListItem() );
	Scrollable* scrollable = getScrollable();
	ListModel* lm = getListModel();


	double width = getWidth();

	Rect itemRect;

	double scrollW = 0;

	if ( NULL != scrollable ) {
		if ( scrollable->getVirtualViewHeight() > getHeight() ) {
			scrollW = scrollable->getVerticalScrollbarWidth();
		}
	}


	GraphicsContext* ctx = getContext();

	ListItem* item = event->getListItem();

	itemRect.setRect( 0, currentMaxHeight_, width-scrollW, currentMaxHeight_ + defaultItemHeight_ );
	item->setBounds( &itemRect );

	currentMaxHeight_ += item->getBounds()->getHeight();


	currentMaxWidth_ = maxVal<double>( ctx->getTextWidth( item->getCaption() ) + leftGutter_ + rightGutter_, currentMaxWidth_ ); 


	if ( NULL != scrollable ) {
		if ( (getHeight() > currentMaxHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}

		if ( (getWidth() > currentMaxWidth_) && (scrollable->getHorizontalPosition() > 0.0) ) {
			scrollable->setHorizontalPosition( 0.0 );
		}

		double realMaxWidth = currentMaxWidth_;
		double realMaxHeight = currentMaxHeight_;
		if ( (currentMaxHeight_ > getHeight())  ) {
			realMaxWidth += scrollable->getVerticalScrollbarWidth();
		}

		if ( currentMaxWidth_ > getWidth() ) {
			realMaxHeight += scrollable->getHorizontalScrollbarHeight();
		}

		scrollable->setVirtualViewHeight( realMaxHeight );
		scrollable->setVirtualViewWidth( realMaxWidth );
	}
	repaint();
}

void ListBoxControl::onItemDeleted( ListModelEvent* event )
{
	ListItem* item = event->getListItem();

	if ( item == singleSelectedItem_ ) {
		singleSelectedItem_ = NULL;
	}

	currentMaxHeight_ -= item->getBounds()->getHeight();

	Scrollable* scrollable = getScrollable();

	if ( NULL != scrollable ) {
		if ( (getHeight() > currentMaxHeight_) && (scrollable->getVerticalPosition() > 0.0) ) {
			scrollable->setVerticalPosition( 0.0 );
		}

		if ( (getWidth() > currentMaxWidth_) && (scrollable->getHorizontalPosition() > 0.0) ) {
			scrollable->setHorizontalPosition( 0.0 );
		}

		double realMaxWidth = currentMaxWidth_;
		double realMaxHeight = currentMaxHeight_;
		if ( (currentMaxHeight_ > getHeight())  ) {
			realMaxWidth += scrollable->getVerticalScrollbarWidth();
		}

		if ( currentMaxWidth_ > getWidth() ) {
			realMaxHeight += scrollable->getHorizontalScrollbarHeight();
		}

		scrollable->setVirtualViewHeight( realMaxHeight );
		scrollable->setVirtualViewWidth( realMaxWidth );
	}

	repaint();
}

void ListBoxControl::rangeSelect( const bool & isSelected, ListItem * first, ListItem * last )
{
	if ( NULL == last ) {
		setSelectedItem( first ); //this will select it
		if ( false == isSelected ) { // we'll deselect it
			first->setSelected( isSelected );
			singleSelectedItem_ = NULL;
		}
		repaint();
	}
	else {
		if ( NULL != singleSelectedItem_ ) {
			singleSelectedItem_->setSelected( false );
		}
		singleSelectedItem_ = NULL;

		selectedItems_.clear();

		ListModel* lm = getListModel();
		if ( NULL != lm ) {
			ulong32 start = first->getIndex();
			ulong32 end = last->getIndex();
			for ( ulong32 i=start;i<=end;i++) {
				ListItem* item = lm->getItemFromIndex( i );
				if ( NULL != item ) {
					item->setSelected( isSelected );
					if ( true == isSelected ) {
						selectedItems_.push_back( item );
					}
				}
			}

			selectionChanged( NULL );
		}
	}
}

void ListBoxControl::paint( GraphicsContext* ctx )
{
	CustomControl::paint( ctx );
	ListModel* lm = getListModel();

	Scrollable* scrollable = this->getScrollable();

	Rect bounds = getClientBounds();
	//ctx->setClippingRect( &bounds );

	double width = bounds.getWidth();
	double scrollW = 0;
	double offsetx = bounds.left_ + leftGutter_;
	if ( NULL != scrollable ) {
		if ( scrollable->getVirtualViewHeight() > getHeight() ) {
			scrollW = scrollable->getVerticalScrollbarWidth();
		}

		offsetx = maxVal<>( offsetx, offsetx + scrollable->getHorizontalPosition() );
	}

	if ( NULL != lm ) {
		Color* selectedTextColor =
				GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION_TEXT );

		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = bounds.top_;
		Rect itemRect;
		Rect itemPaintRect;
		double totalHeight = 0;


		Color oldFontColor;
			oldFontColor = *getFont()->getColor();



		Rect viewBounds = ctx->getViewableBounds();
		//Point origin = ctx->getOrigin();
		//viewBounds.offset( -origin.x_, -origin.y_ );

		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( offsetx, currentTop, offsetx + (width-scrollW), currentTop + defaultItemHeight_ );

			if ( ((itemRect.top_ <= viewBounds.bottom_ ) && (itemRect.bottom_ >= viewBounds.top_ )) ||
					(itemRect.containsPt( &viewBounds.getTopLeft()) || (itemRect.containsPt( &viewBounds.getBottomRight() )) ) ) {
				totalHeight += itemRect.getHeight();

				double y = currentTop + ( (itemRect.getHeight()/2.0) - (ctx->getTextHeight( "EM" )/2.0) );

				if ( true == item->isSelected() ) {
					paintSelectionRect( ctx, &Rect(itemRect.left_-leftGutter_, itemRect.top_, itemRect.right_, itemRect.bottom_), item );
					ctx->getCurrentFont()->setColor( selectedTextColor );
					//ctx->setColor( selectedTextColor );
				}
				else {
					ctx->getCurrentFont()->setColor( &oldFontColor );
					//ctx->setColor( &oldFontColor );
				}
				

				String itemText = item->getCaption();
				if ( getUseLocaleStrings() ) {
					itemText = System::getCurrentThreadLocale()->translate( itemText );
				}

				if( textBounded_ ){
					itemPaintRect.setRect(bounds.left_ + leftGutter_, currentTop, offsetx + width - scrollW - leftGutter_, currentTop + defaultItemHeight_ );
					ctx->textBoundedBy( &itemPaintRect, itemText, false );
				}
				else{
					ctx->textAt( bounds.left_ + leftGutter_, y, itemText );
				}
				
				if ( true == item->canPaint() ) {
					item->paint( ctx, &itemRect );
				}
			}

			currentTop += itemRect.getHeight();
		}
	}
}

void ListBoxControl::paintSelectionRect( GraphicsContext* ctx, Rect* rect, ListItem* item )
{
	Color* selectedColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION );
	Color* selectedTextColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SELECTION_TEXT );
	Color* greyColor = GraphicsToolkit::getSystemColor( SYSCOLOR_SHADOW );
	ctx->setColor( selectedColor );
	ctx->rectangle( rect );
	ctx->fillPath();
	ctx->setColor( greyColor );
	ctx->strokePath();
	ctx->setColor( selectedTextColor );
}

ListItem* ListBoxControl::findSingleSelectedItem( Point* pt )
{
	ListItem* result = NULL;

	Point tmpPt = *pt;
	tmpPt.x_ = 1;

	ListModel* lm = getListModel();
	if ( NULL != lm ) {
		Enumerator<ListItem*>* items= lm->getItems();
		double currentTop = 0.0;
		Rect itemRect;
		while ( true == items->hasMoreElements() ) {
			ListItem* item = items->nextElement();
			itemRect.setRect( 0, currentTop, getWidth(), currentTop + defaultItemHeight_ );
			if ( true == itemRect.containsPt( &tmpPt ) ) {
				result = item;
				break;
			}
			currentTop += itemRect.getHeight();
		}
	}

	return result;
}

void ListBoxControl::mouseDown( MouseEvent* event )
{
	CustomControl::mouseDown( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		keepMouseEvents();

		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {			
			if ( true == allowsMultiSelect_ && true == allowsExtendedSelect_ ) {
				if( event->hasShiftKey() ){
					if( foundItem == singleSelectedItem_ ){
						for( ulong32 j=0;j<selectedItems_.size();j++ ){
							selectedItems_[j]->setSelected(false);
						}
						selectedItems_.clear();
						selectedItems_.push_back(foundItem);
						foundItem->setSelected(true);
						selectionChanged( foundItem );
					}
					else if( NULL != singleSelectedItem_ ){
						ulong32 foundItemPos = foundItem->getIndex();
						ulong32 singlePos = singleSelectedItem_->getIndex();
						for( ulong32 j=0;j<selectedItems_.size();j++ ){
							selectedItems_[j]->setSelected(false);
						}
						if(foundItemPos < singlePos){// rangeSelect clears selectedItems_
							rangeSelect(true, foundItem, singleSelectedItem_ );
						}
						else{
							rangeSelect(true, singleSelectedItem_, foundItem );
						}
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
					else{// needed if no items currently selected.
						foundItem->setSelected(true);
						selectedItems_.push_back(foundItem);
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
				}
				else if( event->hasControlKey() ){
					if( foundItem->isSelected() ){
						foundItem->setSelected(false);
						singleSelectedItem_ = NULL;
						eraseFromSelectedItems( foundItem );
						selectionChanged( foundItem );
					}
					else{
						foundItem->setSelected(true);
						selectedItems_.push_back(foundItem);
						singleSelectedItem_ = foundItem;
						selectionChanged( foundItem );
					}
				}
				else{
					for( ulong32 j=0;j<selectedItems_.size();j++ ){
						selectedItems_[j]->setSelected(false);
					}
					selectedItems_.clear();
					selectedItems_.push_back(foundItem);
					foundItem->setSelected( true );
					singleSelectedItem_ = foundItem;
					selectionChanged( foundItem );
				}
			}
			else if ( true == allowsMultiSelect_ && false == allowsExtendedSelect_ ){
				if( foundItem->isSelected() ){
					foundItem->setSelected(false);
					singleSelectedItem_ = NULL;
					eraseFromSelectedItems( foundItem );
					selectionChanged( foundItem );
				}
				else{
					foundItem->setSelected( true );
					singleSelectedItem_ = foundItem;
					selectedItems_.push_back( foundItem );
					selectionChanged( foundItem );
				}
			}
			else {
				selectedItems_.clear();
				selectedItems_.push_back( foundItem );
				setSelectedItem( foundItem );
			}
		}
	}
}

void ListBoxControl::mouseMove( MouseEvent* event )
{
	CustomControl::mouseMove( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		ListItem* foundItem = findSingleSelectedItem( event->getPoint() );
		if ( NULL != foundItem ) {
			if ( true == allowsMultiSelect_ ) {
				if ( true == foundItem->isSelected() ){
					singleSelectedItem_ = foundItem; 
				}
				else {
					selectedItems_.push_back( foundItem );
					setSelectedItem( foundItem );
				}
			}
			else {
				if ( foundItem != singleSelectedItem_ ) {
					selectedItems_[0] = foundItem;//assumes index 0 exists
					setSelectedItem( foundItem );
				}
			}
		}
	}
}

void ListBoxControl::mouseUp( MouseEvent* event )
{
	CustomControl::mouseUp( event );
	if ( (true == event->hasLeftButton()) && (Component::csNormal == getComponentState()) ) {
		releaseMouseEvents();
	}
}

void ListBoxControl::mouseClick( MouseEvent* event )
{
	CustomControl::mouseClick( event );
}

void ListBoxControl::mouseDblClick( MouseEvent* event )
{
	CustomControl::mouseDblClick( event );
}

void ListBoxControl::keyDown( KeyboardEvent* event )
{
	CustomControl::keyDown( event );

	if ( Component::csNormal == getComponentState() ) {
		if ( true == this->allowsMultiSelect_ ) {

		}
		else {
			ListItem* item = this->getSelectedItem();
			ListModel* lm = getListModel();
			if ( (NULL != item) && (NULL != lm) ) {
				ulong32 index = item->getIndex();

				if ( vkUpArrow == event->getVirtualCode() ) {
					index --;

				}
				else if ( vkDownArrow == event->getVirtualCode() ) {
					index ++;
				}
				item = lm->getItemFromIndex( index );
				if ( NULL != item ) {
					setSelectedItem( item );
				}
			}
		}
	}
}

void ListBoxControl::keyUp( KeyboardEvent* event )
{
	CustomControl::keyUp( event );
}

void ListBoxControl::keyPressed( KeyboardEvent* event )
{
	CustomControl::keyPressed( event );
}

void ListBoxControl::setDefaultItemHeight( const double& defaultItemHeight )
{
	defaultItemHeight_ = defaultItemHeight;
	repaint();
}

Enumerator<ListItem*>* ListBoxControl::getSelectedItems()
{
	return selectedItemsContainer_.getEnumerator();
}

void ListBoxControl::setAllowsMultiSelect( const bool& allowsMultiSelect )
{
	allowsMultiSelect_ = allowsMultiSelect;
}

void ListBoxControl::selectionChanged( ListItem* item )
{
	ItemEvent event( item, ITEM_EVENT_SELECTED );
	SelectionChanged.fireEvent( &event );
}

void ListBoxControl::setSelectedItem( ListItem* selectedItem )
{
	if ( NULL != singleSelectedItem_ && true != allowsMultiSelect_ ) {
		singleSelectedItem_->setSelected( false );
	}
	singleSelectedItem_ = selectedItem;
	if ( NULL != singleSelectedItem_ ) {
		singleSelectedItem_->setSelected( true );

		selectionChanged( singleSelectedItem_ );
	}

	repaint();
}

void ListBoxControl::deselectAllItems()
{
	for( ulong32 j=0;j<selectedItems_.size();j++ ){
		selectedItems_[j]->setSelected(false);
	}

	selectedItems_.clear();

	repaint();
}

void ListBoxControl::eraseFromSelectedItems(ListItem* item)
{
	std::vector<ListItem*>::iterator foundItemPos;
	foundItemPos = std::find( selectedItems_.begin(), selectedItems_.end(), item );
	
	if(foundItemPos != selectedItems_.end() ) selectedItems_.erase( foundItemPos );
}

void ListBoxControl::setAllowsExtendedSelect (const bool& allowsExtendedSelect)
{
	if ( true == allowsExtendedSelect ) {
		allowsMultiSelect_ = true;
	}

	allowsExtendedSelect_ = allowsExtendedSelect;
}

void ListBoxControl::setLeftGutter(const double& leftgutter)
{
	leftGutter_ = leftgutter;
	repaint();
}

void ListBoxControl::setRightGutter(const double& rightgutter)
{
	rightGutter_ = rightgutter;
	repaint();
}

void ListBoxControl::setTextBounded( const bool& istextbounded ){
	textBounded_ = istextbounded;
}


/**
*CVS Log info
*$Log$
*Revision 1.3  2004/08/19 02:24:54  ddiego
*fixed bug [ 1007039 ] lightweight controls do not paint correctly.
*
*Revision 1.2  2004/08/07 02:49:08  ddiego
*merged in the devmain-0-6-5 branch to stable
*
*Revision 1.1.2.5  2004/07/16 04:01:45  ddiego
*fixed the last of border redraw issues, I hope.
*
*Revision 1.1.2.4  2004/07/09 03:39:29  ddiego
*merged in changes from the OSX branch for new theming API. Added
*support for controlling the use of locale translated strings in components.
*
*Revision 1.1.2.3  2004/07/08 19:41:48  dougtinkham
*implemented multi-selection and extended-selection, modified mouseDown, mouseMove, and paint. Text in list box can be painted using textBoundedBy or textAt, set by making a call to setTextBounded(const bool&). Added double leftGutter_ and double rightGutter_, which control the distance between text left and right edge of borders, respectively.
*
*Revision 1.1.2.2  2004/04/29 03:43:14  marcelloptr
*reformatting of source files: macros and csvlog and copyright sections
*
*Revision 1.1.2.1  2004/04/28 00:28:18  ddiego
*migration towards new directory structure
*
*Revision 1.18  2004/01/20 01:54:56  ddiego
*merged some more changes from dev branch, primarily changes to
*teh RTTI API so that we now process enum sets correctly (i.e. a long
*that is a mask made of enum values).
*
*Revision 1.17.2.1  2004/01/16 04:30:47  ddiego
*some more minor mods to menus and the Component class. Added some utility
*methods for determining the state of a component, and added two new
*delegates for firing events when the component is loaded and saved,
*as well as value changes for the COmponentState enum so that some of
*the values of the component state can be OR'd together.
*
*Revision 1.17  2003/12/18 05:16:00  ddiego
*merge from devmain-0-6-2 branch into the stable branch
*
*Revision 1.16.2.7  2003/11/10 01:57:43  ddiego
*add a fromString methods to StingUtils
*added some minor fixes to list box control and added a SelectionChanged
*Delegate to it
*add some minor fixes ot ComboBoxControl
*added an unknownColor() method to ColorNames class
*
*Revision 1.16.2.6  2003/10/31 05:06:38  ddiego
*added toolbar impl
*
*Revision 1.16.2.5  2003/10/30 20:03:33  ddiego
*fixed display bug - shouldn't have been adjusting the viewable bounds
*also fixed the display rect for a given item to properly take into
*account any scroll bars
*
*Revision 1.16.2.4  2003/09/22 01:48:04  ddiego
*some minor additions ot teh DropTarget to allow it to have multiple
*control targets
*also a few other misc fixes
*
*Revision 1.16.2.3  2003/09/08 05:23:21  ddiego
*additions to scrolling to determine the correct width/height of scroll
*bars
*fixed problem in text model with inserting text
*optimized ListBoxControl, performs much much better now
*
*Revision 1.16.2.2  2003/08/26 21:41:17  ddiego
*miscellanesous stuff, minor bugs
*
*Revision 1.16.2.1  2003/08/22 01:32:20  ddiego
*fixed failure to release model in destructor
*
*Revision 1.16  2003/08/09 02:56:45  ddiego
*merge over from the devmain-0-6-1 branch
*Changes
*Features:
*-Added additional implementation to better support the MVC architecture in
*the VCF
*
*-Added a Document/View architecure that is similar to MFC's or NextSteps's
*Doc/View architectures
*
*-Integrated the Anti Grain Graphics library into the GraphicsKit. There is
*now basic support for it in terms of drawing vector shapes
*(fills and strokes). Image support will come in the next release
*
*-Added several documented graphics tutorials
*
*Bugfixes:
*
*[ 775744 ] wrong buttons on a dialog
*[ 585239 ] Painting weirdness in a modal dialog ?
*[ 585238 ] Modal dialog which makes a modal Dialog
*[ 509004 ] Opening a modal Dialog causes flicker
*[ 524878 ] onDropped not called for MLTcontrol
*
*Plus an issue with some focus and getting the right popup window to activate
*has also been fixed
*
*Revision 1.15.2.3  2003/07/24 04:10:44  ddiego
*added fixes for the following tasks:
*Task #82279 ApplicationKit: add static methods to singleton objects
*Task #82277 FoundationKit: add static methods to singleton objects
*this required a bunch of changes in terms of getting rid of older style code
*
*Revision 1.15.2.2  2003/07/10 04:55:16  ddiego
*added more stuff to GTK port - fixed some issues with events, and
*added support for posting events, and the stubs for a ButtonPeer
*
*Revision 1.15.2.1  2003/07/09 03:53:18  ddiego
*some fixes to gtk port
*
*Revision 1.15  2003/05/17 20:37:49  ddiego
*this is the checkin for the 0.6.1 release - represents the merge over from
*the devmain-0-6-0 branch plus a few minor bug fixes
*
*Revision 1.14.2.3  2003/05/14 03:04:30  ddiego
*fixed some bugs caused by some of the changes in the graphics kit that I made
*yesterday. All is well now.
*
*Revision 1.14.2.2  2003/03/23 03:24:00  marcelloptr
*3 empty lines at the end of the files
*
*Revision 1.14.2.1  2003/03/12 03:13:14  ddiego
*switched all member variable that used the "m_"<name> prefix to
* <name>"_" suffix nameing standard.
*Also changed all vcf builder files to accomadate this.
*Changes were made to the Stream classes to NOT multiple inheritance and to
*be a little more correct. Changes include breaking the FileStream into two
*distinct classes, one for input and one for output.
*
*Revision 1.14  2003/02/26 04:30:56  ddiego
*merge of code in the devmain-0-5-9 branch into the current tree.
*most additions are in the area of the current linux port, but the major
*addition to this release is the addition of a Condition class (currently
*still under development) and the change over to using the Delegate class
*exclusively from the older event handler macros.
*
*Revision 1.13.2.3  2003/01/08 00:20:00  marcelloptr
*mispellings and newlines at the end of all source files
*
*Revision 1.13.2.2  2002/12/27 23:05:06  marcelloptr
*Improved macros for automatic import/export of libraries. - Warning fixes. - Other Minor Changes.
*
*Revision 1.13.2.1  2002/12/25 22:06:35  ddiego
*whole bunch of little changes to the header files used by the ApplicationKit
*to get rid of no newline warnings by gcc.
*fixes to various event handlers in the ApplicationKit to compile with gcc
*since gcc does not like a member function pointer without the "&"
*addressof operator.
*Added initial file for the X11 UIToolkit implementation
*
*Revision 1.13  2002/11/18 00:46:09  ddiego
*this is the merge over of all the bug fixes and features (mostly
*VCF Builder stuff) from the devmain-0-5-8 branch
*
*Revision 1.12.10.2  2002/11/16 20:31:35  ddiego
*this fixes the following bugs:
*632802 TextControl's setViewModel not called
*639416 ListViewControl's setViewModel not called
*639417 TreeControl's setViewModel not called
*639418 ListBoxControl's setViewModel not called
*639419 ComboBoxControl's setViewModel not called
*639420 TreeListControl's setViewModel not called
*basically just required that setViewModel() get called. Also made changes to
*the TableControl and teh TabbedPages control
*
*Revision 1.12.10.1  2002/09/20 21:28:44  ddiego
*added mods to support building from the VCF Builder and display the
*console build process. Also allows for double clicking in the output
*area and being able to read the output in a generic manner
*
*Revision 1.12  2002/05/09 03:10:45  ddiego
*merged over code from development branch devmain-0-5-1a into the main CVS trunk
*
*Revision 1.11.4.2  2002/04/27 15:52:51  ddiego
*Changed a bunch of files include and made it a bit faster and added better include
*guards in the common headers
*
*Revision 1.11.4.1  2002/04/08 20:55:31  zzack
*changed include style
*
*Revision 1.11  2002/01/24 01:46:50  ddiego
*added a cvs "log" comment to the top of all files in vcf/src and vcf/include
*to facilitate change tracking
*
*/


